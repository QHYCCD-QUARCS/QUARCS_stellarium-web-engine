{"remainingRequest":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/App.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/App.vue","mtime":1760072945681},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/babel-loader/lib/index.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js","mtime":1707125450000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBfIGZyb20gJ2xvZGFzaCcKaW1wb3J0IEd1aSBmcm9tICdAL2NvbXBvbmVudHMvZ3VpLnZ1ZScKaW1wb3J0IEd1aUxvYWRlciBmcm9tICdAL2NvbXBvbmVudHMvZ3VpLWxvYWRlci52dWUnCmltcG9ydCBzd2ggZnJvbSAnQC9hc3NldHMvc3dfaGVscGVycy5qcycKaW1wb3J0IE1vbWVudCBmcm9tICdtb21lbnQnCmltcG9ydCBCYWNrZ3JvdW5kSW1hZ2UgZnJvbSAnQC9hc3NldHMvaW1hZ2VzL3N2Zy91aS9CYWNrZ3JvdW5kLnN2Zyc7CmltcG9ydCBFcnJvckltYWdlIGZyb20gJ0AvYXNzZXRzL2ltYWdlcy9zdmcvdWkvZXJyb3JJbWFnZS5zdmcnOwppbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnQC9jb21wb25lbnRzL1Byb2dyZXNzQmFyLnZ1ZSc7CgpsZXQgZ2xUZXN0Q2lyY2xlOwpsZXQgZ2xMYXllcjsKbGV0IGdsU3RlbDsKCmV4cG9ydCBkZWZhdWx0IHsKICBkYXRhKGNvbnRleHQpIHsKICAgIHJldHVybiB7CiAgICAgIG1lbnVJdGVtczogWwogICAgICAgIHsgdGl0bGU6IHRoaXMuJHQoJ1ZpZXcgU2V0dGluZ3MnKSwgaWNvbjogJ21kaS1zZXR0aW5ncycsIHN0b3JlX3Zhcl9uYW1lOiAnc2hvd1ZpZXdTZXR0aW5nc0RpYWxvZycsIHN0b3JlX3Nob3dfbWVudV9pdGVtOiAnc2hvd1ZpZXdTZXR0aW5nc01lbnVJdGVtJyB9LAogICAgICAgIHsgdGl0bGU6IHRoaXMuJHQoJ1BsYW5ldHMgVG9uaWdodCcpLCBpY29uOiAnbWRpLXBhbm9yYW1hLWZpc2hleWUnLCBzdG9yZV92YXJfbmFtZTogJ3Nob3dQbGFuZXRzVmlzaWJpbGl0eURpYWxvZycsIHN0b3JlX3Nob3dfbWVudV9pdGVtOiAnc2hvd1BsYW5ldHNWaXNpYmlsaXR5TWVudUl0ZW0nIH0sCiAgICAgICAgeyBkaXZpZGVyOiB0cnVlIH0KICAgICAgXS5jb25jYXQodGhpcy5nZXRQbHVnaW5zTWVudUl0ZW1zKCkpLmNvbmNhdChbCiAgICAgICAgeyB0aXRsZTogdGhpcy4kdCgnRGF0YSBDcmVkaXRzJyksIGZvb3RlcjogdHJ1ZSwgaWNvbjogJ21kaS1jb3B5cmlnaHQnLCBzdG9yZV92YXJfbmFtZTogJ3Nob3dEYXRhQ3JlZGl0c0RpYWxvZycgfQogICAgICBdKSwKICAgICAgbWVudUNvbXBvbmVudHM6IFtdLmNvbmNhdCh0aGlzLmdldFBsdWdpbnNNZW51Q29tcG9uZW50cygpKSwKICAgICAgZ3VpQ29tcG9uZW50OiAnR3VpTG9hZGVyJywKICAgICAgc3RhcnRUaW1lSXNTZXQ6IGZhbHNlLAogICAgICBpbml0RG9uZTogZmFsc2UsCiAgICAgIGRhdGFTb3VyY2VJbml0RG9uZTogZmFsc2UsCiAgICAgIGltYWdlU3JjOiAnaHR0cHM6Ly9pLmltZ3VyLmNvbS9lZ0E1Rkl2LmpwZWcnLCAvLyDmm7/mjaLkuLrkvaDnmoTlm77lg4/ot6/lvoQKICAgICAgY3ZSZWFkeTogZmFsc2UsCiAgICAgIGNhbnZhc1pJbmRleFN0ZWw6IC0xMCwKICAgICAgY2FudmFzWkluZGV4TWFpbkNhbWVyYTogLTExLAogICAgICBjYW52YXNaSW5kZXhHdWlkZXJDYW1lcmE6IC0xMiwKICAgICAgY3VycmVudGNhbnZhczogJ1N0ZWwnLAoKICAgICAgV2ViU29ja2V0VXJsOiAnJywKCiAgICAgIHdlYnNvY2tldDogbnVsbCwKICAgICAgbWVzc2FnZTogJycsCiAgICAgIHJlY2VpdmVkTWVzc2FnZXM6IFtdLC8vIOWtmOWCqOaOpeaUtuWIsOeahOa2iOaBrwogICAgICBzZW50TWVzc2FnZXM6IFtdLCAvLyDlrZjlgqjlt7Llj5HpgIHnmoTmtojmga8KICAgICAgbWVzc2FnZUNvdW50ZXI6IDAsIC8vIOeUqOS6jueUn+aIkOWUr+S4gOeahOa2iOaBr0lECiAgICAgIHdlYnNvY2tldFN0YXRlOiAnZGlzY29ubmVjdGVkJywgLy8g5re75YqgV2ViU29ja2V06L+e5o6l54q25oCBCiAgICAgIG5ldHdvcmtEaXNjb25uZWN0ZWQ6IGZhbHNlLCAvLyDmt7vliqDnvZHnu5zov57mjqXnirbmgIEKCiAgICAgIFFUQ2xpZW50VmVyc2lvbjogJ05vdCBjb25uZWN0ZWQnLAogICAgICBWdWVDbGllbnRWZXJzaW9uOiBwcm9jZXNzLmVudi5WVUVfQVBQX1ZFUlNJT04sCgogICAgICAvLyDmoKHlh4bkv6Hmga/lr7nosaEKICAgICAgY2FsaWJyYXRpb25JbmZvOiB7CiAgICAgICAgaXNDYWxpYnJhdGluZzogZmFsc2UsCiAgICAgICAgY2FsaWJyYXRpb25TdGF0ZTogJ2lkbGUnLAogICAgICAgIGNhbGlicmF0aW9uU3RlcDogMCwKICAgICAgICBjYWxpYnJhdGlvbk1lc3NhZ2U6ICcnCiAgICAgIH0sCgogICAgICAvLyBpc01lc3NhZ2VCb3hTaG93OiBmYWxzZSwKCiAgICAgIEN1cnJlbnREcml2ZXJUeXBlOiAnJywKICAgICAgRGV2aWNlSXNDb25uZWN0ZWQ6IG51bGwsCiAgICAgIGNvbmZpcm1Ecml2ZXJUeXBlOiAnJywKCiAgICAgIE1haW5DYW1lcmFPZmZzZXRNaW46IDAsCiAgICAgIE1haW5DYW1lcmFPZmZzZXRNYXg6IDAsCgogICAgICBNYWluQ2FtZXJhR2Fpbk1pbjogMCwKICAgICAgTWFpbkNhbWVyYUdhaW5NYXg6IDAsCgogICAgICBkZXZpY2VzOiBbCiAgICAgICAgeyBuYW1lOiAn5a+85pif6ZWcJywgZHJpdmVyVHlwZTogJ0d1aWRlcicsIHR5cGU6ICdDQ0RzJywgTGlzdE51bTogIjEiLCBpc2dldDogZmFsc2UsIGRldmljZTogJycsIEJhdWRSYXRlOiA5NjAwLCBkcml2ZXJOYW1lOiAnJywgaXNDb25uZWN0ZWQ6IGZhbHNlLCBkaWFsb2dTdGF0ZVZhcjogJ3Nob3dEZXZpY2VTZXR0aW5nc0RpYWxvZ19HdWlkZXInIH0sCiAgICAgICAgeyBuYW1lOiAn5Li755u45py6JywgZHJpdmVyVHlwZTogJ01haW5DYW1lcmEnLCB0eXBlOiAnQ0NEcycsIExpc3ROdW06ICIyMCIsIGlzZ2V0OiBmYWxzZSwgZGV2aWNlOiAnJywgQmF1ZFJhdGU6IDk2MDAsIGRyaXZlck5hbWU6ICcnLCBpc0Nvbm5lY3RlZDogZmFsc2UsIGRpYWxvZ1N0YXRlVmFyOiAnc2hvd0RldmljZVNldHRpbmdzRGlhbG9nX01haW5DYW1lcmEnIH0sCiAgICAgICAgeyBuYW1lOiAn6LWk6YGT5LuqJywgZHJpdmVyVHlwZTogJ01vdW50JywgdHlwZTogJ1RlbGVzY29wZXMnLCBMaXN0TnVtOiAiMCIsIGlzZ2V0OiBmYWxzZSwgZGV2aWNlOiAnJywgQmF1ZFJhdGU6IDk2MDAsIGRyaXZlck5hbWU6ICcnLCBpc0Nvbm5lY3RlZDogZmFsc2UsIGRpYWxvZ1N0YXRlVmFyOiAnc2hvd0RldmljZVNldHRpbmdzRGlhbG9nX01vdW50JyB9LAogICAgICAgIHsgbmFtZTogJ+acm+i/nOmVnCcsIGRyaXZlclR5cGU6ICdUZWxlc2NvcGVzJywgZGV2aWNlOiAnJywgaXNDb25uZWN0ZWQ6IHRydWUgfSwKICAgICAgICB7IG5hbWU6ICfnlLXliqjosIPnhKblmagnLCBkcml2ZXJUeXBlOiAnRm9jdXNlcicsIHR5cGU6ICdGb2N1c2VycycsIExpc3ROdW06ICIyMiIsIGlzZ2V0OiBmYWxzZSwgZGV2aWNlOiAnJywgQmF1ZFJhdGU6IDk2MDAsIGRyaXZlck5hbWU6ICcnLCBpc0Nvbm5lY3RlZDogZmFsc2UsIGRpYWxvZ1N0YXRlVmFyOiAnc2hvd0RldmljZVNldHRpbmdzRGlhbG9nX0ZvY3VzZXInIH0sCiAgICAgICAgeyBuYW1lOiAn55S15a2Q5p6B6L206ZWcJywgZHJpdmVyVHlwZTogJ1BvbGVDYW1lcmEnLCB0eXBlOiAnQ0NEcycsIExpc3ROdW06ICIyIiwgaXNnZXQ6IGZhbHNlLCBkZXZpY2U6ICcnLCBCYXVkUmF0ZTogOTYwMCwgZHJpdmVyTmFtZTogJycsIGlzQ29ubmVjdGVkOiBmYWxzZSwgZGlhbG9nU3RhdGVWYXI6ICdzaG93RGV2aWNlU2V0dGluZ3NEaWFsb2dfUG9sZUNhbWVyYScgfSwKICAgICAgICB7IG5hbWU6ICfmu6TplZzova4nLCBkcml2ZXJUeXBlOiAnQ0ZXJywgdHlwZTogJ0ZpbHRlciBXaGVlbHMnLCBMaXN0TnVtOiAiMjEiLCBpc2dldDogZmFsc2UsIGRldmljZTogJycsIEJhdWRSYXRlOiA5NjAwLCBkcml2ZXJOYW1lOiAnJywgaXNDb25uZWN0ZWQ6IGZhbHNlLCBkaWFsb2dTdGF0ZVZhcjogJ3Nob3dEZXZpY2VTZXR0aW5nc0RpYWxvZ19DRlcnIH0sCiAgICAgIF0sCgogICAgICAvLyBDaGFuZ2luZyB0aGUgbGFiZWwgbmFtZSBhbHNvIHJlcXVpcmVzIGNoYW5naW5nIHRoZSBlbWl0IHNpZ25hbCBuYW1lCiAgICAgIEd1aWRlckNvbmZpZ0l0ZW1zOiBbCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnR3VpZGVyJywgbGFiZWw6ICdHdWlkZXIgRm9jYWwgTGVuZ3RoIChtbSknLCB2YWx1ZTogJycsIGlucHV0VHlwZTogJ3RleHQnIH0sCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnR3VpZGVyJywgbGFiZWw6ICdNdWx0aSBTdGFyIEd1aWRlcicsIHZhbHVlOiBmYWxzZSwgaW5wdXRUeXBlOiAnc3dpdGNoJyB9LAogICAgICAgIC8vIHsgZHJpdmVyVHlwZTogJ0d1aWRlcicsIGxhYmVsOiAnR3VpZGVyIFBpeGVsIHNpemUnLCB2YWx1ZTogJycsIGlucHV0VHlwZTogJ3RleHQnfSwKICAgICAgICB7IGRyaXZlclR5cGU6ICdHdWlkZXInLCBsYWJlbDogJ0d1aWRlciBHYWluJywgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICdzbGlkZXInLCBpbnB1dE1pbjogMCwgaW5wdXRNYXg6IDEwMCwgaW5wdXRTdGVwOiAxIH0sCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnR3VpZGVyJywgbGFiZWw6ICdDYWxpYnJhdGlvbiBzdGVwIChtcyknLCB2YWx1ZTogJycsIGlucHV0VHlwZTogJ3RleHQnIH0sCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnR3VpZGVyJywgbGFiZWw6ICdSYSBBZ2dyZXNzaW9uJywgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICdzbGlkZXInLCBpbnB1dE1pbjogMCwgaW5wdXRNYXg6IDEwMCwgaW5wdXRTdGVwOiAxIH0sCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnR3VpZGVyJywgbGFiZWw6ICdEZWMgQWdncmVzc2lvbicsIHZhbHVlOiAnJywgaW5wdXRUeXBlOiAnc2xpZGVyJywgaW5wdXRNaW46IDAsIGlucHV0TWF4OiAxMDAsIGlucHV0U3RlcDogMSB9LAoKICAgICAgXSwKCiAgICAgIE1haW5DYW1lcmFDb25maWdJdGVtczogWwogICAgICAgIC8vIHZ1ZeWkhOeQhuWPguaVsAogICAgICAgIHsgZHJpdmVyVHlwZTogJ01haW5DYW1lcmEnLCBsYWJlbDogJ0ltYWdlQ0ZBJywgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICdzZWxlY3QnLCBzZWxlY3RWYWx1ZTogWydHUicsICdHQicsICdCRycsICdSR0dCJywgJ251bGwnXSB9LAogICAgICAgIC8vIOehrOS7tuWkhOeQhuWPguaVsAogICAgICAgIHsgZHJpdmVyVHlwZTogJ01haW5DYW1lcmEnLCBsYWJlbDogJ0Jpbm5pbmcnLCB2YWx1ZTogJycsIGlucHV0VHlwZTogJ3NsaWRlcicsIGlucHV0TWluOiAxLCBpbnB1dE1heDogMTYsIGlucHV0U3RlcDogMSB9LAogICAgICAgIHsgZHJpdmVyVHlwZTogJ01haW5DYW1lcmEnLCBsYWJlbDogJ1RlbXBlcmF0dXJlJywgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICdzZWxlY3QnLCBzZWxlY3RWYWx1ZTogWzUsIDAsIC01LCAtMTAsIC0xNSwgLTIwLCAtMjVdIH0sCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnTWFpbkNhbWVyYScsIGxhYmVsOiAnR2FpbicsIHZhbHVlOiAnJywgaW5wdXRUeXBlOiAnc2xpZGVyJywgaW5wdXRNaW46IDAsIGlucHV0TWF4OiAwLCBpbnB1dFN0ZXA6IDEgfSwKICAgICAgICB7IGRyaXZlclR5cGU6ICdNYWluQ2FtZXJhJywgbGFiZWw6ICdPZmZzZXQnLCB2YWx1ZTogJycsIGlucHV0VHlwZTogJ3NsaWRlcicsIGlucHV0TWluOiAwLCBpbnB1dE1heDogMCwgaW5wdXRTdGVwOiAxIH0sCiAgICAgIF0sCgogICAgICBNb3VudENvbmZpZ0l0ZW1zOiBbCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnTW91bnQnLCBsYWJlbDogJ0ZsaXAgRVRBJywgdmFsdWU6ICcwMDowMDowMCcsIGRpc3BsYXlWYWx1ZTogJzAwOjAwOjAwJywgaW5wdXRUeXBlOiAndGlwJyB9LAogICAgICAgIHsgZHJpdmVyVHlwZTogJ01vdW50JywgbGFiZWw6ICdHb3RvVGhlblNvbHZlJywgdmFsdWU6IGZhbHNlLCBpbnB1dFR5cGU6ICdzd2l0Y2gnIH0sCgogICAgICAgIC8vIHsgZHJpdmVyVHlwZTogJ01vdW50JywgbGFiZWw6ICdpc0F1dG9GbGlwJywgdmFsdWU6IGZhbHNlLCBpbnB1dFR5cGU6ICdzd2l0Y2gnIH0sCiAgICAgIF0sCgogICAgICBUZWxlc2NvcGVzQ29uZmlnSXRlbXM6IFsKICAgICAgICB7IGRyaXZlclR5cGU6ICdUZWxlc2NvcGVzJywgbnVtOiAxLCBsYWJlbDogJ0ZvY2FsIExlbmd0aCAobW0pJywgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICdudW1iZXInIH0sCiAgICAgIF0sCgogICAgICBGb2N1c2VyQ29uZmlnSXRlbXM6IFsKICAgICAgICB7IGRyaXZlclR5cGU6ICdGb2N1c2VyJywgbnVtOiAyLCBsYWJlbDogJ1N5bmMgRm9jdXNlciBTdGVwJywgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICd0ZXh0JyB9LAogICAgICAgIHsgZHJpdmVyVHlwZTogJ0ZvY3VzZXInLCBudW06IDIsIGxhYmVsOiAnTWluIExpbWl0JywgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICdudW1iZXInIH0sCiAgICAgICAgeyBkcml2ZXJUeXBlOiAnRm9jdXNlcicsIG51bTogMiwgbGFiZWw6ICdNYXggTGltaXQnLCB2YWx1ZTogJycsIGlucHV0VHlwZTogJ251bWJlcicgfSwKICAgICAgXSwKCiAgICAgIFBvbGVDYW1lcmFDb25maWdJdGVtczogWwoKICAgICAgXSwKCiAgICAgIENGV0NvbmZpZ0l0ZW1zOiBbCgogICAgICBdLAoKICAgICAgQmVmb3JlQ2hhbmdlQ29uZmlnSXRlbXM6IFtdLAoKCgogICAgICBpbWFnZURhdGE6IG51bGwsCgogICAgICBoaXN0b2dyYW1JbWFnZTogbnVsbCwKICAgICAgaGlzdG9ncmFtX21pbjogMCwgICAgLy8g55u05pa55Zu+6Ieq5Yqo5ouJ5Ly455qE5pyA5bCP5YC8CiAgICAgIGhpc3RvZ3JhbV9tYXg6IDI1NSwgIC8vIOebtOaWueWbvuiHquWKqOaLieS8uOeahOacgOWkp+WAvAoKICAgICAgY3VycmVudEhpc3RvZ3JhbU1pbjogMCwKICAgICAgY3VycmVudEhpc3RvZ3JhbU1heDogMjU1LAoKICAgICAgSW1hZ2VHYWluUjogMSwKICAgICAgSW1hZ2VHYWluQjogMSwKCiAgICAgIEltYWdlT2Zmc2V0OiAwLAoKICAgICAgSW1hZ2VDRkE6ICdCRycsCgogICAgICBjYW1lcmFCaW46IDEsICAgLy8g5b2T5YmN55u45py6YmlubmluZwoKICAgICAgQ2FudmFzV2lkdGg6IDE5MjAsICAvLyDkuLvnlLvluIPlrr3luqYKICAgICAgQ2FudmFzSGVpZ2h0OiAxMDgwLCAvLyDkuLvnlLvluIPpq5jluqYKCiAgICAgIHNjYWxlOiAxLCAvLyDnvKnmlL7mr5TkvosKICAgICAgdHJhbnNsYXRlWDogMCwgLy8g5bmz56e7eOWdkOaghwogICAgICB0cmFuc2xhdGVZOiAwLCAvLyDlubPnp7t55Z2Q5qCHCiAgICAgIGJ1ZmZlckNhbnZhczogbnVsbCwgLy8g5a2Y5YKo55S75biDCiAgICAgIGJ1ZmZlckN0eDogbnVsbCwgLy8g5a2Y5YKo55S75biD5LiK5LiL5paHCiAgICAgIHRlbXBDYW52YXM6IG51bGwsIC8vIOS4tOaXtueUu+W4gwogICAgICB0ZW1wQ3R4OiBudWxsLCAvLyDkuLTml7bnlLvluIPkuIrkuIvmlocKCiAgICAgIHZpc2libGVXaWR0aDogMCwgLy8g5Y+v6KeB5Yy65Z+f5a695bqmCiAgICAgIHZpc2libGVIZWlnaHQ6IDAsIC8vIOWPr+ingeWMuuWfn+mrmOW6pgogICAgICB2aXNpYmxlWDogMCwgLy8g5Y+v6KeB5Yy65Z+feOWdkOaghwogICAgICB2aXNpYmxlWTogMCwgLy8g5Y+v6KeB5Yy65Z+feeWdkOaghwogICAgICBpc0RyYWdnaW5nOiBmYWxzZSwgLy8g5qCH6K6w55S75biD5piv5ZCm5q2j5Zyo5ouW5YqoCiAgICAgIHBlbmRpbmdTY2FsZUNoYW5nZTogZmFsc2UsIC8vIOagh+iusOeUu+W4g+aYr+WQpuato+WcqOe8qeaUvgoKICAgICAgdG91Y2hTdGFydFg6IDAsIC8vIOinpuaRuOW8gOWni3jlnZDmoIcKICAgICAgdG91Y2hTdGFydFk6IDAsIC8vIOinpuaRuOW8gOWni3nlnZDmoIcKICAgICAgc3RhcnREaXN0YW5jZTogMCwgLy8g6Kem5pG45byA5aeL6Led56a7CgogICAgICBtb3ZlSW50ZXJ2YWxJZDogbnVsbCwgLy8g5ouW5Yqo5a6a5pe25ZmoCiAgICAgIHpvb21JbnRlcnZhbElkOiBudWxsLCAvLyDnvKnmlL7lrprml7blmagKCgogICAgICBpbWFnZVdpZHRoOiAwLCAvLyDlm77lg4/lrr3luqYKICAgICAgaW1hZ2VIZWlnaHQ6IDAsIC8vIOWbvuWDj+mrmOW6pgogICAgICBkcmF3SW1nRGF0YTogbnVsbCwKICAgICAgT3JpZ2luYWxJbWFnZTogbnVsbCwKICAgICAgZGV0ZWN0U3RhcnNJbWc6IG51bGwsCgogICAgICBpc05vdERyYXdTdGFyczogdHJ1ZSwKCiAgICAgIG1haW5DYW1lcmFTaXplWDogMCwKICAgICAgbWFpbkNhbWVyYVNpemVZOiAwLAoKICAgICAgSW1hZ2VQcm9wb3J0aW9uOiAwLAoKICAgICAgRGV0ZWN0ZWRTdGFyc0xpc3Q6IFtdLAogICAgICBEZXRlY3RlZFN0YXJzRmluaXNoOiBmYWxzZSwKCiAgICAgIENhcnRlc2lhbkxpc3Q6IFtdLAoKICAgICAgUG9sYXJQb2ludF9BbHRpdHVkZTogMCwKCiAgICAgIExhc3RQb2ludF9BekFsdDogbnVsbCwKCiAgICAgIE1hcmtDaXJjbGVOdW06IDAsCgogICAgICBMYXN0Q2lyY2xlX1JhRGVjOiBudWxsLAogICAgICBMYXN0Q2lyY2xlX0F6QWx0OiBudWxsLAoKICAgICAgQ2lyY2xlczogW10sCgogICAgICAvLyDmnoHovbTmoKHlh4bnm7jlhbPmlbDnu4QKICAgICAgY2FsaWJyYXRpb25DaXJjbGVzOiBbXSwgIC8vIOagoeWHhueCueWchuWciOaVsOe7hAogICAgICBhZGp1c3RtZW50Q2lyY2xlczogW10sICAgLy8g6LCD5pW054K55ZyG5ZyI5pWw57uECiAgICAgIHRhcmdldFBvaW50Q2lyY2xlOiBudWxsLCAvLyDnm67moIfngrnlnIblvaLlr7nosaEKICAgICAgZmFrZVBvbGFyQXhpc0NpcmNsZTogbnVsbCwgLy8g5YGH5p6B54K55ZyG5b2i5a+56LGhCiAgICAgIGxhc3RQb3NpdGlvbjogbnVsbCwgICAgICAvLyDkuIrkuIDmrKHkvY3nva4KICAgICAgZmllbGRVcGRhdGVUaW1lcjogbnVsbCwgIC8vIOinhuWcuuabtOaWsOWumuaXtuWZqAogICAgICBmaWVsZE9mVmlld1BvbHlnb25zOiBbXSwgLy8g5a2Y5YKo6KeG5Zy65aSa6L655b2i5a+56LGhCgogICAgICBkcmF3ZXJfMjogbnVsbCwgICAgLy8g6K6+572u5L6n6L655qCP55qE5pi+56S65LiO6ZqQ6JePCgogICAgICBkcml2ZXJzOiBbXSwgLy8g6amx5Yqo6YCJ6aG55pWw57uECiAgICAgIHNlbGVjdGVkRHJpdmVyOiBudWxsLCAvLyDpgInkuK3nmoTpqbHliqgKCiAgICAgIGRldmljZXNMaXN0OiBbXSwgLy8g6K6+5aSH6YCJ6aG55pWw57uECiAgICAgIHNlbGVjdGVkRGV2aWNlOiBudWxsLCAvLyDpgInkuK3nmoTorr7lpIcKICAgICAgVG9CZUNvbm5lY3REZXZpY2U6IFtdLAoKICAgICAgbG9hZGluZ1NlbGVjdERyaXZlcjogZmFsc2UsCiAgICAgIGxvYWRpbmdDb25uZWN0QWxsRGV2aWNlOiBmYWxzZSwKCiAgICAgIEN1cnJlbnRMb2NhdGlvbkxuZzogMCwKICAgICAgQ3VycmVudExvY2F0aW9uTGF0OiAwLAoKICAgICAgaGlzdG9ncmFtRGF0YTogW10sCgogICAgICBJbWFnZUFycmF5QnVmZmVyOiBudWxsLAoKICAgICAgaXNPcGVuRGV2aWNlUGFnZTogZmFsc2UsIC8vIOiuvue9ruiuvuWkh+mhtemdouaYr+WQpuaJk+W8gAogICAgICBpc09wZW5Qb3dlclBhZ2U6IGZhbHNlLCAvLyDorr7nva7nlLXmupDpobXpnaLmmK/lkKbmiZPlvIAKCiAgICAgIE91dFB1dFBvd2VyXzFfT046IHRydWUsCiAgICAgIE91dFB1dFBvd2VyXzJfT046IGZhbHNlLAoKICAgICAgaXNQb2xhckF4aXNNb2RlOiBmYWxzZSwKCiAgICAgIGlzVG91Y2hpbmc6IGZhbHNlLCAvLyDmoIforrDmmK/lkKbmraPlnKjlpITnkIbop6bmkbjkuovku7YKICAgICAgQ29ubmVjdEJ0blByZXNzVGltZXI6IG51bGwsCiAgICAgIENvbm5lY3RCdG5sb25nUHJlc3NUaHJlc2hvbGQ6IDEwMDAsCiAgICAgIGlzQ29ubmVjdEJ0bkxvbmdQcmVzczogZmFsc2UsIC8vIOagh+iusOaYr+WQpuS4uumVv+aMiQogICAgICBDb25uZWN0QnRuQ2FuQ2xpY2s6IHRydWUsCgoKICAgICAgaGF2ZURldmljZUNvbm5lY3Q6IGZhbHNlLAogICAgICBpc0Nvbm5lY3Rpbmc6IGZhbHNlLCAvLyDmt7vliqDov57mjqXnirbmgIEKCiAgICAgIGRpc2Nvbm5lY3RUaW1lb3V0VHJpZ2dlcmVkOiBmYWxzZSwKICAgICAgZGlzY29ubmVjdFRpbWVvdXQ6IG51bGwsCgogICAgICBpc0Rvd25sb2FkaW5nSW1hZ2U6IGZhbHNlLAogICAgICBpc0Rvd25sb2FkaW5nSW1hZ2VOYW1lOiAnJywKICAgICAgaXNXYWl0aW5nTG9nZ2VkOiBmYWxzZSwgLy8g5re75Yqg562J5b6F5pel5b+X5qCH5b+XCgogICAgICBzaG93RGlzY29ubmVjdERpYWxvZzogZmFsc2UsCiAgICAgIGN1cnJlbnREaXNjb25uZWN0RHJpdmVyTmFtZTogJycsCgogICAgICBlbmFibGVNYWluQ2FudmFzQ2xpY2s6IGZhbHNlLCAvLyDmjqfliLbnlLvluIPmmK/lkKblj6/ku6Xngrnlh7vvvIznlKjmnaXnp7vliqjosIPnhKbpgInmi6nmoYblkozpgInmmJ8KCiAgICAgIGxhc3RJbWFnZVByb2Nlc3NQYXJhbXM6IHsgLy8g5pyA5ZCO5aSE55CG5Zu+5YOP55qE5Y+C5pWwCiAgICAgICAgYmxhY2tMZXZlbDogMCwKICAgICAgICB3aGl0ZUxldmVsOiA2NTUzNSwKICAgICAgICBDRkE6ICdudWxsJywKICAgICAgICBhbmFseXNpczogbnVsbCwKICAgICAgICBpc0NvbG9yQ2FtZXJhOiBmYWxzZSwKICAgICAgfSwKICAgICAgZm9jdXNlclBpY3R1cmVGaWxlTmFtZTogJycsICAvLyDnhKbot53lm77niYfmlofku7blkI0KICAgICAgaXNQcm9jZXNzaW5nSW1hZ2U6IGZhbHNlLCAgIC8vIOaOp+WItuaYr+WQpuato+WcqOWkhOeQhuWbvuWDjwogICAgICBpc0ZvY3VzTG9vcFNob290aW5nOiBmYWxzZSwgIC8vIOaOp+WItuaYr+WQpui/m+ihjFJPaeW+queOr+aLjeaRhAogICAgICBmb2N1c2VyUk9JU3RhcnNMaXN0OiBbXSwgIC8vIOeUqOadpeS/neWtmFJPSeWMuuWfn+eahOaYn+eCueWIl+ihqO+8jOWIhuWIq+S/neWtmHgseSxIRlIKICAgICAgc2VsZWN0U3Rhclg6IC0xLAogICAgICBzZWxlY3RTdGFyWTogLTEsCiAgICAgIERyYXdTZWxlY3RTdGFyWDogLTEsCiAgICAgIERyYXdTZWxlY3RTdGFyWTogLTEsCiAgICAgIERyYXdTZWxlY3RTdGFySEZSOiAtMSwKICAgICAgUk9JX3g6IC0xLCAgICAvLyDnlKjmnaXkv53lrZhST0nljLrln5/nmoR45Z2Q5qCHLOWcqHZ1ZeS4reiuoeeulwogICAgICBST0lfeTogLTEsICAgIC8vIOeUqOadpeS/neWtmFJPSeWMuuWfn+eahHnlnZDmoIcs5ZyodnVl5Lit6K6h566XCiAgICAgIFJPSV94X3F0OiAtMSwgICAgLy8g55So5p2l5L+d5a2YUk9J5Yy65Z+f55qEeOWdkOaghyzlnKhxdOS4reiuoeeulwogICAgICBST0lfeV9xdDogLTEsICAgIC8vIOeUqOadpeS/neWtmFJPSeWMuuWfn+eahHnlnZDmoIcs5ZyocXTkuK3orqHnrpcKICAgICAgUk9JX2xlbmd0aDogMzAwLCAvLyDnlKjmnaXkv53lrZhST0nljLrln5/nmoTplb/luqYKICAgICAgc2hvd1NlbGVjdFN0YXI6IGZhbHNlLAoKICAgICAgaXNPbmVUb3VjaDogZmFsc2UsCiAgICAgIGN1cnJlbnRUb3VjaFg6IFswLCAwXSwKICAgICAgY3VycmVudFRvdWNoWTogWzAsIDBdLAogICAgICBzdGFydFRvdWNoWDogWzAsIDBdLAogICAgICBzdGFydFRvdWNoWTogWzAsIDBdLAogICAgICBzdGFydFRvdWNoRGlzdGFuY2U6IDAsCgogICAgICAvLyDlrprkuYnms6LnibnnjofpgInpobkKICAgICAgQmF1ZFJhdGVJdGVtczogWwogICAgICAgIHsgbGFiZWw6ICc5NjAwJywgdmFsdWU6IDk2MDAgfSwKICAgICAgICB7IGxhYmVsOiAnMTkyMDAnLCB2YWx1ZTogMTkyMDAgfSwKICAgICAgICB7IGxhYmVsOiAnMzg0MDAnLCB2YWx1ZTogMzg0MDAgfSwKICAgICAgICB7IGxhYmVsOiAnNTc2MDAnLCB2YWx1ZTogNTc2MDAgfSwKICAgICAgICB7IGxhYmVsOiAnMTE1MjAwJywgdmFsdWU6IDExNTIwMCB9LAogICAgICAgIHsgbGFiZWw6ICcyMzA0MDAnLCB2YWx1ZTogMjMwNDAwIH0sCiAgICAgIF0sCiAgICAgIEJhdWRSYXRlU2VsZWN0ZWQ6IDk2MDAsIC8vIOazoueJueeOh+mAieaLqQogICAgICBjcHVUZW1wOiBudWxsLCAgLy8gQ1BV5rip5bqmCiAgICAgIGNwdVVzYWdlOiBudWxsLCAvLyBDUFXkvb/nlKjnjocKCiAgICAgIHByb2dyZXNzVmFsdWU6IDAsLy8g5o6n5Yi25Zu+5YOP5aSE55CG6L+b5bqm5p2h55qE5Y+Y6YePCiAgICAgIHByb2dyZXNzRGVzY3JpcHRpb246ICcnLCAvLyDmjqfliLbov5vluqbmnaHmmL7npLrlhoXlrrkKCiAgICAgIGNhbGN1bGF0ZUdhaW46IHRydWUsIC8vIOaOp+WItuaYr+WQpuiuoeeul+eZveW5s+ihoeWinuebigogICAgICBsdXRDYWNoZTogewogICAgICAgIGxhc3RQYXJhbXM6IG51bGwsIC8vIOeUqOS6juWtmOWCqOS4iuasoeeahOWPguaVsAogICAgICAgIGx1dFI6IG51bGwsCiAgICAgICAgbHV0RzogbnVsbCwKICAgICAgICBsdXRCOiBudWxsCiAgICAgIH0sCiAgICB9CiAgfSwKICBjb21wb25lbnRzOiB7CiAgICBHdWksCiAgICBHdWlMb2FkZXIsCiAgICBQcm9ncmVzc0JhciwKICAgIC8vIE1lc3NhZ2VCb3gsCiAgfSwKICBjcmVhdGVkKCkgewogICAgdGhpcy4kYnVzLiRvbignQXBwU2VuZE1lc3NhZ2UnLCB0aGlzLnNlbmRNZXNzYWdlKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0FwcFVwZGF0ZURldmljZXMnLCB0aGlzLnVwZGF0ZURldmljZXMpOwogICAgdGhpcy4kYnVzLiRvbignU3dpdGNoLU1haW5QYWdlJywgdGhpcy5oYW5kbGVCdXR0b25UZXN0Q2xpY2spOwogICAgdGhpcy4kYnVzLiRvbignSGFuZGxlSGlzdG9ncmFtTnVtJywgdGhpcy5hcHBseUhpc3RTdHJldGNoKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0ltYWdlR2FpblInLCB0aGlzLkltYWdlR2FpblNldCk7CiAgICB0aGlzLiRidXMuJG9uKCdJbWFnZUdhaW5CJywgdGhpcy5JbWFnZUdhaW5TZXQpOwogICAgdGhpcy4kYnVzLiRvbignT2Zmc2V0JywgdGhpcy5JbWFnZU9mZnNldFNldCk7CiAgICB0aGlzLiRidXMuJG9uKCdCaW5uaW5nJywgdGhpcy5CaW5uaW5nU2V0KTsKICAgIHRoaXMuJGJ1cy4kb24oJ0dhaW4nLCB0aGlzLkdhaW5TZXQpOwogICAgdGhpcy4kYnVzLiRvbignT2Zmc2V0JywgdGhpcy5PZmZzZXRTZXQpOwogICAgdGhpcy4kYnVzLiRvbignSW1hZ2VDRkEnLCB0aGlzLkltYWdlQ0ZBU2V0KTsKICAgIC8vIHRoaXMuJGJ1cy4kb24oJ01haW5DYW1lcmFDRkEnLCB0aGlzLkltYWdlQ0ZBU2V0KTsKICAgIHRoaXMuJGJ1cy4kb24oJ1RlbXBlcmF0dXJlJywgdGhpcy5DYW1lcmFUZW1wZXJhdHVyZVNldCk7CiAgICB0aGlzLiRidXMuJG9uKCdGb2NhbCBMZW5ndGggKG1tKScsIHRoaXMuRm9jYWxMZW5ndGhTZXQpOwogICAgdGhpcy4kYnVzLiRvbignR3VpZGVyIEZvY2FsIExlbmd0aCAobW0pJywgdGhpcy5HdWlkZXJGb2NhbExlbmd0aFNldCk7CiAgICB0aGlzLiRidXMuJG9uKCdNdWx0aSBTdGFyIEd1aWRlcicsIHRoaXMuTXVsdGlTdGFyR3VpZGVyU2V0KTsKICAgIHRoaXMuJGJ1cy4kb24oJ0d1aWRlciBQaXhlbCBzaXplJywgdGhpcy5HdWlkZXJQaXhlbFNpemVTZXQpOwogICAgdGhpcy4kYnVzLiRvbignR3VpZGVyIEdhaW4nLCB0aGlzLkd1aWRlckdhaW5TZXQpOwogICAgdGhpcy4kYnVzLiRvbignQ2FsaWJyYXRpb24gc3RlcCAobXMpJywgdGhpcy5DYWxpYnJhdGlvbkR1cmF0aW9uU2V0KTsKICAgIHRoaXMuJGJ1cy4kb24oJ1JhIEFnZ3Jlc3Npb24nLCB0aGlzLlJhQWdncmVzc2lvblNldCk7CiAgICB0aGlzLiRidXMuJG9uKCdEZWMgQWdncmVzc2lvbicsIHRoaXMuRGVjQWdncmVzc2lvblNldCk7CiAgICB0aGlzLiRidXMuJG9uKCdTeW5jIEZvY3VzZXIgU3RlcCcsIHRoaXMuU3luY0ZvY3VzZXJTdGVwKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0dvdG9UaGVuU29sdmUnLCB0aGlzLkdvdG9UaGVuU29sdmUpOwogICAgdGhpcy4kYnVzLiRvbignQXV0b0ZsaXAnLCB0aGlzLkF1dG9GbGlwU2V0KTsKICAgIHRoaXMuJGJ1cy4kb24oJ1dlc3RNaW51dGVzUGFzdE1lcmlkaWFuJywgdGhpcy5XZXN0TWludXRlc1Bhc3RNZXJpZGlhblNldCk7CiAgICB0aGlzLiRidXMuJG9uKCdFYXN0TWludXRlc1Bhc3RNZXJpZGlhbicsIHRoaXMuRWFzdE1pbnV0ZXNQYXN0TWVyaWRpYW5TZXQpOwogICAgdGhpcy4kYnVzLiRvbignSW1hZ2VQcm9wb3J0aW9uJywgdGhpcy5zZXRJbWFnZVByb3BvcnRpb24pOwogICAgdGhpcy4kYnVzLiRvbignTW91bnRHb3RvJywgdGhpcy5sb29rYXRjaXJjbGUpOwogICAgdGhpcy4kYnVzLiRvbignU3dpdGNoSW1hZ2VUb1Nob3cnLCB0aGlzLlN3aXRjaEltYWdlVG9TaG93KTsKICAgIHRoaXMuJGJ1cy4kb24oJ1BvbGFyUG9pbnRBbHRpdHVkZScsIHRoaXMuc2V0UG9sYXJQb2ludEFsdGl0dWRlKTsKICAgIHRoaXMuJGJ1cy4kb24oJ3Nob3dTdGVsQ2FudmFzJywgdGhpcy5zaG93U3RlbENhbnZhcyk7CiAgICB0aGlzLiRidXMuJG9uKCdSZWNhbGlicmF0ZVBvbGFyQXhpcycsIHRoaXMuUmVjYWxpYnJhdGVQb2xhckF4aXMpOwogICAgdGhpcy4kYnVzLiRvbignQ3VycmVudEV4cFRpbWVMaXN0JywgdGhpcy5DdXJyZW50RXhwVGltZUxpc3QpOwogICAgdGhpcy4kYnVzLiRvbignZGlzY29ubmVjdEFsbERldmljZScsIHRoaXMuZGlzY29ubmVjdEFsbERldmljZSk7CiAgICB0aGlzLiRidXMuJG9uKCdHZXRDb25uZWN0ZWREZXZpY2VzJywgdGhpcy5SZXR1cm5Db25uZWN0ZWREZXZpY2VzKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0N1cnJlbnRDRldMaXN0JywgdGhpcy5DdXJyZW50Q0ZXTGlzdCk7CiAgICB0aGlzLiRidXMuJG9uKCdjYWxjV2hpdGVCYWxhbmNlR2FpbnMnLCB0aGlzLmNhbGNXaGl0ZUJhbGFuY2VHYWlucyk7CiAgICB0aGlzLiRidXMuJG9uKCdTd2l0Y2hPdXRQdXRQb3dlcicsIHRoaXMuU3dpdGNoT3V0UHV0UG93ZXIpOwogICAgdGhpcy4kYnVzLiRvbignUG9sYXJBeGlzTW9kZScsIHRoaXMuUG9sYXJBeGlzTW9kZSk7CiAgICB0aGlzLiRidXMuJG9uKCdTZW5kQ29uc29sZUxvZ01zZycsIHRoaXMuU2VuZENvbnNvbGVMb2dNc2cpOwogICAgLy8gdGhpcy4kYnVzLiRvbignRGlzY29ubmVjdERyaXZlclN1Y2Nlc3MnLCB0aGlzLmRpc2Nvbm5lY3REcml2ZXJzdWNjZXNzKTsKICAgIHRoaXMuJGJ1cy4kb24oJ1VuQmluZGluZ0RldmljZScsIHRoaXMuVW5CaW5kaW5nRGV2aWNlKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0Nsb3NlV2ViVmlldycsIHRoaXMuUXVpdFRvTWFpbkFwcCkKICAgIHRoaXMuJGJ1cy4kb24oJ1JlZEJveFNpemVDaGFuZ2UnLCB0aGlzLlJlZEJveFNpemVDaGFuZ2UpOwogICAgdGhpcy4kYnVzLiRvbignc2V0Rm9jdXNlclN0YXRlJywgdGhpcy5zZXRGb2N1c2VyU3RhdGUpOyAgLy8g6K6+572u6LCD54Sm54q25oCB5ZKM6L+b5bqmCiAgICB0aGlzLiRidXMuJG9uKCdzZXRTaG93U2VsZWN0U3RhcicsIHRoaXMuc2V0U2hvd1NlbGVjdFN0YXIpOyAgLy8g6K6+572u5piv5ZCm5pi+56S66YCJ5oup5pif54K5CiAgICB0aGlzLiRidXMuJG9uKCdTY2FsZUNoYW5nZScsIHRoaXMuU2NhbGVDaGFuZ2UpOwogICAgdGhpcy4kYnVzLiRvbignc2hvd0NhbnZhcycsIHRoaXMuc2hvd0NhbnZhcyk7CgogICAgLy8g5p6B6L205qCh5YeG57uY5Yi255u45YWz55uR5ZCs5ZmoCiAgICB0aGlzLiRidXMuJG9uKCdEcmF3Q2FsaWJyYXRpb25Qb2ludFBvbHlnb24nLCB0aGlzLmRyYXdDYWxpYnJhdGlvblBvaW50UG9seWdvbik7CiAgICB0aGlzLiRidXMuJG9uKCdDbGVhckNhbGlicmF0aW9uUG9pbnRzJywgdGhpcy5jbGVhckNhbGlicmF0aW9uUG9pbnRzKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0RyYXdBZGp1c3RtZW50UG9pbnRzUG9seWdvbicsIHRoaXMuZHJhd0FkanVzdG1lbnRQb2ludHNQb2x5Z29uKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0RyYXdUYXJnZXRQb2ludENpcmNsZScsIHRoaXMuZHJhd1RhcmdldFBvaW50Q2lyY2xlKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0RyYXdGYWtlUG9sYXJBeGlzQ2lyY2xlJywgdGhpcy5EcmF3RmFrZVBvbGFyQXhpc0NpcmNsZSkKCiAgICAvLyDmoKHlh4bnm7jlhbPkuovku7bnm5HlkKzlmagKICAgIHRoaXMuJGJ1cy4kb24oJ1N0YXJ0Q2FsaWJyYXRpb24nLCB0aGlzLnN0YXJ0Q2FsaWJyYXRpb25Qcm9jZXNzKTsKICAgIHRoaXMuJGJ1cy4kb24oJ1VwZGF0ZUNhbGlicmF0aW9uSW5mbycsIHRoaXMudXBkYXRlQ2FsaWJyYXRpb25JbmZvKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0VuZENhbGlicmF0aW9uJywgdGhpcy5lbmRDYWxpYnJhdGlvbik7CgogICAgdGhpcy5tZW1vcnlDaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja01lbW9yeVVzYWdlLCAzMDAwMCk7CgoKICB9LAogIG1ldGhvZHM6IHsKICAgIC8vIOaYr+WQpuWFgeiuuOWwj+aVsO+8mnN0ZXAg5LiN5piv5pW05pWw77yM5oiW5pi+5byP5YWB6K64CiAgICBhbGxvd3NEZWNpbWFsKGl0ZW0pIHsKICAgICAgY29uc3Qgc3RlcCA9IGl0ZW0uc3RlcCA/PyAxOwogICAgICByZXR1cm4gaXRlbS5hbGxvd0RlY2ltYWwgPT09IHRydWUgfHwgIU51bWJlci5pc0ludGVnZXIoc3RlcCkgfHwgU3RyaW5nKHN0ZXApLmluY2x1ZGVzKCcuJyk7CiAgICB9LAogICAgLy8g5piv5ZCm5YWB6K646LSf5pWw77ya5qC55o2u6YWN572u5oiWIG1pbjwwIOeMnOa1iwogICAgYWxsb3dzTmVnYXRpdmUoaXRlbSkgewogICAgICByZXR1cm4gaXRlbS5hbGxvd05lZ2F0aXZlID09PSB0cnVlIHx8ICh0eXBlb2YgaXRlbS5taW4gPT09ICdudW1iZXInICYmIGl0ZW0ubWluIDwgMCk7CiAgICB9LAogICAgLy8g56e75Yqo56uv6ZSu55uY57G75Z6LCiAgICBnZXRJbnB1dE1vZGUoaXRlbSkgewogICAgICAvLyDku4Xnp7vliqjnq6/nlJ/mlYjvvJvmoYzpnaLlv73nlaUKICAgICAgaWYgKCF0aGlzLmlzTW9iaWxlKSByZXR1cm4gdW5kZWZpbmVkOwogICAgICAvLyDpnIDopoHlsI/mlbDmiJbotJ/mlbDvvIznlKggZGVjaW1hbO+8iOabtOWuueaYk+WHuueOsOWwj+aVsOeCuS/otJ/lj7fvvIkKICAgICAgcmV0dXJuIHRoaXMuYWxsb3dzRGVjaW1hbChpdGVtKSB8fCB0aGlzLmFsbG93c05lZ2F0aXZlKGl0ZW0pID8gJ2RlY2ltYWwnIDogJ251bWVyaWMnOwogICAgfSwKICAgIC8vIOmFjeWQiCBpT1PvvJpwYXR0ZXJuIOWPr+W9seWTjeW8ueWHuumUruebmOS4juagoemqjAogICAgZ2V0UGF0dGVybihpdGVtKSB7CiAgICAgIGNvbnN0IG5lZyA9IHRoaXMuYWxsb3dzTmVnYXRpdmUoaXRlbSk7CiAgICAgIGlmICh0aGlzLmFsbG93c0RlY2ltYWwoaXRlbSkpIHsKICAgICAgICAvLyDlhYHorrggLiDmiJYgLCDkvZzkuLrlsI/mlbDngrnvvIzkvr/kuo7kuI3lkIzor63oqIDplK7nm5gKICAgICAgICByZXR1cm4gbmVnID8gJ15bLV0/WzAtOV0qKFsuLF1bMC05XSopPyQnIDogJ15bMC05XSooWy4sXVswLTldKik/JCc7CiAgICAgIH0KICAgICAgLy8g5pW05pWwCiAgICAgIHJldHVybiBuZWcgPyAnXlstXT9bMC05XSokJyA6ICdeWzAtOV0qJCc7CiAgICB9LAoKICAgIG51bWJlclJ1bGVzKGl0ZW0pIHsKICAgICAgcmV0dXJuIFsKICAgICAgICB2ID0+IHYgPT09ICcnIHx8IHYgPT09IG51bGwgfHwgIWlzTmFOKHRoaXMuX3RvTnVtYmVyKHYpKSB8fCAn6K+36L6T5YWl5pWw5a2XJywKICAgICAgICB2ID0+IGl0ZW0ubWluID09PSB1bmRlZmluZWQgfHwgdGhpcy5fdG9OdW1iZXIodikgPj0gaXRlbS5taW4gfHwgYOacgOWwj+WAvCAke2l0ZW0ubWlufWAsCiAgICAgICAgdiA9PiBpdGVtLm1heCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3RvTnVtYmVyKHYpIDw9IGl0ZW0ubWF4IHx8IGDmnIDlpKflgLwgJHtpdGVtLm1heH1gLAogICAgICBdOwogICAgfSwKCiAgICAvLyDnu5/kuIDmiorpgJflj7flsI/mlbDovazkuLrngrnvvIzljrvmjonlpJrkvZnnqbrnmb0KICAgIF90b051bWJlcih2KSB7CiAgICAgIGlmICh2ID09PSAnJyB8fCB2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkgcmV0dXJuIE5hTjsKICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykgcmV0dXJuIHY7CiAgICAgIGNvbnN0IHMgPSBTdHJpbmcodikudHJpbSgpLnJlcGxhY2UoJywnLCAnLicpOwogICAgICByZXR1cm4gTnVtYmVyKHMpOwogICAgfSwKCiAgICBvbk51bWJlckNvbW1pdChpdGVtKSB7CiAgICAgIGxldCB2ID0gdGhpcy5fdG9OdW1iZXIoaXRlbS52YWx1ZSk7CiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHYpKSByZXR1cm47CgogICAgICAvLyAxKSDlpLnlj5bliLAgbWluL21heAogICAgICBpZiAoaXRlbS5taW4gIT09IHVuZGVmaW5lZCAmJiB2IDwgaXRlbS5taW4pIHYgPSBpdGVtLm1pbjsKICAgICAgaWYgKGl0ZW0ubWF4ICE9PSB1bmRlZmluZWQgJiYgdiA+IGl0ZW0ubWF4KSB2ID0gaXRlbS5tYXg7CgogICAgICAvLyAyKSDmjIkgc3RlcCDlr7npvZDvvIjku6UgbWluIOaIliAwIOS4uuWfuuWHhu+8iQogICAgICBjb25zdCBzdGVwID0gaXRlbS5zdGVwID8/IDE7CiAgICAgIGlmIChzdGVwID4gMCkgewogICAgICAgIGNvbnN0IGJhc2UgPSAoaXRlbS5taW4gIT09IHVuZGVmaW5lZCA/IGl0ZW0ubWluIDogMCk7CiAgICAgICAgdiA9IGJhc2UgKyBNYXRoLnJvdW5kKCh2IC0gYmFzZSkgLyBzdGVwKSAqIHN0ZXA7CiAgICAgICAgaWYgKGl0ZW0ubWluICE9PSB1bmRlZmluZWQgJiYgdiA8IGl0ZW0ubWluKSB2ID0gaXRlbS5taW47CiAgICAgICAgaWYgKGl0ZW0ubWF4ICE9PSB1bmRlZmluZWQgJiYgdiA+IGl0ZW0ubWF4KSB2ID0gaXRlbS5tYXg7CiAgICAgICAgdiA9IE51bWJlcih2LnRvRml4ZWQoMTIpKTsgLy8g5Y675rWu54K56K+v5beuCiAgICAgIH0KCiAgICAgIC8vIOWbnuWGmeW5tumAmuefpQogICAgICBpdGVtLnZhbHVlID0gdjsKICAgICAgdGhpcy5oYW5kbGVDb25maWdDaGFuZ2UoaXRlbS5sYWJlbCwgdik7CiAgICB9LAogICAgY2hlY2tNZW1vcnlVc2FnZSgpIHsKICAgICAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2UubWVtb3J5KSB7CiAgICAgICAgY29uc3QgbWVtb3J5SW5mbyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5tZW1vcnk7CiAgICAgICAgY29uc3QgdXNlZCA9IE1hdGgucm91bmQobWVtb3J5SW5mby51c2VkSlNIZWFwU2l6ZSAvIDEwNDg1NzYpOwogICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5yb3VuZChtZW1vcnlJbmZvLmpzSGVhcFNpemVMaW1pdCAvIDEwNDg1NzYpOwoKICAgICAgICAvLyBjb25zb2xlLmxvZyhg5YaF5a2Y5L2/55SoOiAke3VzZWR9TUIgLyAke2xpbWl0fU1CYCk7CgogICAgICAgIGlmIChtZW1vcnlJbmZvLnVzZWRKU0hlYXBTaXplID4gbWVtb3J5SW5mby5qc0hlYXBTaXplTGltaXQgKiAwLjcpIHsKICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2hvd1dhcm5pbmcnLCB0aGlzLiRpMThuLmxvY2FsZSA9PT0gJ2NuJyA/CiAgICAgICAgICAgICflhoXlrZjkvb/nlKjmjqXov5HpmZDliLbvvIzor7fkv53lrZjlt6XkvZzlkI7liLfmlrDpobXpnaInIDoKICAgICAgICAgICAgJ01lbW9yeSB1c2FnZSBpcyBhcHByb2FjaGluZyBsaW1pdC4gUGxlYXNlIHNhdmUgeW91ciB3b3JrIGFuZCByZWZyZXNoIHRoZSBwYWdlLicpOwoKICAgICAgICAgIC8vIOWPr+mAie+8muWwneivleaJi+WKqOinpuWPkeWeg+WcvuWbnuaUtgogICAgICAgICAgaWYgKHdpbmRvdy5nYykgewogICAgICAgICAgICB0cnkgeyB3aW5kb3cuZ2MoKTsgfSBjYXRjaCAoZSkgeyB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9LAoKICAgIGZvcm1hdFRpcFZhbHVlKGl0ZW0pIHsKICAgICAgcmV0dXJuIChpdGVtICYmIGl0ZW0uZGlzcGxheVZhbHVlICE9IG51bGwpCiAgICAgICAgPyBTdHJpbmcoaXRlbS5kaXNwbGF5VmFsdWUpCiAgICAgICAgOiAoaXRlbSAmJiBpdGVtLnZhbHVlICE9IG51bGwgPyBTdHJpbmcoaXRlbS52YWx1ZSkgOiAnLScpOwogICAgfSwKICAgIGZvcm1hdFRpcFRpdGxlKGl0ZW0pIHsKICAgICAgaWYgKGl0ZW0gJiYgaXRlbS50b29sdGlwICE9IG51bGwpIHJldHVybiBTdHJpbmcoaXRlbS50b29sdGlwKTsKICAgICAgaWYgKGl0ZW0gJiYgaXRlbS52YWx1ZSAhPSBudWxsKSByZXR1cm4gU3RyaW5nKGl0ZW0udmFsdWUpOwogICAgICByZXR1cm4gJyc7CiAgICB9LAogICAgY29weVRpcChpdGVtKSB7CiAgICAgIGNvbnN0IHRleHQgPSAoaXRlbSAmJiBpdGVtLnZhbHVlICE9IG51bGwpID8gU3RyaW5nKGl0ZW0udmFsdWUpIDogJyc7CiAgICAgIGlmICghdGV4dCkgcmV0dXJuOwogICAgICBpZiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5jbGlwYm9hcmQgJiYgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQpIHsKICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTsKICAgICAgfQogICAgfSwKCiAgICBwcmV2ZW50RGVmYXVsdChldmVudCkgewogICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOwogICAgfSwKICAgIGdldExvY2F0aW9uSG9zdE5hbWUoKSB7CiAgICAgIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lOwogICAgICBjb25zdCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnd3NzOicgOiAnd3M6JzsKICAgICAgY29uc3QgcG9ydCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnODYwMScgOiAnODYwMCc7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ2xvY2F0aW9uIGhvc3RuYW1lOicgKyBob3N0bmFtZSwgJ2luZm8nKTsKICAgICAgdGhpcy5XZWJTb2NrZXRVcmwgPSBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9OiR7cG9ydH1gOwogICAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0VXJsOicsIHRoaXMuV2ViU29ja2V0VXJsKTsKICAgIH0sCiAgICBnZXRRVENsaWVudFZlcnNpb24oKSB7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ2dldFFUQ2xpZW50VmVyc2lvbicpOwogICAgfSwKICAgIGNvbm5lY3QoKSB7CiAgICAgIC8vIOabv+aNouS4uuS9oOeahCBXZWJTb2NrZXQg5pyN5Yqh5Zmo5Zyw5Z2ACiAgICAgIC8vIHRoaXMud2Vic29ja2V0ID0gbmV3IFdlYlNvY2tldCgnd3M6Ly8xOTIuMTY4LjIuMzE6ODYwMCcpOyAgLy8gcHJvY2Vzcy5lbnYuVlVFX0FQUF9XRUJTT0NLRVQKICAgICAgLy8gdGhpcy53ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHByb2Nlc3MuZW52LlZVRV9BUFBfV0VCU09DS0VUKTsKICAgICAgY29uc3Qgd3NPcHRpb25zID0gewogICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgIC8vIOemgeeUqOivgeS5pumqjOivgQogICAgICB9OwogICAgICB0aGlzLndlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5XZWJTb2NrZXRVcmwsIFtdLCB3c09wdGlvbnMpOwoKICAgICAgdGhpcy53ZWJzb2NrZXQub25vcGVuID0gKCkgPT4gewogICAgICAgIHRoaXMud2Vic29ja2V0U3RhdGUgPSAnY29ubmVjdGVkJzsKICAgICAgICB0aGlzLm5ldHdvcmtEaXNjb25uZWN0ZWQgPSBmYWxzZTsgLy8gV2ViU29ja2V06L+e5o6l5oiQ5Yqf5pe26YeN572u572R57uc6L+e5o6l54q25oCBCiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdFRpbWVvdXRUcmlnZ2VyZWQpIHsKICAgICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KCdXZWJTb2NrZXQgY29ubmVjdGVkJywgJ3N1Y2Nlc3MnKTsKICAgICAgICB9CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTaG93TmV0U3RhdHVzJywgJ3RydWUnKTsKICAgICAgICB0aGlzLlN0YXR1c1JlY292ZXJ5KCk7CiAgICAgICAgY29uc29sZS5sb2coJ3Byb2Nlc3MuZW52Lk5PREVfRU5WOicsIHByb2Nlc3MuZW52Lk5PREVfRU5WKTsKICAgICAgfTsKCiAgICAgIHRoaXMud2Vic29ja2V0Lm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7CiAgICAgICAgLy8gY29uc29sZS5sb2coJ1FIWUNDRCB8IFJlY2VpdmVkIG1lc3NhZ2U6JywgbWVzc2FnZS5kYXRhKTsKCiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTsKCiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ1FUX1JldHVybicpIHsKICAgICAgICAgIGNvbnN0IHBhcnRzID0gZGF0YS5tZXNzYWdlLnNwbGl0KCc6Jyk7CiAgICAgICAgICBsZXQgbWVzc2FnZVR5cGU7CiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMCkgewogICAgICAgICAgICBtZXNzYWdlVHlwZSA9IHBhcnRzWzBdOwogICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUUhZQ0NEIHwg6I635b6X5L+h5oGvKCcrbWVzc2FnZVR5cGUrJyk6JywgcGFydHMpOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+a2iOaBr+agvOW8j+mUmeivr++8jOaXoOazleWIhuWJsjonLCBkYXRhLm1lc3NhZ2UpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBsZXQgYWNjZXB0TWVzc2FnZSA9IGZhbHNlOwogICAgICAgICAgaWYgKGRhdGEubWVzc2FnZS5zdGFydHNXaXRoKCdTdGFnaW5nU2NoZWR1bGVEYXRhOicpKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTsKICAgICAgICAgICAgYWNjZXB0TWVzc2FnZSA9IHRydWU7CiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZGF0YS5tZXNzYWdlLnNwbGl0KCdbJyk7CgogICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwYXJ0cy5sZW5ndGg6ICcsIHBhcnRzLmxlbmd0aCk7CiAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTdGFnaW5nU2NoZWR1bGVEYXRhJywgZGF0YS5tZXNzYWdlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGRhdGEubWVzc2FnZS5zdGFydHNXaXRoKCdTZW5kRGVidWdNZXNzYWdlfCcpKSB7CiAgICAgICAgICAgIGFjY2VwdE1lc3NhZ2UgPSB0cnVlOwogICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGRhdGEubWVzc2FnZS5zcGxpdCgnfCcpOwogICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJ0c1syXTsKICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ1NlbmREZWJ1Z01lc3NhZ2UnLCB0eXBlLCBtZXNzYWdlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGlmICghYWNjZXB0TWVzc2FnZSkgewogICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7CiAgICAgICAgICAgICAgY2FzZSAnQWRkRHJpdmVyJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuQ3VycmVudERyaXZlclR5cGU7CiAgICAgICAgICAgICAgICAgIC8vIOWIm+W7uuS4gOS4qumpseWKqOWvueixoQogICAgICAgICAgICAgICAgICBjb25zdCBkcml2ZXIgPSB7IHR5cGUsIGxhYmVsLCB2YWx1ZSB9OwoKICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGUgPT09ICdNYWluQ2FtZXJhJyAmJiBsYWJlbCA9PT0gIlFIWSBDQ0QyIikgewogICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAvLyB9CiAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlID09PSAnR3VpZGVyJyAmJiBsYWJlbCA9PT0gIlFIWSBDQ0QiKSB7CiAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIC8vIH0KCiAgICAgICAgICAgICAgICAgIC8vIOajgOafpWxhYmVs5piv5ZCm5Li6IlFIWSBDQ0Qi5oiWIlFGb2N1c2VyIu+8jOWmguaenOaYr++8jOWImeaPkuWFpeWIsOaVsOe7hOmmluS9jQogICAgICAgICAgICAgICAgICBpZiAobGFiZWwgPT09ICJRSFkgQ0NEIiB8fCBsYWJlbCA9PT0gIlFGb2N1c2VyIiB8fCBsYWJlbCA9PT0gIlFIWSBDQ0QyIikgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZHJpdmVycy51bnNoaWZ0KGRyaXZlcik7IC8vIOWwhuaWsOmpseWKqOa3u+WKoOWIsOaVsOe7hOeahOW8gOWni+S9jee9rgogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZHJpdmVycy5wdXNoKGRyaXZlcik7IC8vIOWwhuaWsOmpseWKqOa3u+WKoOWIsOaVsOe7hOeahOacq+WwvgogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnQWRkRGV2aWNlJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1FIWUNDRCB8IEFkZERldmljZTogJywgbGFiZWwpOwogICAgICAgICAgICAgICAgICAvLyBjb25zdCB2YWx1ZSA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5jb25maXJtRHJpdmVyVHlwZTsKICAgICAgICAgICAgICAgICAgLy8g5Yib5bu65LiA5Liq6amx5Yqo5a+56LGhCiAgICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHsgdHlwZSwgbGFiZWwsIGxhYmVsIH07CiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdRSFlDQ0QgfCBBZGREZXZpY2U6ICcsIGRldmljZSk7CiAgICAgICAgICAgICAgICAgIC8vIHRoaXMuJGJ1cy4kZW1pdCgnYWRkLWRldmljZScsIGRldmljZSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuZGV2aWNlc0xpc3QucHVzaChkZXZpY2UpOwoKICAgICAgICAgICAgICAgICAgdGhpcy5Ub0JlQ29ubmVjdERldmljZSA9IFtdOwogICAgICAgICAgICAgICAgICB0aGlzLmRldmljZXNMaXN0LmZvckVhY2goZGV2aWNlc0xpc3QgPT4gewogICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2VzTGlzdC50eXBlID09PSB0aGlzLkN1cnJlbnREcml2ZXJUeXBlKSB7CiAgICAgICAgICAgICAgICAgICAgICB0aGlzLlRvQmVDb25uZWN0RGV2aWNlLnB1c2goZGV2aWNlc0xpc3QpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTZWxlY3REcml2ZXIgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICd1cGRhdGVEZXZpY2VzXyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IExpc3ROdW0gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURldmljZXNfKExpc3ROdW0sIG5hbWUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0Nvbm5lY3RTdWNjZXNzJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VOYW1lID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgIGNvbnN0IGRyaXZlck5hbWUgPSBwYXJ0c1szXTsKCiAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2VOYW1lICE9ICcnKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEZXZpY2VzQ29ubmVjdCh0eXBlLCBkZXZpY2VOYW1lLCBkcml2ZXJOYW1lLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURldmljZXNDb25uZWN0KHR5cGUsIGRldmljZU5hbWUsIGRyaXZlck5hbWUsIGZhbHNlKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0Nvbm5lY3RGYWlsZWQnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCByZWFzb24gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3gocmVhc29uLCAnZXJyb3InKTsKICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nQ29ubmVjdEFsbERldmljZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1NjYW5GYWlsZWQnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCByZWFzb24gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3gocmVhc29uLCAnZXJyb3InKTsKICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nU2VsZWN0RHJpdmVyID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnQWRkRGV2aWNlVHlwZSc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IERldmljZVR5cGUgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBZGREZXZpY2VUeXBlJywgRGV2aWNlVHlwZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnRGV2aWNlVG9CZUFsbG9jYXRlZCc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IERldmljZVR5cGUgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgRGV2aWNlSW5kZXggPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgY29uc3QgRGV2aWNlTmFtZSA9IHBhcnRzWzNdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0RldmljZVRvQmVBbGxvY2F0ZWQnLCBEZXZpY2VJbmRleCwgRGV2aWNlTmFtZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnU2hvd0RldmljZUFsbG9jYXRpb25XaW5kb3cnOgogICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCd0b2dnbGVEZXZpY2VBbGxvY2F0aW9uUGFuZWwnKTsKICAgICAgICAgICAgICAgIHRoaXMubmF2ID0gZmFsc2U7CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnRXhwb3N1cmVDb21wbGV0ZWQnOgogICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdFeHBvc3VyZUNvbXBsZXRlZCcpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1NhdmVKcGdTdWNjZXNzJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3Qgcm9pX3ggPSBwYXJzZUludChwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IHJvaV95ID0gcGFyc2VJbnQocGFydHNbM10pOwogICAgICAgICAgICAgICAgICB0aGlzLlJPSV94ID0gcm9pX3g7CiAgICAgICAgICAgICAgICAgIHRoaXMuUk9JX3kgPSByb2lfeTsKCiAgICAgICAgICAgICAgICAgIC8vIHRoaXMuJGJ1cy4kZW1pdCgnc2hvd1JvaUltYWdlJywgZmlsZU5hbWUpOwogICAgICAgICAgICAgICAgICB0aGlzLnNob3dSb2lJbWFnZShmaWxlTmFtZSwgcm9pX3gsIHJvaV95KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdTYXZlQmluU3VjY2Vzcyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEJpbkZpbGUoJ2ltZy8nICsgZmlsZU5hbWUpOwogICAgICAgICAgICAgICAgICB0aGlzLkRldGVjdGVkU3RhcnNGaW5pc2ggPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnU2F2ZUd1aWRlckltYWdlU3VjY2Vzcyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMubG9hZEFuZERpc3BsYXlJbWFnZSgnaW1nLycgKyBmaWxlTmFtZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlICdHdWlkZVNpemUnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgiR3VpZGVTaXplIiwgY29sLCByb3cpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjYXNlICdBZGRTY2F0dGVyQ2hhcnREYXRhJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgRGF0YV94ID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIGNvbnN0IERhdGFfeSA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRhUG9pbnQgPSBbRGF0YV94LCBEYXRhX3ldOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0FkZFNjYXR0ZXJDaGFydERhdGEnLCBuZXdEYXRhUG9pbnQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0FkZExpbmVDaGFydERhdGEnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkgewogICAgICAgICAgICAgICAgICBjb25zdCBEYXRhX3ggPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgRGF0YV9SYSA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICBjb25zdCBEYXRhX0RlYyA9IHBhcnRzWzNdOwogICAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRhUG9pbnRfUmEgPSBbRGF0YV94LCBEYXRhX1JhXTsKICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YVBvaW50X0RlYyA9IFtEYXRhX3gsIERhdGFfRGVjXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBZGRMaW5lQ2hhcnREYXRhJywgbmV3RGF0YVBvaW50X1JhLCBuZXdEYXRhUG9pbnRfRGVjKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdTZXRMaW5lQ2hhcnRSYW5nZSc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbiA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBjb25zdCBtYXggPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTZXRMaW5lQ2hhcnRSYW5nZScsIG1pbiwgbWF4KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdHdWlkZXJTdGF0dXMnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdHdWlkZXJTdGF0dXMnLCBzdGF0dXMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0ZvY3VzQ2hhbmdlU3BlZWRTdWNjZXNzJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgU3BlZWQgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdGb2N1c0NoYW5nZVNwZWVkU3VjY2VzcycsIFNwZWVkKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnRm9jdXNQb3NpdGlvbic6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IEN1cnJlbnRQb3NpdGlvbiA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBjb25zdCBUYXJnZXRQb3NpdGlvbiA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0ZvY3VzUG9zaXRpb24nLCBDdXJyZW50UG9zaXRpb24sIFRhcmdldFBvc2l0aW9uKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdGb2N1c01vdmVEb25lJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgQ3VycmVudFBvc2l0aW9uID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIGNvbnN0IEZXSE0gPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdVcGRhdGVGV0hNJywgQ3VycmVudFBvc2l0aW9uLCBGV0hNKTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdhZGREYXRhX1BvaW50JywgQ3VycmVudFBvc2l0aW9uLCBGV0hNKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdhZGRNaW5Qb2ludERhdGFfUG9pbnQnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgICAgICAgICBjb25zdCB4ID0gcGFyc2VJbnQocGFydHNbMV0pOwogICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnYWRkTWluUG9pbnREYXRhX1BvaW50JywgeCwgeSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlICdhZGRMaW5lRGF0YV9Qb2ludCc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHBhcnNlRmxvYXQocGFydHNbMl0pOwogICAgICAgICAgICAgICAgICBjb25zdCBjID0gcGFyc2VGbG9hdChwYXJ0c1szXSk7CiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZGRMaW5lRGF0YV9Qb2ludDonLCBhLCBiLCBjKTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdhZGRMaW5lRGF0YV9Qb2ludCcsIGEsIGIsIGMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAnTWFpbkNhbWVyYVNpemUnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgICAgICAgICBjb25zdCBTaXplWCA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBjb25zdCBTaXplWSA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ01haW5DYW1lcmFTaXplJywgU2l6ZVgsIFNpemVZKTsKICAgICAgICAgICAgICAgICAgdGhpcy5tYWluQ2FtZXJhU2l6ZVggPSBTaXplWDsKICAgICAgICAgICAgICAgICAgdGhpcy5tYWluQ2FtZXJhU2l6ZVkgPSBTaXplWTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdNYWluQ2FtZXJhQmlubmluZyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhQmluID0gcGFyc2VJbnQocGFydHNbMV0pOwogICAgICAgICAgICAgICAgICB0aGlzLk1haW5DYW1lcmFDb25maWdJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5sYWJlbCA9PT0gJ0Jpbm5pbmcnKS52YWx1ZSA9IHRoaXMuY2FtZXJhQmluOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ01haW5DYW1lcmFCaW5uaW5nJywgdGhpcy5jYW1lcmFCaW4pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ2ZpdFF1YWRyYXRpY0N1cnZlJzoKICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQ2xlYXJmaXRRdWFkcmF0aWNDdXJ2ZScpOwogICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gNjAxOyB4ICs9IDEpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IHBhcnRzW3hdOwogICAgICAgICAgICAgICAgICBjb25zdCBiID0gYS5zcGxpdCgnfCcpOwogICAgICAgICAgICAgICAgICBpZiAoYi5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gYlswXTsKICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gYlsxXTsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ2ZpdFF1YWRyYXRpY0N1cnZlJywgeCwgeSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdmaXRRdWFkcmF0aWNDdXJ2ZV9taW5Qb2ludCc6CiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ2ZpdFF1YWRyYXRpY0N1cnZlX21pblBvaW50JywgeCwgeSk7CiAgICAgICAgICAgICAgICBicmVhazsKCgogICAgICAgICAgICAgIGNhc2UgJ1RlbGVzY29wZVBhcmsnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBTd2l0Y2ggPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudFBhcmtTd2l0Y2gnLCBTd2l0Y2gpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1RlbGVzY29wZVRyYWNrJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgU3dpdGNoID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnTW91bnRUcmFja1N3aXRjaCcsIFN3aXRjaCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnTW91bnRTZXRTcGVlZFN1Y2Nlc3MnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBudW0gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCduZXdNb3VudFNsZXdSYXRlJywgbnVtKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnVGVsZXNjb3BlUGllclNpZGUnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBTaWRlID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgndXBkYXRlTW91bnRQaWVyU2lkZScsIFNpZGUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1RlbGVzY29wZVRvdGFsU2xld1JhdGUnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBudW0gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudFRvdGFsU2xld1JhdGUnLCBudW0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgoKICAgICAgICAgICAgICBjYXNlICdVcGRhdGVTY2hlZHVsZVByb2Nlc3MnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgICAgICAgICBjb25zdCBSb3dOdW0gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgUHJvY2VzcyA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ1VwZGF0ZVNjaGVkdWxlUHJvY2VzcycsIFJvd051bSwgUHJvY2Vzcyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnRXhwVGltZUxpc3QnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ2luaXRFeHBUaW1lTGlzdCcsIHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnQ2FtZXJhSW5FeHBvc3VyaW5nJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQ2FtZXJhSW5FeHBvc3VyaW5nJywgc3RhdHVzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdBdXRvRm9jdXNPdmVyJzoKICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXV0b0ZvY3VzT3ZlcicpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0NGV1Bvc2l0aW9uTWF4JzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTZXRDRldQb3NpdGlvbk1heCcsIHBhcnRzWzFdKTsKCiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHBhcnRzWzFdOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLkNGV0NvbmZpZ0l0ZW1zLnB1c2goeyBkcml2ZXJUeXBlOiAnQ0ZXJywgbGFiZWw6IGBDRlcgWyR7aX1dYCwgdmFsdWU6ICcnLCBpbnB1dFR5cGU6ICd0ZXh0JyB9KTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdnZXRDRldMaXN0Jyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCgogICAgICAgICAgICAgIGNhc2UgJ1NldENGV1Bvc2l0aW9uU3VjY2Vzcyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2V0Q0ZXUG9zaXRpb25TdWNjZXNzJywgcGFydHNbMV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ2dldENGV0xpc3QnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ2luaXRDRldMaXN0JywgcGFydHNbMV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0d1aWRlclN3aXRjaFN0YXR1cyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnR3VpZGVyU3dpdGNoU3RhdHVzJywgcGFydHNbMV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0d1aWRlckxvb3BFeHBTdGF0dXMnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0d1aWRlckxvb3BFeHBTdGF0dXMnLCBwYXJ0c1sxXSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnVGVsZXNjb3BlUkFERUMnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgICAgICAgICB0aGlzLlVwZGF0ZUNpcmNsZVBvcyhwYXJ0c1sxXSwgcGFydHNbMl0pOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3VwZGF0ZUN1cnJlbnRMb2NhdGlvbicsIHBhcnRzWzFdLCBwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCgogICAgICAgICAgICAgIGNhc2UgJ1RlbGVzY29wZVN0YXR1cyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuVXBkYXRlVGVsZXNjb3BlU3RhdHVzKHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdNYWluQ2FtZXJhU3RhdHVzJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVNYWluQ2FtZXJhU3RhdHVzKHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnTWFpbkNhbWVyYVRlbXBlcmF0dXJlJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVNYWluQ2FtZXJhVGVtcGVyYXR1cmUocGFydHNbMV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgoKICAgICAgICAgICAgICBjYXNlICdTaG93QWxsSW1hZ2VGb2xkZXInOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ1Nob3dBbGxJbWFnZUZvbGRlcicsIHBhcnRzWzFdLCBwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCgogICAgICAgICAgICAgIGNhc2UgJ0ltYWdlRmlsZXNOYW1lJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdJbWFnZUZpbGVzTmFtZScsIHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnVVNCQ2hlY2snOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBVU0JkYXRhID0gcGFydHNbMV0uc3BsaXQoJywnKTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VTQiBuYW1lOiAnLCBVU0JkYXRhWzBdKTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VTQiBzcGFjZTogJywgVVNCZGF0YVsxXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1VTQiBuYW1lOicgKyBVU0JkYXRhWzBdLCAnaW5mbycpOwogICAgICAgICAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdVU0Igc3BhY2U6JyArIFVTQmRhdGFbMV0sICdpbmZvJyk7CgogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ1VTQl9OYW1lX1NhcGNlJywgVVNCZGF0YVswXSwgVVNCZGF0YVsxXSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnSW1hZ2VTYXZlRXJyb2UnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBFcnJvZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBpZiAoRXJyb2UgPT09ICdVU0ItTnVsbCcpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCgnTm8gVVNCIERyaXZlIERldGVjdGVkLicsICdlcnJvcicpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVycm9lID09PSAnVVNCLU11bHRpcGxlJykgewogICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KCdNdWx0aXBsZSBVU0IgZHJpdmVzIGRldGVjdGVkLCBwbGVhc2UgcmVtb3ZlIGV4Y2VzcyBVU0IgZHJpdmVzLicsICdlcnJvcicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnRGV0ZWN0ZWRTdGFycyc6CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGV0ZWN0ZWQnLCBwYXJ0cy5sZW5ndGgsICdzdGFycy4nKTsKICAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0RldGVjdGVkICcgKyBwYXJ0cy5sZW5ndGggKyAnIHN0YXJzLicsICdpbmZvJyk7CiAgICAgICAgICAgICAgICB0aGlzLkRldGVjdGVkU3RhcnNMaXN0ID0gW107CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBwYXJ0c1tpXTsKICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IGEuc3BsaXQoJ3wnKTsKICAgICAgICAgICAgICAgICAgaWYgKGIubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGJbMF07CiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGJbMV07CiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGZyID0gYlsyXTsKICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3RhcnMgYXQoJywgeCwgJywnLCB5LCAnKSB3aXRoIEhGUjonLCBoZnIpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuRGV0ZWN0ZWRTdGFyc0xpc3QucHVzaCh7IHg6IHgsIHk6IHksIGhmcjogaGZyIH0pOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLkRldGVjdGVkU3RhcnNGaW5pc2ggPSB0cnVlOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1NvbHZlSW1hZ2VSZXN1bHQnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNSkgewogICAgICAgICAgICAgICAgICAvLyB0aGlzLlVwZGF0ZUNpcmNsZVBvcyhwYXJ0c1sxXSwgcGFydHNbMl0pOwogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU29sdmUgSW1hZ2UgUmVzdWx0KFJBX0RlZ3JlZSwgREVDX0RlZ3JlZSwgQXppbXV0aCwgQWx0aXR1ZGUpOicsIHBhcnRzWzFdLCAnLCcsIHBhcnRzWzJdLCAnLCcsIHBhcnRzWzNdLCAnLCcsIHBhcnRzWzRdKTsKICAgICAgICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnU29sdmUgSW1hZ2UgUmVzdWx0KFJBX0RlZ3JlZSwgREVDX0RlZ3JlZSwgQXppbXV0aCwgQWx0aXR1ZGUpOicgKyBwYXJ0c1sxXSArICcsJyArIHBhcnRzWzJdICsgJywnICsgcGFydHNbM10gKyAnLCcgKyBwYXJ0c1s0XSwgJ2luZm8nKTsKICAgICAgICAgICAgICAgICAgdGhpcy5Tb2x2ZVJlc3VsdE1hcmsocGFydHNbMV0sIHBhcnRzWzJdLCBwYXJ0c1szXSwgcGFydHNbNF0pOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoIkltYWdlU29sdmVGaW5pc2hlZCIsIHRydWUpOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3NldFBhcnNpbmdQcm9ncmVzcycsIGZhbHNlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdTb2x2ZUZvdlJlc3VsdCc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSA5KSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IFJhRGVjID0gWwogICAgICAgICAgICAgICAgICAgIHsgUmE6IHBhcnRzWzFdLCBEZWM6IHBhcnRzWzJdIH0sCiAgICAgICAgICAgICAgICAgICAgeyBSYTogcGFydHNbM10sIERlYzogcGFydHNbNF0gfSwKICAgICAgICAgICAgICAgICAgICB7IFJhOiBwYXJ0c1s1XSwgRGVjOiBwYXJ0c1s2XSB9LAogICAgICAgICAgICAgICAgICAgIHsgUmE6IHBhcnRzWzddLCBEZWM6IHBhcnRzWzhdIH0sCiAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgICAgIHRoaXMuU29sdmVGb3ZNYXJrKFJhRGVjKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdSZWFsVGltZVNvbHZlSW1hZ2VSZXN1bHQnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNSkgewogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU29sdmUgSW1hZ2UgUmVzdWx0KFJBX0RlZ3JlZSwgREVDX0RlZ3JlZSwgQXppbXV0aCwgQWx0aXR1ZGUpOicsIHBhcnRzWzFdLCAnLCcsIHBhcnRzWzJdLCAnLCcsIHBhcnRzWzNdLCAnLCcsIHBhcnRzWzRdKTsKICAgICAgICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnU29sdmUgSW1hZ2UgUmVzdWx0KFJBX0RlZ3JlZSwgREVDX0RlZ3JlZSwgQXppbXV0aCwgQWx0aXR1ZGUpOicgKyBwYXJ0c1sxXSArICcsJyArIHBhcnRzWzJdICsgJywnICsgcGFydHNbM10gKyAnLCcgKyBwYXJ0c1s0XSwgJ2luZm8nKTsKICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5Tb2x2ZVJlc3VsdE1hcmtfUmVhbFRpbWUocGFydHNbMV0sIHBhcnRzWzJdLCBwYXJ0c1szXSwgcGFydHNbNF0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnU29sdmVJbWFnZVN1Y2NlZWRlZCc6CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn6Kej5p6Q5ZCM5q2l5oiQ5YqfJyk7CiAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoImhhbmRsZU9wZXJhdGlvbkNvbXBsZXRlIiwgInNvbHZlIik7CiAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3Nob3dNc2dCb3gnLCAnU29sdmUgaW1hZ2Ugc3VjY2VlZCEnLCAnc3VjY2VzcycpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1NvbHZlSW1hZ2VmYWlsZWQnOgogICAgICAgICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3goJ1NvbHZlIGltYWdlIGZhaWxkLi4uJywgJ2Vycm9yJyk7CiAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoIkltYWdlU29sdmVGaW5pc2hlZCIsIGZhbHNlKTsKICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2V0UGFyc2luZ1Byb2dyZXNzJywgZmFsc2UpOwogICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudE9wZXJhdGlvbkNvbXBsZXRlJywgJ3NvbHZlJyk7CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnTWFpbkNhbWVyYU9mZnNldFJhbmdlJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01haW5DYW1lcmFPZmZzZXRSYW5nZTonLCBwYXJ0c1sxXSwgJywnLCBwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ01haW5DYW1lcmFPZmZzZXRSYW5nZTonICsgcGFydHNbMV0gKyAnLCcgKyBwYXJ0c1syXSwgJ2luZm8nKTsKICAgICAgICAgICAgICAgICAgdGhpcy5NYWluQ2FtZXJhT2Zmc2V0TWluID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMuTWFpbkNhbWVyYU9mZnNldE1heCA9IHBhcnRzWzJdOwoKICAgICAgICAgICAgICAgICAgY29uc3QgT2Zmc2V0SXRlbSA9IHRoaXMuTWFpbkNhbWVyYUNvbmZpZ0l0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLmxhYmVsID09PSAnT2Zmc2V0Jyk7CiAgICAgICAgICAgICAgICAgIGlmIChPZmZzZXRJdGVtKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01haW5DYW1lcmFPZmZzZXRSYW5nZTonLCBwYXJzZUludCh0aGlzLk1haW5DYW1lcmFPZmZzZXRNaW4sIDEwKSwgJywnLCBwYXJzZUludCh0aGlzLk1haW5DYW1lcmFPZmZzZXRNYXgsIDEwKSk7CiAgICAgICAgICAgICAgICAgICAgT2Zmc2V0SXRlbS5pbnB1dE1pbiA9IHBhcnNlSW50KHRoaXMuTWFpbkNhbWVyYU9mZnNldE1pbiwgMTApOwogICAgICAgICAgICAgICAgICAgIE9mZnNldEl0ZW0uaW5wdXRNYXggPSBwYXJzZUludCh0aGlzLk1haW5DYW1lcmFPZmZzZXRNYXgsIDEwKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ01haW5DYW1lcmFHYWluUmFuZ2UnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykgewogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWFpbkNhbWVyYUdhaW5SYW5nZTonLCBwYXJ0c1sxXSwgJywnLCBwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ01haW5DYW1lcmFHYWluUmFuZ2U6JyArIHBhcnRzWzFdICsgJywnICsgcGFydHNbMl0sICdpbmZvJyk7CiAgICAgICAgICAgICAgICAgIHRoaXMuTWFpbkNhbWVyYUdhaW5NaW4gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5NYWluQ2FtZXJhR2Fpbk1heCA9IHBhcnRzWzJdOwoKICAgICAgICAgICAgICAgICAgY29uc3QgZ2Fpbkl0ZW0gPSB0aGlzLk1haW5DYW1lcmFDb25maWdJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5sYWJlbCA9PT0gJ0dhaW4nKTsKICAgICAgICAgICAgICAgICAgaWYgKGdhaW5JdGVtKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01haW5DYW1lcmFHYWluUmFuZ2U6JywgcGFyc2VJbnQodGhpcy5NYWluQ2FtZXJhR2Fpbk1pbiwgMTApLCAnLCcsIHBhcnNlSW50KHRoaXMuTWFpbkNhbWVyYUdhaW5NYXgsIDEwKSk7CiAgICAgICAgICAgICAgICAgICAgZ2Fpbkl0ZW0uaW5wdXRNaW4gPSBwYXJzZUludCh0aGlzLk1haW5DYW1lcmFHYWluTWluLCAxMCk7CiAgICAgICAgICAgICAgICAgICAgZ2Fpbkl0ZW0uaW5wdXRNYXggPSBwYXJzZUludCh0aGlzLk1haW5DYW1lcmFHYWluTWF4LCAxMCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdPdXRwdXRQb3dlclN0YXR1cyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChwYXJ0c1syXSwgMTApOwoKICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5PdXRQdXRQb3dlcl8xX09OID0gdmFsdWUgPT09IDE7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLk91dFB1dFBvd2VyXzJfT04gPSB2YWx1ZSA9PT0gMTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1BIRDJTdGFyQm94Vmlldyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdQSEQyU3RhckJveFZpZXcnLCB2aWV3KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdQSEQyU3RhckNyb3NzVmlldyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdQSEQyU3RhckNyb3NzVmlldycsIHZpZXcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1BIRDJTdGFyQm94UG9zaXRpb24nOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNSkgewogICAgICAgICAgICAgICAgICBjb25zdCBQSEQySW1hZ2VTaXplX1ggPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOwogICAgICAgICAgICAgICAgICBjb25zdCBQSEQySW1hZ2VTaXplX1kgPSBwYXJzZUludChwYXJ0c1syXSwgMTApOwogICAgICAgICAgICAgICAgICBjb25zdCBCb3hfWCA9IHBhcnNlSW50KHBhcnRzWzNdLCAxMCk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IEJveF9ZID0gcGFyc2VJbnQocGFydHNbNF0sIDEwKTsKICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3UEhEMkJveChQSEQySW1hZ2VTaXplX1gsIFBIRDJJbWFnZVNpemVfWSwgQm94X1gsIEJveF9ZKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdQSEQyTXVsdGlTdGFyc1Bvc2l0aW9uJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDUpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgUEhEMkltYWdlU2l6ZV9YID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgICAgICAgICAgICAgY29uc3QgUEhEMkltYWdlU2l6ZV9ZID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKTsKICAgICAgICAgICAgICAgICAgY29uc3QgQm94X1ggPSBwYXJzZUludChwYXJ0c1szXSwgMTApOwogICAgICAgICAgICAgICAgICBjb25zdCBCb3hfWSA9IHBhcnNlSW50KHBhcnRzWzRdLCAxMCk7CiAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1BIRDJNdWx0aVN0YXJzKFBIRDJJbWFnZVNpemVfWCwgUEhEMkltYWdlU2l6ZV9ZLCBCb3hfWCwgQm94X1kpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0NsZWFyUEhEMk11bHRpU3RhcnMnOgogICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdDbGVhclBIRDJNdWx0aVN0YXJzJyk7CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnUEhEMlN0YXJDcm9zc1Bvc2l0aW9uJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDUpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgUEhEMkltYWdlU2l6ZV9YID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgICAgICAgICAgICAgY29uc3QgUEhEMkltYWdlU2l6ZV9ZID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKTsKICAgICAgICAgICAgICAgICAgY29uc3QgQ3Jvc3NfWCA9IHBhcnNlSW50KHBhcnRzWzNdLCAxMCk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IENyb3NzX1kgPSBwYXJzZUludChwYXJ0c1s0XSwgMTApOwogICAgICAgICAgICAgICAgICB0aGlzLkRyYXdQSEQyQ3Jvc3MoUEhEMkltYWdlU2l6ZV9YLCBQSEQySW1hZ2VTaXplX1ksIENyb3NzX1gsIENyb3NzX1kpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1FUQ2xpZW50VmVyc2lvbic6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuUVRDbGllbnRWZXJzaW9uID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCgogICAgICAgICAgICAgIGNhc2UgJ0NhcHR1cmVJbWFnZVNhdmVTdGF0dXMnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1JlcGVhdCcpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCh0aGlzLiR0KCdUaGVyZSBpcyBubyBuZWVkIHRvIHNhdmUgaXQgYWdhaW4nKSwgJ2Vycm9yJyk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnU3VjY2VzcycpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCh0aGlzLiR0KCdJbWFnZSBzYXZlZCBzdWNjZXNzZnVsbHknKSwgJ3N1Y2Nlc3MnKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdOdWxsJykgewogICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KHRoaXMuJHQoJ05vIGltYWdlcyB0byBzYXZlJyksICdlcnJvcicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnSU5ESVNlcnZlckRlYnVnJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0lORElTZXJ2ZXJEZWJ1ZycsIG1lc3NhZ2UpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0hvdHNwb3ROYW1lJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgTmFtZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0hvdHNwb3ROYW1lJywgTmFtZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlICdFZGl0SG90c3BvdE5hbWVTdWNjZXNzJzoKICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnRWRpdEhvdHNwb3ROYW1lU3VjY2VzcycpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0RTTFJzU2V0dXAnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBOYW1lID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2hvd0RTTFJzU2V0dXAnLCBOYW1lKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdDb25maWd1cmVSZWNvdmVyeSc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IENvbmZpZ05hbWUgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgQ29uZmlnVmFsdWUgPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbmZpZ3VyZTonLCBDb25maWdOYW1lLCAnLCcsIENvbmZpZ1ZhbHVlKTsKICAgICAgICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ29uZmlndXJlIFJlY292ZXJ5OicgKyBwYXJ0c1sxXSArICcsJyArIHBhcnRzWzJdLCAnaW5mbycpOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoQ29uZmlnTmFtZSwgQ29uZmlnVmFsdWUpOwoKICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnRm9jYWxMZW5ndGgnKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5UZWxlc2NvcGVzQ29uZmlnSXRlbXNbMF0udmFsdWUgPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiB0aGlzLmRldmljZXMpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UuZHJpdmVyVHlwZSA9PT0gJ1RlbGVzY29wZXMnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1syXSA9PT0gJycgfHwgcGFydHNbMl0gPT09IE5hTikgewogICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZS5kZXZpY2UgPSAnJzsKICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UuaXNDb25uZWN0ZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UuZGV2aWNlID0gcGFydHNbMl0gKyAnIG1tJzsKICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UuaXNDb25uZWN0ZWQgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0gPT09ICdHdWlkZXJGb2NhbExlbmd0aCcpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLkd1aWRlckNvbmZpZ0l0ZW1zWzBdLnZhbHVlID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdHdWlkZXJGb2NhbExlbmd0aDonICsgcGFydHNbMl0pOwogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0gPT09ICdDb29yZGluYXRlcycpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBbbGF0U3RyLCBsbmdTdHIsIGlzQXV0b1N0cl0gPSBwYXJ0c1syXS5zcGxpdCgnLCcpLm1hcChpdGVtID0+IGl0ZW0udHJpbSgpKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXQgPSBwYXJzZUZsb2F0KGxhdFN0cik7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG5nID0gcGFyc2VGbG9hdChsbmdTdHIpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0byA9IGlzQXV0b1N0ciA9PT0gJ3RydWUnIHx8IGlzQXV0b1N0ciA9PT0gJzEnOwogICAgICAgICAgICAgICAgICAgIHRoaXMuU2V0Q3VycmVudExvY2F0aW9uKGxhdCwgbG5nLCBpc0F1dG8pOwogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0gPT09ICdNdWx0aVN0YXJHdWlkZXInKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5HdWlkZXJDb25maWdJdGVtc1sxXS52YWx1ZSA9IChwYXJ0c1syXSA9PT0gJ3RydWUnKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ011bHRpU3Rhckd1aWRlcjonICsgcGFydHNbMl0pOwogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0gPT09ICdHdWlkZXJHYWluJykgewogICAgICAgICAgICAgICAgICAgIHRoaXMuR3VpZGVyQ29uZmlnSXRlbXNbMl0udmFsdWUgPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ0d1aWRlckdhaW46JyArIHBhcnRzWzJdKTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnQ2FsaWJyYXRpb25EdXJhdGlvbicpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLkd1aWRlckNvbmZpZ0l0ZW1zWzNdLnZhbHVlID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdDYWxpYnJhdGlvbkR1cmF0aW9uOicgKyBwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1sxXSA9PT0gJ1JhQWdncmVzc2lvbicpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLkd1aWRlckNvbmZpZ0l0ZW1zWzRdLnZhbHVlID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdSYUFnZ3Jlc3Npb246JyArIHBhcnRzWzJdKTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnRGVjQWdncmVzc2lvbicpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLkd1aWRlckNvbmZpZ0l0ZW1zWzVdLnZhbHVlID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdEZWNBZ2dyZXNzaW9uOicgKyBwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnQ29ubmVjdERyaXZlclN1Y2Nlc3MnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0RHJpdmVyU3VjY2VzcyhkZXZpY2UpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0Nvbm5lY3REcml2ZXJGYWlsZWQnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdERyaXZlckZhaWxlZChtZXNzYWdlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdEaXNjb25uZWN0RHJpdmVyU3VjY2Vzcyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3REcml2ZXJzdWNjZXNzKGRldmljZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnRGlzY29ubmVjdERyaXZlckZhaWwnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBkcml2ZXIgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0RHJpdmVyRmFpbChkZXZpY2UpCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNhc2UgJ1NlbGVjdGVkRHJpdmVyTGlzdCc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDMpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlT2JqZWN0cyA9IHBhcnRzLnNsaWNlKDEpLnJlZHVjZSgoYWNjLCBwYXJ0LCBpbmRleCwgYXJyYXkpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IFthcnJheVtpbmRleF1dOiBhcnJheVtpbmRleCArIDFdIH0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjOwogICAgICAgICAgICAgICAgICB9LCBbXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMubG9hZFNlbGVjdGVkRHJpdmVyTGlzdChkZXZpY2VPYmplY3RzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnQmluZERldmljZUxpc3QnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAzKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZU9iamVjdHMgPSBwYXJ0cy5zbGljZSgxKS5yZWR1Y2UoKGFjYywgcGFydCwgaW5kZXgsIGFycmF5KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goeyBbYXJyYXlbaW5kZXhdXTogYXJyYXlbaW5kZXggKyAxXSB9KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYzsKICAgICAgICAgICAgICAgICAgfSwgW10pOwogICAgICAgICAgICAgICAgICB0aGlzLmxvYWRCaW5kRGV2aWNlTGlzdChkZXZpY2VPYmplY3RzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgY2FzZSAnQmluZERldmljZVR5cGVMaXN0JzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gNSkgeyAvLyDnoa7kv53oh7PlsJHmnInkupTkuKrlj4LmlbDliqDkuIrliY3nvIAKICAgICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlVHlwZU9iamVjdHMgPSBbXTsKICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gNCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZVR5cGVPYmplY3QgPSB7CiAgICAgICAgICAgICAgICAgICAgICBUeXBlOiBwYXJ0c1tpXSwKICAgICAgICAgICAgICAgICAgICAgIERldmljZU5hbWU6IHBhcnRzW2kgKyAxXSwKICAgICAgICAgICAgICAgICAgICAgIERyaXZlck5hbWU6IHBhcnRzW2kgKyAyXSwKICAgICAgICAgICAgICAgICAgICAgIGlzYmluZDogcGFydHNbaSArIDNdID09ICJ0cnVlIiA/IHRydWUgOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgIGRldmljZVR5cGVPYmplY3RzLnB1c2goZGV2aWNlVHlwZU9iamVjdCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkQmluZERldmljZVR5cGVMaXN0KGRldmljZVR5cGVPYmplY3RzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdkZWxldGVEZXZpY2VBbGxvY2F0aW9uTGlzdCc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZU5hbWUgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVEZXZpY2VBbGxvY2F0aW9uTGlzdChkZXZpY2VOYW1lKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdkZWxldGVEZXZpY2VUeXBlQWxsb2NhdGlvbkxpc3QnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2VUeXBlICE9ICcnKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdkZWxldGVEZXZpY2VUeXBlQWxsb2NhdGlvbkxpc3QnLCBkZXZpY2VUeXBlKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlVHlwZSA9PSAnQ0ZXJykgewogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXZpY2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXZpY2VzW2ldLmRyaXZlclR5cGUgPT0gJ0NGVycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXZpY2VzW2ldLmlzQ29ubmVjdGVkID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV2aWNlc1tpXS5kZXZpY2UgPSAnJzsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXZpY2VzW2ldLmRyaXZlck5hbWUgPSAnJzsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXZpY2VzW2ldLkJhdWRSYXRlID0gOTYwMDsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdDRldDb25uZWN0ZWQnLCAwKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdQYXJzZUluZm9FbWl0dGVkJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdQYXJzZUluZm9FbWl0dGVkJywgcHJvZ3Jlc3MpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ0d1aWRlclVwZGF0ZVN0YXR1cyc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0d1aWRlclVwZGF0ZVN0YXR1cycsIHBhcnNlSW50KHN0YXR1cywgMTApKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdMb29wU29sdmVJbWFnZUZpbmlzaGVkJzoKICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnTG9vcFNvbHZlSW1hZ2VGaW5pc2hlZCcpOwogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3REZXZpY2VoYXNvcnRoZXJkZXZpY2UnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBkcml2ZXJuYW1lID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1NlbGVjdGRpc2Nvbm5lY3REcml2ZXIoZHJpdmVybmFtZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnZ2V0Rm9jdXNlck1vdmVTdGF0ZSc6CiAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ2dldEZvY3VzZXJNb3ZlU3RhdGUnKTsKICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdGb2N1c01vdmVUb0xpbWl0JzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3Jsb2cgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3goZXJyb3Jsb2csICdlcnJvcicpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0Rm9jdXNMb29wRmFpbGVkJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3N0YXJ0Rm9jdXNMb29wRmFpbGVkJywgbWVzc2FnZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnc2V0Rm9jdXNlckxvb3BpbmdTdGF0ZSc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzZXRGb2N1c2VyTG9vcGluZ1N0YXRlJywgbWVzc2FnZSk7CiAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09ICd0cnVlJykgewogICAgICAgICAgICAgICAgICAgIHRoaXMuaXNGb2N1c0xvb3BTaG9vdGluZyA9IHRydWU7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0ZvY3VzTG9vcFNob290aW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdmb2N1c2VyUk9JU3RhcnNMaXN0JzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgIGNvbnN0IEhGUiA9IHBhcnRzWzNdOwogICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZXJST0lTdGFyc0xpc3QucHVzaCh7IHgsIHksIEhGUiB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAvLyBjYXNlICdjbGVhckZvY3VzZXJST0lTdGFyc0xpc3QnOgogICAgICAgICAgICAgIC8vICAgdGhpcy5mb2N1c2VyUk9JU3RhcnNMaXN0ID0gW107CiAgICAgICAgICAgICAgLy8gICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnc2V0U2VsZWN0U3RhclBvc2l0aW9uJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2VsZWN0U3RhclggPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2VsZWN0U3RhclkgPSBwYXJzZUZsb2F0KHBhcnRzWzJdKTsKICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2VsZWN0U3RhckhGUiA9IHBhcnNlRmxvYXQocGFydHNbM10pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1NldFJlZEJveFN0YXRlJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocGFydHNbMV0pOwogICAgICAgICAgICAgICAgICB0aGlzLlJPSV94ID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuUk9JX3kgPSBwYXJzZUZsb2F0KHBhcnRzWzNdKTsKCiAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVkQm94U3RhdGUobGVuZ3RoLCB0aGlzLlJPSV94LCB0aGlzLlJPSV95KTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+iuvue9rue6ouiJslJPSeahhjogJywgbGVuZ3RoLCB0aGlzLlJPSV94LCB0aGlzLlJPSV95KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdTZXRWaXNpYmxlQXJlYSc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7CiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZVggPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlWSA9IHBhcnNlRmxvYXQocGFydHNbMl0pOwogICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gcGFyc2VGbG9hdChwYXJ0c1szXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2V0U2NhbGUnLCB0aGlzLnNjYWxlKTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+iuvue9ruWPr+ingeWMuuWfnzogJywgdGhpcy52aXNpYmxlWCwgdGhpcy52aXNpYmxlWSwgdGhpcy5zY2FsZSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ3VwZGF0ZSBWaXNpYmxlQXJlYSB4PScgKyB0aGlzLnZpc2libGVYICsgJywgeT0nICsgdGhpcy52aXNpYmxlWSArICcsIHNjYWxlPScgKyB0aGlzLnNjYWxlLCAnaW5mbycpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1NldFNlbGVjdFN0YXJzJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RTdGFyWCA9IHBhcnNlRmxvYXQocGFydHNbMV0pOwogICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFN0YXJZID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ3VwZGF0ZSBTZWxlY3RTdGFycyB4PScgKyB0aGlzLnNlbGVjdFN0YXJYICsgJywgeT0nICsgdGhpcy5zZWxlY3RTdGFyWSwgJ2luZm8nKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICd1cGRhdGVDUFVJbmZvJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHsKICAgICAgICAgICAgICAgICAgbGV0IGNwdVRlbXAgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgICAgbGV0IGNwdVVzYWdlID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuY3B1VGVtcCA9IGlzTmFOKGNwdVRlbXApID8gbnVsbCA6IChjcHVUZW1wICUgMSA9PT0gMCA/IGNwdVRlbXAgOiBjcHVUZW1wLnRvRml4ZWQoMSkpOyAgLy8g5aaC5p6cIGNwdVRlbXAg5pivIE5hTu+8jOiuvue9ruS4uiBudWxs77yM5ZCm5YiZ5aaC5p6cIGNwdVRlbXAg5piv5pW05pWw77yM5bCx5LiN5L+d55WZ5bCP5pWw77yM5ZCm5YiZ5L+d55WZ5LiA5L2N5bCP5pWwCiAgICAgICAgICAgICAgICAgIHRoaXMuY3B1VXNhZ2UgPSBpc05hTihjcHVVc2FnZSkgPyBudWxsIDogKGNwdVVzYWdlICUgMSA9PT0gMCA/IGNwdVVzYWdlIDogY3B1VXNhZ2UudG9GaXhlZCgxKSk7ICAvLyDlpoLmnpwgY3B1VXNhZ2Ug5pivIE5hTu+8jOiuvue9ruS4uiBudWxs77yM5ZCm5YiZ5aaC5p6cIGNwdVVzYWdlIOaYr+aVtOaVsO+8jOWwseS4jeS/neeVmeWwj+aVsO+8jOWQpuWImeS/neeVmeS4gOS9jeWwj+aVsAogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3VwZGF0ZUNQVUluZm8nLCB0aGlzLmNwdVRlbXAsIHRoaXMuY3B1VXNhZ2UpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ1RpYW5XZW4nOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkgewogICAgICAgICAgICAgICAgICBjb25zdCBub3RpY2VfdHlwZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBjb25zdCByYSA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICBjb25zdCBkZWMgPSBwYXJ0c1szXTsKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdUaWFuV2VuJywgbm90aWNlX3R5cGUsIHJhLCBkZWMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ3NldE1haW5DYW1lcmFQYXJhbWV0ZXJzJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMykgewogICAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVycyA9IHt9OwogICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gcGFydHNbaV07CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0c1tpICsgMV07CiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc1twYXJhbWV0ZXJdID0gdmFsdWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhpcy5zZXRNYWluQ2FtZXJhUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdsb2NhbE1lc3NhZ2UnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkgewogICAgICAgICAgICAgICAgICBjb25zdCBsYXQgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgbG9uID0gcGFydHNbMl07CiAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gcGFydHNbM107CiAgICAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJzItLS0tLS0tLS0tLS3ojrflvpflj4LmlbDorr7nva5sb2NhbE1lc3NhZ2U6ICcgKyBsYXQgKyAnLCcgKyBsb24gKyAnLCcgKyBsYW5ndWFnZSwgJ2luZm8nKTsKICAgICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlID09ICd6aCcpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0NsaWVudExhbmd1YWdlJywgJ2NuJyk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdDbGllbnRMYW5ndWFnZScsICdlbicpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2V0TG9jYXRpb25MYXRBbmRMb24nLCBsYXQsIGxvbik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnaXNBdXRvTG9jYXRpb24nOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBpc0F1dG9Mb2NhdGlvbiA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ2lzQXV0b0xvY2F0aW9uJywgaXNBdXRvTG9jYXRpb24pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ3NlbmRHZXRMb2NhdGlvbic6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdCA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBjb25zdCBsb24gPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnc2VuZEdldExvY2F0aW9uOiAnICsgbGF0ICsgJywnICsgbG9uLCAnaW5mbycpOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3NlbmRHZXRMb2NhdGlvbicsIGxhdCwgbG9uKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdNYWluQ2FtZXJhQ0ZBJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdudWxsJzsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ0dSQkcnKSB7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnR1InOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnR0JSRycpIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdHQic7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdCR0dSJykgewogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ0JHJzsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ1JHJykgewogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ1JHR0InOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRoaXMuSW1hZ2VDRkEgPSB2YWx1ZTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIuiOt+WPluWIsOeahOS4u+ebuOacuuWPguaVsCAgTWFpbkNhbWVyYUNGQTogIiwgdGhpcy5JbWFnZUNGQSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuTWFpbkNhbWVyYUNvbmZpZ0l0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLmxhYmVsID09PSAnSW1hZ2VDRkEnKS52YWx1ZSA9IHRoaXMuSW1hZ2VDRkE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnQ2FtZXJhTm90SWRsZSc6CiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCgnQ2FtZXJhIGlzIG5vdCBpZGxlJywgJ2Vycm9yJyk7CiAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ01vdW50T3BlcmF0aW9uQ29tcGxldGUnLCAnc29sdmUnKTsKICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICBjYXNlICdNYWluQ2FtZXJhTm90Q29ubmVjdCc6CiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCgnTWFpbiBDYW1lcmEgaXMgbm90IGNvbm5lY3QnLCAnZXJyb3InKTsKICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnTW91bnRPcGVyYXRpb25Db21wbGV0ZScsICdzb2x2ZScpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAnU2VydmVySW5pdFN1Y2Nlc3MnOgogICAgICAgICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3goJ1NlcnZlciBpbml0IHN1Y2Nlc3MnLCAnc3VjY2VzcycpOwogICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAnUG9sYXJBbGlnbm1lbnRTdGF0ZSc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHBhcnRzWzNdOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ1BvbGFyQWxpZ25tZW50U3RhdGUnLCBzdGF0ZSwgbWVzc2FnZSwgcGVyY2VudGFnZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlICdQb2xhckFsaWdubWVudEFkanVzdG1lbnRHdWlkZURhdGEnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMjEpIHsgIC8vIOS7jjE35pS55Li6MjEKICAgICAgICAgICAgICAgICAgY29uc3QgcmEgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgICAgY29uc3QgZGVjID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7CiAgICAgICAgICAgICAgICAgIC8vIOaWsOWinu+8muWbm+S4quinkueCuQogICAgICAgICAgICAgICAgICBjb25zdCByYTAgPSBwYXJzZUZsb2F0KHBhcnRzWzNdKTsKICAgICAgICAgICAgICAgICAgY29uc3QgZGVjMCA9IHBhcnNlRmxvYXQocGFydHNbNF0pOwogICAgICAgICAgICAgICAgICBjb25zdCByYTEgPSBwYXJzZUZsb2F0KHBhcnRzWzVdKTsKICAgICAgICAgICAgICAgICAgY29uc3QgZGVjMSA9IHBhcnNlRmxvYXQocGFydHNbNl0pOwogICAgICAgICAgICAgICAgICBjb25zdCByYTIgPSBwYXJzZUZsb2F0KHBhcnRzWzddKTsKICAgICAgICAgICAgICAgICAgY29uc3QgZGVjMiA9IHBhcnNlRmxvYXQocGFydHNbOF0pOwogICAgICAgICAgICAgICAgICBjb25zdCByYTMgPSBwYXJzZUZsb2F0KHBhcnRzWzldKTsKICAgICAgICAgICAgICAgICAgY29uc3QgZGVjMyA9IHBhcnNlRmxvYXQocGFydHNbMTBdKTsKCiAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldHJhID0gcGFyc2VGbG9hdChwYXJ0c1sxMV0pOwogICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRkZWMgPSBwYXJzZUZsb2F0KHBhcnRzWzEyXSk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldHJhID0gcGFyc2VGbG9hdChwYXJ0c1sxM10pOwogICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRkZWMgPSBwYXJzZUZsb2F0KHBhcnRzWzE0XSk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnRyYSA9IHBhcnRzWzE1XTsKICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudGRlYyA9IHBhcnRzWzE2XTsKICAgICAgICAgICAgICAgICAgY29uc3QgZmFrZVBvbGFyUkEgPSBwYXJzZUZsb2F0KHBhcnRzWzE3XSk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGZha2VQb2xhckRFQyA9IHBhcnNlRmxvYXQocGFydHNbMThdKTsKICAgICAgICAgICAgICAgICAgY29uc3QgcmVhbFBvbGFyUkEgPSBwYXJzZUZsb2F0KHBhcnRzWzE5XSk7CiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWxQb2xhckRFQyA9IHBhcnNlRmxvYXQocGFydHNbMjBdKTsKCgogICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygn6Ieq5Yqo5a+554Sm57uY5Yi25pWw5o2uOiAnLCByYSwgZGVjLCB0YXJnZXRyYSwgdGFyZ2V0ZGVjLCBmYWtlUG9sYXJSQSwgZmFrZVBvbGFyREVDLCByZWFsUG9sYXJSQSwgcmVhbFBvbGFyREVDKTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+Wbm+inkueCueaVsOaNrjogJywgcmEwLCBkZWMwLCByYTEsIGRlYzEsIHJhMiwgZGVjMiwgcmEzLCBkZWMzKTsKCiAgICAgICAgICAgICAgICAgIC8vIOeOsOacieS6i+S7tuS/neaMgeS4jeWPmO+8iOS9v+eUqOiuoeeul+eahG1heC9taW7lgLzlhbzlrrnvvIkKICAgICAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdGaWVsZERhdGFVcGRhdGUnLCBbcmEsIGRlYywgcmEwLCBkZWMwLCByYTEsIGRlYzEsIHJhMiwgZGVjMiwgcmEzLCBkZWMzLCB0YXJnZXRyYSwgdGFyZ2V0ZGVjLCBmYWtlUG9sYXJSQSwgZmFrZVBvbGFyREVDLCByZWFsUG9sYXJSQSwgcmVhbFBvbGFyREVDXSk7CgogICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygn6Ieq5Yqo5a+554Sm5pi+56S65pu05paw5pWw5o2uOiAnLCBvZmZzZXRyYSwgb2Zmc2V0ZGVjLCBhZGp1c3RtZW50cmEsIGFkanVzdG1lbnRkZWMpOwogICAgICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3VwZGF0ZUNhcmRJbmZvJywgcmEsIGRlYywgdGFyZ2V0cmEsIHRhcmdldGRlYywgb2Zmc2V0cmEsIG9mZnNldGRlYywgYWRqdXN0bWVudHJhLCBhZGp1c3RtZW50ZGVjLCAiZGVnIik7CgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzTW92ZUZhaWxlZCc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3gobWVzc2FnZSwgJ2Vycm9yJyk7CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnZm9jdXNNb3ZlRmFpbGVkJywgbWVzc2FnZSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzTW92ZUZhaWxlZCc6CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3gobWVzc2FnZSwgJ2Vycm9yJyk7CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnZm9jdXNNb3ZlRmFpbGVkJywgbWVzc2FnZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgY2FzZSAnTWVyaWRpYW5FVEFfaG1zJzogewogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSA0KSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGggPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IHBhcnRzWzJdOwogICAgICAgICAgICAgICAgICBjb25zdCBzID0gcGFydHNbM107CgogICAgICAgICAgICAgICAgICBjb25zdCBobXMgPSBgJHtofToke219OiR7c31gOwogICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5Nb3VudENvbmZpZ0l0ZW1zLmZpbmQoaSA9PiBpLmxhYmVsID09PSAnRmxpcCBFVEEnKTsKICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHsKICAgICAgICAgICAgICAgICAgICBpdGVtLnZhbHVlID0gaG1zOwogICAgICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheVZhbHVlID0gaG1zOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNhc2UgJ0F1dG9GbGlwJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBpc0F1dG9GbGlwID0gcGFydHNbMV07CiAgICAgICAgICAgICAgICAgIC8vIOafpeaJvuaYr+WQpuW3suWtmOWcqCAiQXV0b0ZsaXAiIOmhuQogICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuTW91bnRDb25maWdJdGVtcy5maW5kKGkgPT4gaS5sYWJlbCA9PT0gJ0F1dG9GbGlwJyk7CiAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7CiAgICAgICAgICAgICAgICAgICAgLy8g5bey5a2Y5ZyoIOKGkiDmm7TmlrAKICAgICAgICAgICAgICAgICAgICBpdGVtLnZhbHVlID0gaXNBdXRvRmxpcCA9PSAndHJ1ZSc7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgLy8g5LiN5a2Y5ZyoIOKGkiDmlrDlop4KICAgICAgICAgICAgICAgICAgICB0aGlzLk1vdW50Q29uZmlnSXRlbXMucHVzaCh7IGRyaXZlclR5cGU6ICdNb3VudCcsIGxhYmVsOiAnQXV0b0ZsaXAnLCB2YWx1ZTogaXNBdXRvRmxpcCA9PSAndHJ1ZScsIGlucHV0VHlwZTogJ3N3aXRjaCcgfSwpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgLy8gY2FzZSAnTWludXRlc1Bhc3RNZXJpZGlhbic6CiAgICAgICAgICAgICAgLy8gICBpZiAocGFydHMubGVuZ3RoID49IDMpIHsKICAgICAgICAgICAgICAvLyAgICAgY29uc3QgRWFzdE1pbnV0ZXNQYXN0TWVyaWRpYW4gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAvLyAgICAgY29uc3QgV2VzdE1pbnV0ZXNQYXN0TWVyaWRpYW4gPSBwYXJ0c1syXTsKICAgICAgICAgICAgICAvLyAgICAgbGV0IGl0ZW0gPSB0aGlzLk1vdW50Q29uZmlnSXRlbXMuZmluZChpID0+IGkubGFiZWwgPT09ICdFYXN0TWludXRlc1Bhc3RNZXJpZGlhbicpOwogICAgICAgICAgICAgIC8vICAgICBpZiAoaXRlbSkgewogICAgICAgICAgICAgIC8vICAgICAgIGl0ZW0udmFsdWUgPSBFYXN0TWludXRlc1Bhc3RNZXJpZGlhbjsKICAgICAgICAgICAgICAvLyAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAvLyAgICAgICB0aGlzLk1vdW50Q29uZmlnSXRlbXMucHVzaCh7IGRyaXZlclR5cGU6ICdNb3VudCcsIGxhYmVsOiAnRWFzdE1pbnV0ZXNQYXN0TWVyaWRpYW4nLCB2YWx1ZTogRWFzdE1pbnV0ZXNQYXN0TWVyaWRpYW4sbWluOi0xODAsbWF4OjE4MCwgaW5wdXRUeXBlOiAnbnVtYmVyJyB9LCk7CiAgICAgICAgICAgICAgLy8gICAgIH0KICAgICAgICAgICAgICAvLyAgICAgaXRlbSA9IHRoaXMuTW91bnRDb25maWdJdGVtcy5maW5kKGkgPT4gaS5sYWJlbCA9PT0gJ1dlc3RNaW51dGVzUGFzdE1lcmlkaWFuJyk7CiAgICAgICAgICAgICAgLy8gICAgIGlmIChpdGVtKSB7CiAgICAgICAgICAgICAgLy8gICAgICAgaXRlbS52YWx1ZSA9IFdlc3RNaW51dGVzUGFzdE1lcmlkaWFuOwogICAgICAgICAgICAgIC8vICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vICAgICAgIHRoaXMuTW91bnRDb25maWdJdGVtcy5wdXNoKHsgZHJpdmVyVHlwZTogJ01vdW50JywgbGFiZWw6ICdXZXN0TWludXRlc1Bhc3RNZXJpZGlhbicsIHZhbHVlOiBXZXN0TWludXRlc1Bhc3RNZXJpZGlhbixtaW46LTE4MCxtYXg6MTgwLCBpbnB1dFR5cGU6ICdudW1iZXInIH0sKTsKICAgICAgICAgICAgICAvLyAgICAgfQogICAgICAgICAgICAgIC8vICAgfQogICAgICAgICAgICAgIC8vICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAnRWFzdE1pbnV0ZXNQYXN0TWVyaWRpYW4nOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgICAgICAgICBjb25zdCBFYXN0TWludXRlc1Bhc3RNZXJpZGlhbiA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuTW91bnRDb25maWdJdGVtcy5maW5kKGkgPT4gaS5sYWJlbCA9PT0gJ0Vhc3RNaW51dGVzUGFzdE1lcmlkaWFuJyk7CiAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7CiAgICAgICAgICAgICAgICAgICAgaXRlbS52YWx1ZSA9IEVhc3RNaW51dGVzUGFzdE1lcmlkaWFuOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMuTW91bnRDb25maWdJdGVtcy5wdXNoKHsgZHJpdmVyVHlwZTogJ01vdW50JywgbGFiZWw6ICdFYXN0TWludXRlc1Bhc3RNZXJpZGlhbicsIHZhbHVlOiBFYXN0TWludXRlc1Bhc3RNZXJpZGlhbiwgbWluOiAtMTgwLCBtYXg6IDE4MCwgaW5wdXRUeXBlOiAnbnVtYmVyJyB9LCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgJ1dlc3RNaW51dGVzUGFzdE1lcmlkaWFuJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgV2VzdE1pbnV0ZXNQYXN0TWVyaWRpYW4gPSBwYXJ0c1sxXTsKICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLk1vdW50Q29uZmlnSXRlbXMuZmluZChpID0+IGkubGFiZWwgPT09ICdXZXN0TWludXRlc1Bhc3RNZXJpZGlhbicpOwogICAgICAgICAgICAgICAgICBpZiAoaXRlbSkgewogICAgICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUgPSBXZXN0TWludXRlc1Bhc3RNZXJpZGlhbjsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLk1vdW50Q29uZmlnSXRlbXMucHVzaCh7IGRyaXZlclR5cGU6ICdNb3VudCcsIGxhYmVsOiAnV2VzdE1pbnV0ZXNQYXN0TWVyaWRpYW4nLCB2YWx1ZTogV2VzdE1pbnV0ZXNQYXN0TWVyaWRpYW4sIG1pbjogLTE4MCwgbWF4OiAxODAsIGlucHV0VHlwZTogJ251bWJlcicgfSwpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlICdHb3RvVGhlblNvbHZlJzoKICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgR290b1RoZW5Tb2x2ZSA9IHBhcnRzWzFdOwogICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuTW91bnRDb25maWdJdGVtcy5maW5kKGkgPT4gaS5sYWJlbCA9PT0gJ0dvdG9UaGVuU29sdmUnKTsKICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHsKICAgICAgICAgICAgICAgICAgICBpdGVtLnZhbHVlID0gR290b1RoZW5Tb2x2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGNhc2UgJ2FkZEZ3aG1Ob3cnOgogICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGZ3aG0gPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIGFkZEZ3aG1Ob3c6JywgZndobSk7CiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnYWRkRndobU5vdycsIGZ3aG0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ+acquWkhOeQhuWRveS7pDogJywgZGF0YS5tZXNzYWdlKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ1FUX0NvbmZpcm0nKSB7CiAgICAgICAgICAvLyDlpITnkIbnoa7orqTmtojmga8KICAgICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IGRhdGEubXNnaWQ7CiAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2VSZXNwb25zZShtZXNzYWdlSWQpOwogICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnUHJvY2Vzc19Db21tYW5kJykgewogICAgICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NfQ29tbWFuZDogJywgZGF0YS5tZXNzYWdlKTsKICAgICAgICAgIC8vIOWkhOeQhui/lOWbnua2iOaBrwogICAgICAgICAgY29uc3QgcGFydHMgPSBkYXRhLm1lc3NhZ2Uuc3BsaXQoJzonKTsKICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJ3F0U2VydmVySXNPdmVyJykgewogICAgICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCgnUVQgU2VydmVyIGlzIG92ZXInLCAnZXJyb3InKTsKICAgICAgICAgICAgdGhpcy5TaG93Q29uZmlybURpYWxvZygncmVzdGFydCcsICdRVCBzZXJ2ZXIgZW5jb3VudGVyZWQgYSBzZWdtZW50YXRpb24gZmF1bHQgb3IgaXMgZnJvemVuLCBwbGVhc2UgcmVzdGFydCBvciBleGl0IScsICdyZXN0YXJ0UXRTZXJ2ZXInKTsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09PSAnY2hlY2tIYXNOZXdVcGRhdGVQYWNrJykgewogICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHBhcnRzWzFdOwogICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+iOt+WPluWIsOabtOaWsOWMheeJiOacrDogJyArIHZlcnNpb24sICdpbmZvJyk7CgogICAgICAgICAgICAgIHRoaXMuU2hvd0NvbmZpcm1EaWFsb2coJ0ZvcmNlVXBkYXRlJywgdGhpcy4kdCgnY2hlY2tIYXNOZXdVcGRhdGVQYWNrJykgKyAnOiAnICsgdmVyc2lvbiArICfvvIwnICsgdGhpcy4kdCgndXBkYXRlQ29uZmlybScpLCAndXBkYXRlQ3VycmVudENsaWVudDonICsgdmVyc2lvbik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09PSAnTm9fdXBkYXRlX3BhY2tfZm91bmQnKSB7CiAgICAgICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KHRoaXMuJHQoJ05vX3VwZGF0ZV9wYWNrX2ZvdW5kJyksICdlcnJvcicpOwogICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJ3VwZGF0ZV9wcm9ncmVzcycpIHsKICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCd1cGRhdGVfcHJvZ3Jlc3MnLCBkYXRhLm1lc3NhZ2UpOwogICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJ3VwZGF0ZV9lcnJvcicpIHsKICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCd1cGRhdGVfZXJyb3InLCBkYXRhLm1lc3NhZ2UpOwogICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJ3VwZGF0ZV9zdWNjZXNzJykgewogICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3VwZGF0ZV9zdWNjZXNzJywgZGF0YS5tZXNzYWdlKTsKICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICd0ZXN0UXRTZXJ2ZXJQcm9jZXNzJykgewoKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBjb25zb2xlLndhcm4oJ+acquWkhOeQhuWRveS7pDogJywgZGF0YS5tZXNzYWdlKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHRoaXMucmVjZWl2ZWRNZXNzYWdlcy5wdXNoKGRhdGEubWVzc2FnZSk7IC8vIOWwhuaOpeaUtuWIsOeahOa2iOaBr+a3u+WKoOWIsOaVsOe7hOS4rQogICAgICB9OwoKICAgICAgdGhpcy53ZWJzb2NrZXQub25lcnJvciA9IChlcnJvcikgPT4gewogICAgICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IHsKICAgICAgICAgIHR5cGU6IGVycm9yLnR5cGUsCiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwKICAgICAgICAgIHVybDogdGhpcy5XZWJTb2NrZXRVcmwsCiAgICAgICAgICByZWFkeVN0YXRlOiB0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlLAogICAgICAgICAgcHJvdG9jb2w6IHRoaXMud2Vic29ja2V0LnByb3RvY29sLAogICAgICAgICAgZXh0ZW5zaW9uczogdGhpcy53ZWJzb2NrZXQuZXh0ZW5zaW9ucwogICAgICAgIH07CiAgICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IEVycm9yIERldGFpbHM6JywgZXJyb3JEZXRhaWxzKTsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdXZWJTb2NrZXQgRXJyb3I6ICcgKyBKU09OLnN0cmluZ2lmeShlcnJvckRldGFpbHMpLCAnZXJyb3InKTsKICAgICAgICB0aGlzLndlYnNvY2tldFN0YXRlID0gJ2Vycm9yJzsKICAgICAgICB0aGlzLm5ldHdvcmtEaXNjb25uZWN0ZWQgPSB0cnVlOwogICAgICB9OwoKICAgICAgdGhpcy53ZWJzb2NrZXQub25jbG9zZSA9ICgpID0+IHsKICAgICAgICBjb25zb2xlLmxvZygnUUhZQ0NEIHwgV2ViU29ja2V0IGRpc2Nvbm5lY3RlZCcpOwogICAgICAgIHRoaXMud2Vic29ja2V0U3RhdGUgPSAnZGlzY29ubmVjdGVkJzsKICAgICAgICB0aGlzLm5ldHdvcmtEaXNjb25uZWN0ZWQgPSB0cnVlOyAvLyBXZWJTb2NrZXTov57mjqXlhbPpl63ml7borr7nva7nvZHnu5zov57mjqXnirbmgIEKICAgICAgICBjb25zb2xlLmxvZygnUUhZQ0NEIHwgV2ViU29ja2V0IGRpc2Nvbm5lY3RlZCcpOwogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2hvd05ldFN0YXR1cycsICdmYWxzZScpOwoKICAgICAgICAvLyDorr7nva7kuIDkuKrlrprml7blmajvvIwx56eS5ZCO5qOA5p+l572R57uc54q25oCBCiAgICAgICAgdGhpcy5kaXNjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgaWYgKHRoaXMubmV0d29ya0Rpc2Nvbm5lY3RlZCkgeyAvLyDlpoLmnpwx56eS5ZCO5LuN54S25pat5byACiAgICAgICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkJywgJ2Vycm9yJyk7CiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFRpbWVvdXRUcmlnZ2VyZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0sIDEwMDApOyAvLyAx56eS5ZCO5omn6KGMCgogICAgICAgIC8vIOWQr+WKqOiHquWKqOmHjei/ngogICAgICAgIHRoaXMucmVjb25uZWN0V2ViU29ja2V0KCk7CiAgICAgIH07CiAgICB9LAoKICAgIC8vIOiHquWKqOmHjei/ngogICAgcmVjb25uZWN0V2ViU29ja2V0KCkgewogICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICBjb25zb2xlLmxvZygnUUhZQ0NEIHwgV2ViU29ja2V0IHJlY29ubmVjdGVkJyk7CiAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnV2ViU29ja2V0IHJlY29ubmVjdGVkLicsICdpbmZvJyk7CiAgICAgICAgdGhpcy5jb25uZWN0KCk7CiAgICAgIH0sIDIwMDApOyAvLyAy56eS5ZCO5bCd6K+V6YeN5paw6L+e5o6lCiAgICB9LAogICAgLy8g6Ieq5Yqo6YeN6L+eCgogICAgLy/nm5HlkKznvZHnu5zov57mjqXnirbmgIEKICAgIHNldHVwTmV0d29ya1N0YXR1c0xpc3RlbmVyKCkgewogICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgKCkgPT4gewogICAgICAgIC8vIOajgOafpeaWreW8gOi/nuaOpeeahOWumuaXtuWZqOaYr+WQpuW3sue7j+inpuWPkQogICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0VHJpZ2dlcmVkKSB7CiAgICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCgnV2ViU29ja2V0IGNvbm5lY3RlZCcsICdzdWNjZXNzJyk7CiAgICAgICAgfQogICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0KTsgLy8g5riF6Zmk5pat5byA6L+e5o6l55qE5a6a5pe25ZmoCiAgICAgICAgdGhpcy5uZXR3b3JrRGlzY29ubmVjdGVkID0gZmFsc2U7IC8vIOe9kee7nOaBouWkjeaXtumHjee9rue9kee7nOi/nuaOpeeKtuaAgQogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2hvd05ldFN0YXR1cycsICd0cnVlJyk7CiAgICAgICAgdGhpcy5TdGF0dXNSZWNvdmVyeSgpOwogICAgICAgIHRoaXMucmVjb25uZWN0V2ViU29ja2V0KCk7IC8vIOe9kee7nOaBouWkjeWQjuiHquWKqOmHjei/nldlYlNvY2tldAogICAgICB9KTsKCiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgKCkgPT4gewogICAgICAgIHRoaXMubmV0d29ya0Rpc2Nvbm5lY3RlZCA9IHRydWU7IC8vIOe9kee7nOaWreW8gOaXtuiuvue9rue9kee7nOi/nuaOpeeKtuaAgQogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2hvd05ldFN0YXR1cycsICdmYWxzZScpOwogICAgICAgIHRoaXMuZGlzY29ubmVjdFRpbWVvdXRUcmlnZ2VyZWQgPSBmYWxzZTsgLy8g5Yid5aeL5YyW5pat5byA6L+e5o6l5a6a5pe25Zmo6Kem5Y+R5qCH5b+XCiAgICAgICAgLy8g6K6+572u5LiA5Liq5a6a5pe25Zmo77yMMeenkuWQjuajgOafpee9kee7nOeKtuaAgQogICAgICAgIHRoaXMuZGlzY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmtEaXNjb25uZWN0ZWQpIHsgLy8g5aaC5p6cMeenkuWQjuS7jeeEtuaWreW8gAogICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0VHJpZ2dlcmVkID0gdHJ1ZTsgLy8g5qCH6K6w5a6a5pe25Zmo5bey6Kem5Y+RCiAgICAgICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkJywgJ2Vycm9yJyk7CiAgICAgICAgICB9CiAgICAgICAgfSwgMTAwMCk7IC8vIDHnp5LlkI7miafooYwKICAgICAgfSk7CiAgICB9LAogICAgLy/nm5HlkKznvZHnu5zov57mjqXnirbmgIEKCiAgICBzZW5kTWVzc2FnZSh0eXBlLCBtZXNzYWdlKSB7CiAgICAgIGNvbnNvbGUubG9nKCJRSFlDQ0QgfCBzZW5kTWVzc2FnZTogIiwgbWVzc2FnZSk7CgogICAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLmdlbmVyYXRlTWVzc2FnZUlkKCk7IC8vIOeUn+aIkOWUr+S4gOeahOa2iOaBr0lECiAgICAgIGNvbnN0IG1lc3NhZ2VPYmogPSB7IHR5cGU6IHR5cGUsIG1zZ2lkOiBtZXNzYWdlSWQsIG1lc3NhZ2U6IG1lc3NhZ2UgfTsgLy8g5Yib5bu65YyF5ZCr57G75Z6L5ZKM5raI5oGv55qE5a+56LGhCiAgICAgIGNvbnN0IG1lc3NhZ2VKc29uID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZU9iaik7IC8vIOWwhua2iOaBr+Wvueixoei9rOaNouS4uiBKU09OIOWtl+espuS4sgogICAgICBjb25zdCBtZXNzYWdlU3RhdGUgPSB7IG1zZ2lkOiBtZXNzYWdlSWQsIHRleHQ6IG1lc3NhZ2VKc29uLCBzdWNjZXNzOiBmYWxzZSB9OyAvLyDliJvlu7rljIXlkKvmtojmga/lkoznirbmgIHkv6Hmga/nmoTlr7nosaEKCiAgICAgIGlmICh0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgewogICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQobWVzc2FnZUpzb24pOwogICAgICAgIC8vIG1lc3NhZ2VTdGF0ZS5zdWNjZXNzID0gdHJ1ZTsgLy8g6K6+572u5raI5oGv5Li65oiQ5YqfCiAgICAgIH0KICAgICAgdGhpcy5zZW50TWVzc2FnZXMucHVzaChtZXNzYWdlU3RhdGUpOyAvLyDmt7vliqDmtojmga/lr7nosaHliLDlt7Llj5HpgIHnmoTmtojmga/mlbDnu4QKICAgIH0sCgogICAgZ2VuZXJhdGVNZXNzYWdlSWQoKSB7CiAgICAgIC8vIOS9v+eUqOaXtumXtOaIs+WSjOiuoeaVsOWZqOeUn+aIkOWUr+S4gOeahOa2iOaBr0lECiAgICAgIHJldHVybiBEYXRlLm5vdygpICsgIi0iICsgKHRoaXMubWVzc2FnZUNvdW50ZXIrKyk7CiAgICB9LAoKICAgIGhhbmRsZU1lc3NhZ2VSZXNwb25zZShtZXNzYWdlSWQpIHsKICAgICAgLy8g5qC55o2u6L+U5Zue55qE5raI5oGvSUTmm7TmlrDmtojmga/lj5HpgIHnirbmgIEKICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLnNlbnRNZXNzYWdlc1t0aGlzLnNlbnRNZXNzYWdlcy5sZW5ndGggLSAxXTsKICAgICAgaWYgKGxhc3RNZXNzYWdlICYmIGxhc3RNZXNzYWdlLm1zZ2lkID09PSBtZXNzYWdlSWQpIHsKICAgICAgICBsYXN0TWVzc2FnZS5zdWNjZXNzID0gdHJ1ZTsKICAgICAgfQogICAgfSwKCiAgICAvLyDmtojmga/moYYKICAgIGNhbGxTaG93TWVzc2FnZUJveChtc2csIHR5cGUpIHsKICAgICAgY29uc29sZS5sb2coJ1FIWUNDRCB8IGNhbGxTaG93TWVzc2FnZUJveDonLCBtc2csIHR5cGUpOwogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKG1zZywgdHlwZSk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2hvd01zZ0JveCcsIG1zZywgdHlwZSk7CiAgICB9LAogICAgLy8g5raI5oGv5qGGCgogICAgbG9jYXRpb25DbGlja2VkOiBmdW5jdGlvbiAoKSB7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnVnVlX0NvbW1hbmQnLCAnbG9jYWxNZXNzYWdlJyk7IC8vIOiOt+WPluS9jee9ruS/oeaBrwogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3RvZ2dsZUJvb2wnLCAnc2hvd0xvY2F0aW9uRGlhbG9nJyk7CgogICAgICB0aGlzLiRidXMuJGVtaXQoJ1Jlc2V0VGltZScpOwogICAgfSwKCiAgICBTZXRDdXJyZW50TG9jYXRpb24obGF0LCBsbmcsIGlzQXV0bykgewogICAgICBjb25zb2xlLmxvZygnU2V0Q3VycmVudExvY2F0aW9uOicsIGxhdCwgJywnLCBsbmcpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ1NlbmRDb25zb2xlTG9nTXNnJywgJ1NldCBDdXJyZW50IExvY2F0aW9uOicgKyBsYXQgKyAnLCcgKyBsbmcsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnUG9sYXJQb2ludEFsdGl0dWRlJywgbGF0KTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdyZXNldExvY2F0aW9uJywgbGF0LCBsbmcsIGlzQXV0byk7CiAgICAgIGNvbnN0IGxvYyA9IHsKICAgICAgICBzaG9ydF9uYW1lOiAnVW5rbm93bicsCiAgICAgICAgY291bnRyeTogJ1Vua25vd24nLAogICAgICAgIGxuZzogbG5nLAogICAgICAgIGxhdDogbGF0LAogICAgICAgIGFsdDogMCwKICAgICAgICBhY2N1cmFjeTogMCwKICAgICAgICBzdHJlZXRfYWRkcmVzczogJycKICAgICAgfQogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3NldEN1cnJlbnRMb2NhdGlvbicsIGxvYyk7CgogICAgICB0aGlzLiRidXMuJGVtaXQoJ1Nob3dQb3NpdGlvbkluZm8nLCBsYXQsIGxuZyk7CgogICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ1Jlc2V0VGltZScpOwogICAgICB9LCAxMDAwKTsKICAgIH0sCiAgICAvLyDnirbmgIHmgaLlpI0KICAgIFN0YXR1c1JlY292ZXJ5KCkgewogICAgICAvLyB0aGlzLnNlbmRNZXNzYWdlKCdTZW5kQ29uc29sZUxvZ01zZycsICfnvZHnu5zov57mjqXmgaLlpI3vvIzmgaLlpI3lvZPliY3nirbmgIEhJywgJ3dhcm5pbmcnKTsKICAgICAgdGhpcy5nZXRRVENsaWVudFZlcnNpb24oKTsgICAgICAgICAgICAgICAgLy8g6I635Y+WUVRDbGllbnTniYjmnKwKICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnZ2V0Uk9JSW5mbycpOyAvLyDojrflj5ZST0nkv6Hmga8KICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnbG9jYWxNZXNzYWdlJyk7IC8vIOiOt+WPluS9jee9ruS/oeaBrwogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdnZXRMYXN0U2VsZWN0RGV2aWNlJyk7IC8vIOiOt+WPluS4iuS4gOasoemAieaLqeeahOiuvuWkhwogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdnZXRNYWluQ2FtZXJhUGFyYW1ldGVycycpOyAvLyDojrflj5bkuLvnm7jmnLrlj4LmlbAKICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnZ2V0TW91bnRQYXJhbWV0ZXJzJyk7IC8vIOiOt+WPlui1pOmBk+S7qlVJ5L+h5oGvCiAgICAgIHRoaXMuUmVjYWxpYnJhdGVQb2xhckF4aXMoKTsgLy8g6YeN5paw5qCh5YeG5p6B6L20CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ2dldFN0YWdpbmdTb2x2ZVJlc3VsdCcpOyAvLyDojrflj5blrprmoIfnu5PmnpwKICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnZ2V0Rm9jdXNlckxvb3BpbmdTdGF0ZScpOyAvLyDojrflj5bnhKbot53lmajlvqrnjq/nirbmgIEKICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnZ2V0U3RhZ2luZ1NjaGVkdWxlRGF0YScpOyAvLyDojrflj5blrprmoIforqHliJLmlbDmja4KICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnZ2V0U3RhZ2luZ1NvbHZlUmVzdWx0Jyk7IC8vIOiOt+WPluWumuagh+e7k+aenAogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdnZXRHUElPc1N0YXR1cycpOyAvLyDojrflj5ZHUElP54q25oCBCiAgICAgIC8vIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ2dldFN0YWdpbmdJbWFnZScpOyAvLyDojrflj5bmnIDlkI7mi43mkYTnmoTlm77lg48KICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnZ2V0UG9sYXJBbGlnbm1lbnRTdGF0ZScpOyAvLyDojrflj5bmnoHovbTlr7npvZDnirbmgIEKCgogICAgICB0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0VHJpZ2dlcmVkID0gZmFsc2U7CiAgICB9LAoKICAgIG9wZW5Qb3dlck1hbmFnZXJQYWdlKCkgewogICAgICB0aGlzLmlzT3BlbkRldmljZVBhZ2UgPSBmYWxzZTsKICAgICAgdGhpcy5pc09wZW5Qb3dlclBhZ2UgPSB0cnVlOwoKICAgICAgdGhpcy5kcmF3ZXJfMiA9IHRydWU7CiAgICB9LAoKICAgIFF1aXRUb01haW5BcHAoKSB7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ0Jyb2FkY2FzdF9Nc2cnLCAnQ2xvc2VXZWJWaWV3Jyk7CiAgICB9LAoKICAgIHNlbGVjdERldmljZShkZXZpY2UpIHsKICAgICAgaWYgKCF0aGlzLmhhdmVEZXZpY2VDb25uZWN0IHx8ICh0aGlzLmhhdmVEZXZpY2VDb25uZWN0KSB8fCBkZXZpY2UuZHJpdmVyVHlwZSA9PT0gJ1RlbGVzY29wZXMnKSB7CiAgICAgICAgdGhpcy5pc09wZW5EZXZpY2VQYWdlID0gdHJ1ZTsKICAgICAgICB0aGlzLmlzT3BlblBvd2VyUGFnZSA9IGZhbHNlOwoKICAgICAgICBpZiAoZGV2aWNlLmlzZ2V0ID09PSBmYWxzZSkgewogICAgICAgICAgLy8gZGV2aWNlLmlzZ2V0ID0gdHJ1ZTsKICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ1NlbGVjdEluZGlEcml2ZXI6JyArIGRldmljZS50eXBlICsgIjoiICsgZGV2aWNlLkxpc3ROdW0pOwogICAgICAgICAgdGhpcy5kcml2ZXJzID0gW107CiAgICAgICAgfQoKICAgICAgICB0aGlzLkN1cnJlbnREcml2ZXJUeXBlID0gZGV2aWNlLmRyaXZlclR5cGU7CiAgICAgICAgdGhpcy5EZXZpY2VJc0Nvbm5lY3RlZCA9IGRldmljZS5pc0Nvbm5lY3RlZDsKICAgICAgICB0aGlzLkJhdWRSYXRlU2VsZWN0ZWQgPSBkZXZpY2UuQmF1ZFJhdGU7CiAgICAgICAgaWYgKGRldmljZS5kcml2ZXJUeXBlID09PSAnVGVsZXNjb3BlcycpIHsKICAgICAgICAgIHRoaXMuRGV2aWNlSXNDb25uZWN0ZWQgPSB0cnVlOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5kcmF3ZXJfMiA9IHRydWU7CgogICAgICAgIHRoaXMuVG9CZUNvbm5lY3REZXZpY2UgPSBbXTsKICAgICAgICB0aGlzLmRldmljZXNMaXN0LmZvckVhY2goZGV2aWNlc0xpc3QgPT4gewogICAgICAgICAgaWYgKGRldmljZXNMaXN0LnR5cGUgPT09IHRoaXMuQ3VycmVudERyaXZlclR5cGUpIHsKICAgICAgICAgICAgdGhpcy5Ub0JlQ29ubmVjdERldmljZS5wdXNoKGRldmljZXNMaXN0KTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCgnVGhlIGRldmljZSBpcyBub3QgY29ubmVjdGVkLicsICdlcnJvcicpOwogICAgICB9CgogICAgfSwKCiAgICBDdXJyZW50Q29uZmlnSXRlbXMoKSB7CiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50Q29uZmlnSXRlbXM6ICcsIHRoaXMuQ3VycmVudERyaXZlclR5cGUgKyAnQ29uZmlnSXRlbXMnKTsKICAgICAgc3dpdGNoICh0aGlzLkN1cnJlbnREcml2ZXJUeXBlKSB7CiAgICAgICAgY2FzZSAnR3VpZGVyJzoKICAgICAgICAgIHJldHVybiB0aGlzLkd1aWRlckNvbmZpZ0l0ZW1zOwogICAgICAgIGNhc2UgJ01haW5DYW1lcmEnOgogICAgICAgICAgcmV0dXJuIHRoaXMuTWFpbkNhbWVyYUNvbmZpZ0l0ZW1zOwogICAgICAgIGNhc2UgJ01vdW50JzoKICAgICAgICAgIHJldHVybiB0aGlzLk1vdW50Q29uZmlnSXRlbXM7CiAgICAgICAgY2FzZSAnVGVsZXNjb3Blcyc6CiAgICAgICAgICByZXR1cm4gdGhpcy5UZWxlc2NvcGVzQ29uZmlnSXRlbXM7CiAgICAgICAgY2FzZSAnRm9jdXNlcic6CiAgICAgICAgICByZXR1cm4gdGhpcy5Gb2N1c2VyQ29uZmlnSXRlbXM7CiAgICAgICAgY2FzZSAnUG9sZUNhbWVyYSc6CiAgICAgICAgICByZXR1cm4gdGhpcy5Qb2xlQ2FtZXJhQ29uZmlnSXRlbXM7CiAgICAgICAgY2FzZSAnQ0ZXJzoKICAgICAgICAgIHJldHVybiB0aGlzLkNGV0NvbmZpZ0l0ZW1zOwogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgIH0sCgogICAgY29uZmlybURyaXZlcigpIHsKICAgICAgLy8g56Gu5a6a6amx5Yqo55qE6YC76L6RCiAgICAgIGNvbnNvbGUubG9nKCJRSFlDQ0QgfCBjb25maXJtRHJpdmVyOiAiLCB0aGlzLnNlbGVjdGVkRHJpdmVyKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ29uZmlybSBJbmRpIERyaXZlcjonICsgdGhpcy5zZWxlY3RlZERyaXZlciwgJ2luZm8nKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdDb25maXJtSW5kaURyaXZlcjonICsgdGhpcy5zZWxlY3RlZERyaXZlciArICc6JyArIHRoaXMuQmF1ZFJhdGVTZWxlY3RlZCk7CiAgICAgIHRoaXMuY29uZmlybURyaXZlclR5cGUgPSB0aGlzLkN1cnJlbnREcml2ZXJUeXBlOwogICAgICB0aGlzLmxvYWRpbmdTZWxlY3REcml2ZXIgPSB0cnVlOwoKICAgICAgdGhpcy5kZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09IHRoaXMuQ3VycmVudERyaXZlclR5cGUpIHsKICAgICAgICAgIGRldmljZS5kZXZpY2UgPSB0aGlzLnNlbGVjdGVkRHJpdmVyOwogICAgICAgICAgZGV2aWNlLmRyaXZlck5hbWUgPSB0aGlzLnNlbGVjdGVkRHJpdmVyOwogICAgICAgICAgZGV2aWNlLkJhdWRSYXRlID0gdGhpcy5CYXVkUmF0ZVNlbGVjdGVkOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9LAogICAgY2xlYXJEcml2ZXIoKSB7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnQ2xlYXJJbmRpRHJpdmVyJyk7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0NsZWFyIEluZGkgRHJpdmVyJywgJ2luZm8nKTsKICAgICAgdGhpcy5kZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09IHRoaXMuQ3VycmVudERyaXZlclR5cGUpIHsKICAgICAgICAgIGRldmljZS5kZXZpY2UgPSAnJzsKICAgICAgICAgIGRldmljZS5kcml2ZXJOYW1lID0gJyc7CiAgICAgICAgICBkZXZpY2UuQmF1ZFJhdGUgPSA5NjAwOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHRoaXMuc2VsZWN0ZWREcml2ZXIgPSAnJzsKICAgIH0sCiAgICBjb25maXJtRGV2aWNlKCkgewogICAgICAvLyDnoa7lrprorr7lpIfnmoTpgLvovpEKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdDb25maXJtSW5kaURldmljZTonICsgdGhpcy5zZWxlY3RlZERldmljZSArICc6JyArIHRoaXMuc2VsZWN0ZWREcml2ZXIpOwogICAgICAvLyB0aGlzLiRidXMuJGVtaXQoJ0FwcFVwZGF0ZURldmljZXMnLCB0aGlzLkN1cnJlbnREcml2ZXJUeXBlLCB0aGlzLnNlbGVjdGVkRGV2aWNlKTsKICAgICAgdGhpcy51cGRhdGVEZXZpY2VzKHRoaXMuQ3VycmVudERyaXZlclR5cGUsIHRoaXMuc2VsZWN0ZWREZXZpY2UpOwogICAgfSwKCiAgICB1cGRhdGVEZXZpY2VzKGRyaXZlclR5cGUsIG5ld0RldmljZSkgeyAgICAvLyDmiYvliqjpgInmi6kKICAgICAgdGhpcy5kZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09IGRyaXZlclR5cGUpIHsKICAgICAgICAgIGRldmljZS5kZXZpY2UgPSBuZXdEZXZpY2U7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0sCgogICAgdXBkYXRlRGV2aWNlc18oTGlzdE51bSwgbmV3RGV2aWNlKSB7ICAgIC8vIOS7juaWh+S7tuWvvOWFpQogICAgICB0aGlzLmRldmljZXMuZm9yRWFjaChkZXZpY2UgPT4gewogICAgICAgIGlmIChkZXZpY2UuTGlzdE51bSA9PT0gTGlzdE51bSkgewogICAgICAgICAgZGV2aWNlLmRldmljZSA9IG5ld0RldmljZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICB0aGlzLmxvYWRpbmdDb25uZWN0QWxsRGV2aWNlID0gZmFsc2U7CiAgICB9LAoKICAgIHVwZGF0ZURldmljZXNDb25uZWN0KHR5cGUsIERldmljZU5hbWUsIERyaXZlck5hbWUsIGlzQmluZCA9IHRydWUpIHsgICAgLy8g6L+e5o6l5oiQ5YqfCiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ3VwZGF0ZURldmljZXNDb25uZWN0JyArIHR5cGUgKyAnICcgKyBEZXZpY2VOYW1lICsgJyAnICsgRHJpdmVyTmFtZSArICcgJyArIGlzQmluZCwgJ2luZm8nKTsKICAgICAgdGhpcy5kZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09IHR5cGUpIHsKICAgICAgICAgIGlmIChpc0JpbmQgPT0gdHJ1ZSkgewogICAgICAgICAgICBkZXZpY2UuZGV2aWNlID0gRGV2aWNlTmFtZTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRldmljZS5kZXZpY2UgPSAiTm90IEJpbmQgRGV2aWNlIjsKICAgICAgICAgIH0KICAgICAgICAgIGRldmljZS5kcml2ZXJOYW1lID0gRHJpdmVyTmFtZTsKICAgICAgICAgIGRldmljZS5pc0Nvbm5lY3RlZCA9IHRydWU7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3goRGV2aWNlTmFtZSArICcgc3VjY2VzcyBjb25uZWN0ZWQnLCAnc3VjY2VzcycpOwogICAgICB0aGlzLmhhdmVEZXZpY2VDb25uZWN0ID0gdHJ1ZTsKICAgICAgdGhpcy5sb2FkaW5nQ29ubmVjdEFsbERldmljZSA9IGZhbHNlOwoKICAgICAgaWYgKHR5cGUgPT09ICdNYWluQ2FtZXJhJykgewogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnTWFpbkNhbWVyYUNvbm5lY3RlZCcsIDEpOwogICAgICAgIGNvbnNvbGUubG9nKCdNYWluQ2FtZXJhIGlzIENvbm5lY3RlZC4nKTsKICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTW91bnQnKSB7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudENvbm5lY3RlZCcsIDEpOwogICAgICAgIGNvbnNvbGUubG9nKCdNb3VudCBpcyBDb25uZWN0ZWQuJyk7CiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0NGVycpIHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0NGV0Nvbm5lY3RlZCcsIDEpOwogICAgICAgIGNvbnNvbGUubG9nKCdNb3VudCBpcyBDb25uZWN0ZWQuJyk7CiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0ZvY3VzZXInKSB7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdGb2N1c2VyQ29ubmVjdGVkJywgMSk7CiAgICAgICAgY29uc29sZS5sb2coJ0ZvY3VzZXIgaXMgQ29ubmVjdGVkLicpOwogICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHdWlkZXInKSB7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdHdWlkZXJDb25uZWN0ZWQnLCAxKTsKICAgICAgICBjb25zb2xlLmxvZygnR3VpZGVyIGlzIENvbm5lY3RlZC4nKTsKICAgICAgfQogICAgICBjb25zb2xlLmxvZygndXBkYXRlRGV2aWNlc0Nvbm5lY3Q6ICcsIHR5cGUsIERldmljZU5hbWUsIERyaXZlck5hbWUsIGlzQmluZCk7CgogICAgICB0aGlzLiRidXMuJGVtaXQoJ0RldmljZUNvbm5lY3RTdWNjZXNzJywgdHlwZSwgRGV2aWNlTmFtZSwgRHJpdmVyTmFtZSwgaXNCaW5kKTsKICAgIH0sCiAgICBzdGFydENvbm5lY3RCdG5QcmVzcyhldmVudCkgewogICAgICAvLyDlpoLmnpzmmK/op6bmkbjkuovku7bvvIzmoIforrDlubblpITnkIYKICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykgewogICAgICAgIHRoaXMuaXNUb3VjaGluZyA9IHRydWU7CiAgICAgICAgdGhpcy5pc0Nvbm5lY3RCdG5Mb25nUHJlc3MgPSBmYWxzZTsgLy8g6YeN572u6ZW/5oyJ5qCH6K6wCiAgICAgICAgLy8gdGhpcy5Db25uZWN0QnRuUHJlc3NUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgIC8vICAgdGhpcy5pc0Nvbm5lY3RCdG5Mb25nUHJlc3MgPSB0cnVlOyAvLyDmoIforrDkuLrplb/mjIkKICAgICAgICAvLyAgIHRoaXMuaGFuZGxlQ29ubmVjdEJ0bkxvbmdQcmVzcygpOwogICAgICAgIC8vIH0sIHRoaXMuQ29ubmVjdEJ0bmxvbmdQcmVzc1RocmVzaG9sZCk7CiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0QnRuQ2xpY2soKTsKICAgICAgfQogICAgICAvLyDlpoLmnpzmmK/pvKDmoIfkuovku7bvvIzkuJTmsqHmnInmraPlnKjov5vooYznmoTop6bmkbjkuovku7bvvIzliJnlpITnkIYKICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgIXRoaXMuaXNUb3VjaGluZykgewogICAgICAgIHRoaXMuaXNDb25uZWN0QnRuTG9uZ1ByZXNzID0gZmFsc2U7IC8vIOmHjee9rumVv+aMieagh+iusAogICAgICAgIC8vIHRoaXMuQ29ubmVjdEJ0blByZXNzVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAvLyAgIHRoaXMuaXNDb25uZWN0QnRuTG9uZ1ByZXNzID0gdHJ1ZTsgLy8g5qCH6K6w5Li66ZW/5oyJCiAgICAgICAgLy8gICB0aGlzLmhhbmRsZUNvbm5lY3RCdG5Mb25nUHJlc3MoKTsKICAgICAgICAvLyB9LCB0aGlzLkNvbm5lY3RCdG5sb25nUHJlc3NUaHJlc2hvbGQpOwogICAgICAgIHRoaXMuaGFuZGxlQ29ubmVjdEJ0bkNsaWNrKCk7CiAgICAgIH0KICAgIH0sCiAgICBlbmRDb25uZWN0QnRuUHJlc3MoZXZlbnQpIHsKICAgICAgLy8g5aaC5p6c5piv6Kem5pG45LqL5Lu277yM5aSE55CG5bm26YeN572u5qCH6K6wCiAgICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hlbmQnKSB7CiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuQ29ubmVjdEJ0blByZXNzVGltZXIpOyAvLyDmuIXpmaTlrprml7blmagKICAgICAgICAvLyBpZiAoIXRoaXMuaXNDb25uZWN0QnRuTG9uZ1ByZXNzKSB7CiAgICAgICAgLy8gICB0aGlzLmhhbmRsZUNvbm5lY3RCdG5DbGljaygpOyAvLyDlpoLmnpzkuI3mmK/plb/mjInvvIzliJnop6blj5Hngrnlh7vkuovku7YKICAgICAgICAvLyB9CiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0QnRuQ2xpY2soKTsKICAgICAgICB0aGlzLkNvbm5lY3RCdG5QcmVzc1RpbWVyID0gbnVsbDsgLy8g6YeN572u5a6a5pe25ZmoCiAgICAgICAgdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7IC8vIOmHjee9ruinpuaRuOagh+iusAogICAgICB9CiAgICAgIC8vIOWmguaenOaYr+m8oOagh+S6i+S7tu+8jOS4lOayoeacieato+WcqOi/m+ihjOeahOinpuaRuOS6i+S7tu+8jOWImeWkhOeQhgogICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAnbW91c2V1cCcgJiYgIXRoaXMuaXNUb3VjaGluZykgewogICAgICAgIGNsZWFyVGltZW91dCh0aGlzLkNvbm5lY3RCdG5QcmVzc1RpbWVyKTsgLy8g5riF6Zmk5a6a5pe25ZmoCiAgICAgICAgLy8gaWYgKCF0aGlzLmlzQ29ubmVjdEJ0bkxvbmdQcmVzcykgewogICAgICAgIC8vICAgdGhpcy5oYW5kbGVDb25uZWN0QnRuQ2xpY2soKTsgLy8g5aaC5p6c5LiN5piv6ZW/5oyJ77yM5YiZ6Kem5Y+R54K55Ye75LqL5Lu2CiAgICAgICAgLy8gfQogICAgICAgIHRoaXMuaGFuZGxlQ29ubmVjdEJ0bkNsaWNrKCk7CiAgICAgICAgdGhpcy5Db25uZWN0QnRuUHJlc3NUaW1lciA9IG51bGw7IC8vIOmHjee9ruWumuaXtuWZqAogICAgICB9CiAgICB9LAogICAgaGFuZGxlQ29ubmVjdEJ0bkNsaWNrKCkgewogICAgICBpZiAodGhpcy5oYXZlRGV2aWNlQ29ubmVjdCkgewogICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KCdQbGVhc2UgZGlzY29ubmVjdCBhbGwgZGV2aWNlcyBmaXJzdC4nLCAnZXJyb3InKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKCF0aGlzLkNvbm5lY3RCdG5DYW5DbGljaykgcmV0dXJuOyAvLyDlpoLmnpzkuI3lj6/ngrnlh7vvvIznm7TmjqXov5Tlm54KICAgICAgdGhpcy5Db25uZWN0QnRuQ2FuQ2xpY2sgPSBmYWxzZTsgLy8g6K6+572u5Li65LiN5Y+v54K55Ye7CiAgICAgIGNvbnNvbGUubG9nKCJDb25uZWN0IEJ1dHRvbiBjbGlja2VkIik7CgogICAgICB0aGlzLmNvbm5lY3RBbGxEZXZpY2UoKTsKCiAgICAgIC8vIOaBouWkjeeCueWHu+adg+mZkAogICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICB0aGlzLkNvbm5lY3RCdG5DYW5DbGljayA9IHRydWU7CiAgICAgIH0sIDEwMDApOyAvLyAx56eS5ZCO5oGi5aSNCiAgICB9LAogICAgaGFuZGxlQ29ubmVjdEJ0bkxvbmdQcmVzcygpIHsKICAgICAgaWYgKHRoaXMuaGF2ZURldmljZUNvbm5lY3QpIHsKICAgICAgICB0aGlzLmNhbGxTaG93TWVzc2FnZUJveCgnUGxlYXNlIGRpc2Nvbm5lY3QgYWxsIGRldmljZXMgZmlyc3QuJywgJ2Vycm9yJyk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIC8vIOmVv+aMieS6i+S7tueahOWkhOeQhgogICAgICBjb25zb2xlLmxvZygiQ29ubmVjdCBCdXR0b24gbG9uZyBwcmVzc2VkIik7CgogICAgICB0aGlzLmF1dG9Db25uZWN0QWxsRGV2aWNlKCk7CiAgICB9LAogICAgY29ubmVjdEFsbERldmljZSgpIHsKICAgICAgY29uc29sZS5sb2coIlFIWUNDRCB8IGNvbm5lY3RBbGxEZXZpY2UuIik7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0Nvbm5lY3QgQWxsIERldmljZScsICdpbmZvJyk7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ2Nvbm5lY3RBbGxEZXZpY2UnKTsKICAgICAgdGhpcy5sb2FkaW5nQ29ubmVjdEFsbERldmljZSA9IHRydWU7CiAgICB9LAogICAgYXV0b0Nvbm5lY3RBbGxEZXZpY2UoKSB7CiAgICAgIGNvbnNvbGUubG9nKCJRSFlDQ0QgfCBhdXRvQ29ubmVjdEFsbERldmljZS4iKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQXV0byBDb25uZWN0IEFsbCBEZXZpY2UnLCAnaW5mbycpOwogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdhdXRvQ29ubmVjdEFsbERldmljZScpOwogICAgICB0aGlzLmxvYWRpbmdDb25uZWN0QWxsRGV2aWNlID0gdHJ1ZTsKICAgIH0sCgogICAgZGlzY29ubmVjdEFsbERldmljZShjb25maXJtKSB7CiAgICAgIC8vIOajgOafpeaYr+WQpuacieiuvuWkh+eahCBpc0Nvbm5lY3RlZCDlsZ7mgKfkuLogdHJ1ZQogICAgICAvLyBjb25zdCBoYXNDb25uZWN0ZWREZXZpY2VzID0gdGhpcy5kZXZpY2VzLnNvbWUoZGV2aWNlID0+IGRldmljZS5pc0Nvbm5lY3RlZCk7CgogICAgICBpZiAodGhpcy5oYXZlRGV2aWNlQ29ubmVjdCkgewogICAgICAgIGlmIChjb25maXJtID09PSBmYWxzZSkgewogICAgICAgICAgdGhpcy5TaG93Q29uZmlybURpYWxvZygnQ29uZmlybScsICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGlzY29ubmVjdCBhbGwgZGV2aWNlcz8nLCAnZGlzY29ubmVjdEFsbERldmljZScpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdkaXNjb25uZWN0QWxsRGV2aWNlJyk7CiAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdEaXNjb25uZWN0IEFsbCBEZXZpY2UnLCAnaW5mbycpOwogICAgICAgICAgdGhpcy5oYXZlRGV2aWNlQ29ubmVjdCA9IGZhbHNlOwogICAgICAgICAgLy8gdGhpcy5kZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHsKICAgICAgICAgIC8vICAgZGV2aWNlLmlzQ29ubmVjdGVkID0gZmFsc2U7CiAgICAgICAgICAvLyAgIC8vIGRldmljZS5kZXZpY2UgPSAnJzsKICAgICAgICAgIC8vIH0pOwoKICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnTWFpbkNhbWVyYUNvbm5lY3RlZCcsIDApOwogICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudENvbm5lY3RlZCcsIDApOwogICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdDRldDb25uZWN0ZWQnLCAwKTsKICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnRm9jdXNlckNvbm5lY3RlZCcsIDApOwogICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdHdWlkZXJDb25uZWN0ZWQnLCAwKTsKICAgICAgICAgIHRoaXMuY2xlYXJEZXZpY2VMaXN0KCk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KCdObyBkZXZpY2VzIGhhdmUgYmVlbiBjb25uZWN0ZWQuJywgJ2Vycm9yJyk7CiAgICAgIH0KICAgICAgdGhpcy5zZWxlY3RlZERyaXZlciA9ICcnOwogICAgfSwKCiAgICBjbGVhckRldmljZUxpc3QoKSB7CiAgICAgIHRoaXMuZGV2aWNlcy5mb3JFYWNoKGRldmljZSA9PiB7CiAgICAgICAgZGV2aWNlLmRldmljZSA9IGRldmljZS5kcml2ZXJOYW1lOwogICAgICAgIGRldmljZS5pc0Nvbm5lY3RlZCA9IGZhbHNlOwogICAgICAgIGRldmljZS5pc2dldCA9IGZhbHNlOwogICAgICAgIGRldmljZS5CYXVkUmF0ZSA9IDk2MDA7CiAgICAgIH0pOwogICAgICB0aGlzLlRvQmVDb25uZWN0RGV2aWNlID0gW107CiAgICAgIHRoaXMuZGV2aWNlc0xpc3QgPSBbXTsKICAgICAgdGhpcy5kcml2ZXJzID0gW107CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnY2xlYXJEZXZpY2VBbGxvY2F0aW9uTGlzdCcpOwogICAgfSwKCiAgICBTd2l0Y2hPdXRQdXRQb3dlcihpbmRleCwgaXNQb3dlck9OKSB7CiAgICAgIGlmIChpc1Bvd2VyT04pIHsKICAgICAgICB0aGlzLmRyYXdlcl8yID0gZmFsc2U7CiAgICAgICAgdGhpcy5TaG93Q29uZmlybURpYWxvZygnT3V0cHV0IFBvd2VyOicgKyBpbmRleCwgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byB0dXJuIG9mZiB0aGlzIG91dHB1dCBwb3dlcj8nLCAnU3dpdGNoT3V0UHV0UG93ZXInKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ1N3aXRjaE91dFB1dFBvd2VyOicgKyBpbmRleCk7CiAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnU3dpdGNoIE91dFB1dFBvd2VyJyArIGluZGV4LCAnaW5mbycpOwogICAgICB9CiAgICB9LAoKICAgIFJlc3RhcnRSYXNwYmVycnlQaSgpIHsKICAgICAgdGhpcy5kcmF3ZXJfMiA9IGZhbHNlOwogICAgICB0aGlzLlNob3dDb25maXJtRGlhbG9nKCdSZXN0YXJ0JywgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZXN0YXJ0IHRoZSBSYXNwYmVycnkgUGk/JywgJ1Jlc3RhcnRSYXNwYmVycnlQaScpOwogICAgfSwKCiAgICBTaHV0ZG93blJhc3BiZXJyeVBpKCkgewogICAgICB0aGlzLmRyYXdlcl8yID0gZmFsc2U7CiAgICAgIHRoaXMuU2hvd0NvbmZpcm1EaWFsb2coJ1NodXQgRG93bicsICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gc2h1dCBkb3duIHRoZSBSYXNwYmVycnkgUGk/JywgJ1NodXRkb3duUmFzcGJlcnJ5UGknKTsKICAgIH0sCgogICAgRm9yY2VVcGRhdGUoKSB7CiAgICAgIHRoaXMuZHJhd2VyXzIgPSBmYWxzZTsKICAgICAgdGhpcy5TaG93Q29uZmlybURpYWxvZygnRm9yY2UgVXBkYXRlJywgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBmb3JjZSB1cGRhdGUgdGhlIFJhc3BiZXJyeSBQaT8nLCAnRm9yY2VVcGRhdGUnKTsKICAgIH0sCgogICAgUmV0dXJuQ29ubmVjdGVkRGV2aWNlcygpIHsKICAgICAgdGhpcy5kZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09ICdNYWluQ2FtZXJhJykgewogICAgICAgICAgaWYgKGRldmljZS5pc0Nvbm5lY3RlZCA9PT0gdHJ1ZSkgewogICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ01haW5DYW1lcmFDb25uZWN0ZWQnLCAxKTsKICAgICAgICAgICAgY29uc29sZS5sb2coJ01haW5DYW1lcmEgaXMgQ29ubmVjdGVkLicpOwogICAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdNYWluQ2FtZXJhIGlzIENvbm5lY3RlZC4nLCAnaW5mbycpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09ICdNb3VudCcpIHsKICAgICAgICAgIGlmIChkZXZpY2UuaXNDb25uZWN0ZWQgPT09IHRydWUpIHsKICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudENvbm5lY3RlZCcsIDEpOwogICAgICAgICAgICBjb25zb2xlLmxvZygnTW91bnQgaXMgQ29ubmVjdGVkLicpOwogICAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdNb3VudCBpcyBDb25uZWN0ZWQuJywgJ2luZm8nKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pOwogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdsb2FkU2VsZWN0ZWREcml2ZXJMaXN0Jyk7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ2xvYWRCaW5kRGV2aWNlTGlzdCcpOwogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdsb2FkQmluZERldmljZVR5cGVMaXN0Jyk7CiAgICB9LAoKICAgIE9wZW5JYW1nZUZvbGRlcigpIHsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdJbWFnZU1hbmFnZXJQYW5lbE9wZW4nKTsKICAgICAgdGhpcy5uYXYgPSBmYWxzZTsKICAgIH0sCgogICAgT3BlbkRlYnVnTG9nKCkgewogICAgICB0aGlzLiRidXMuJGVtaXQoJ3RvZ2dsZUlORElEZWJ1Z0RpYWxvZycpOwogICAgICB0aGlzLm5hdiA9IGZhbHNlOwogICAgfSwKCiAgICBTZW5kQ29uc29sZUxvZ01zZyhtZXNzYWdlLCB0eXBlKSB7CiAgICAgIGlmICh0eXBlID09ICdlcnJvcicpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogJyArIG1lc3NhZ2UpOwogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2VuZENvbnNvbGVMb2cnLCB0eXBlLCBtZXNzYWdlKTsKICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdpbmZvJykgewogICAgICAgIGNvbnNvbGUubG9nKCdJbmZvOiAnICsgbWVzc2FnZSk7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTZW5kQ29uc29sZUxvZycsIHR5cGUsIG1lc3NhZ2UpOwogICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3dhcm5pbmcnKSB7CiAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiAnICsgbWVzc2FnZSk7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTZW5kQ29uc29sZUxvZycsIHR5cGUsIG1lc3NhZ2UpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnNvbGUubG9nKCdEZWJ1ZzogJyArIG1lc3NhZ2UpOwogICAgICB9CiAgICB9LAoKICAgIERldmljZUFsbG9jYXRpb24oKSB7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgndG9nZ2xlRGV2aWNlQWxsb2NhdGlvblBhbmVsJyk7CiAgICAgIHRoaXMubmF2ID0gZmFsc2U7CiAgICB9LAoKICAgIC8vIEN1cnJlbnRFeHBUaW1lTGlzdChpbmRleCwgdmFsdWUpIHsKICAgIC8vICAgY29uc3QgZXhwVGltZUluZGV4ID0gdGhpcy5NYWluQ2FtZXJhQ29uZmlnSXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5sYWJlbCA9PT0gJ0V4cFRpbWUgWycgKyAoaW5kZXggKyAxKSArICddJyk7CiAgICAvLyAgIGlmIChleHBUaW1lSW5kZXggIT09IC0xKSB7IC8vIOehruS/neaJvuWIsOS6huWvueW6lOeahOmFjee9rumhuQogICAgLy8gICAgIC8vIOabtOaWsCBFeHBUaW1lMSDphY3nva7pobnnmoTlgLwKICAgIC8vICAgICB0aGlzLk1haW5DYW1lcmFDb25maWdJdGVtc1tleHBUaW1lSW5kZXhdLnZhbHVlID0gdmFsdWU7CiAgICAvLyAgIH0gZWxzZSB7CiAgICAvLyAgICAgY29uc29sZS5lcnJvcignRXhwVGltZSBbJyArIGluZGV4ICsgJ10gY29uZmlndXJhdGlvbiBpdGVtIG5vdCBmb3VuZC4nKTsKICAgIC8vICAgfQogICAgLy8gfSwKCiAgICBDdXJyZW50Q0ZXTGlzdChpbmRleCwgdmFsdWUpIHsKICAgICAgY29uc3QgZXhwVGltZUluZGV4ID0gdGhpcy5DRldDb25maWdJdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmxhYmVsID09PSAnQ0ZXIFsnICsgKGluZGV4ICsgMSkgKyAnXScpOwogICAgICBpZiAoZXhwVGltZUluZGV4ICE9PSAtMSkgeyAvLyDnoa7kv53mib7liLDkuoblr7nlupTnmoTphY3nva7pobkKICAgICAgICAvLyDmm7TmlrAgRXhwVGltZTEg6YWN572u6aG555qE5YC8CiAgICAgICAgdGhpcy5DRldDb25maWdJdGVtc1tleHBUaW1lSW5kZXhdLnZhbHVlID0gdmFsdWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc29sZS5lcnJvcignQ0ZXIFsnICsgaW5kZXggKyAnXSBjb25maWd1cmF0aW9uIGl0ZW0gbm90IGZvdW5kLicpOwogICAgICB9CiAgICB9LAoKICAgIGNvbmZpcm1Db25maWd1cmF0aW9uKExpc3QpIHsKICAgICAgTGlzdC5mb3JFYWNoKGl0ZW0gPT4gewogICAgICAgIGlmIChpdGVtLnZhbHVlICE9PSAnJykgewogICAgICAgICAgLy8gY29uc29sZS5sb2coaXRlbS5sYWJlbCwgaXRlbS52YWx1ZSk7CiAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKGl0ZW0ubGFiZWwgKyAnOicgKyBpdGVtLnZhbHVlLCAnaW5mbycpOwogICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KGl0ZW0ubGFiZWwsIGl0ZW0ubGFiZWwgKyAnOicgKyBpdGVtLnZhbHVlKTsKICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udmFsdWUgPT0gJycgJiYgaXRlbS5sYWJlbCA9PT0gJ0ZvY2FsIExlbmd0aCAobW0pJykgewogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZyhpdGVtLmxhYmVsICsgJ2lzIE5VTEwnLCAnaW5mbycpOwogICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KGl0ZW0ubGFiZWwsIGl0ZW0ubGFiZWwgKyAnOicpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KCdDb25maWd1cmF0aW9uIGhhcyBiZWVuIG1vZGlmaWVkIScsICdzdWNjZXNzJyk7CiAgICB9LAoKICAgIGxvYWRBbmREaXNwbGF5SW1hZ2UoaW1hZ2VQYXRoKSB7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdndWlkZXJDYW1lcmEtY2FudmFzJyk7CiAgICAgIC8vIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluQ2FtZXJhLWNhbnZhcycpOwogICAgICBpZiAoY2FudmFzLmdldENvbnRleHQpIHsKICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTsKCiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHsKICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDsKICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0OwogICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpOwogICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApOwogICAgICAgICAgLy8gdGhpcy4kYnVzLiRlbWl0KCdzaG93U29sdmVJbWFnZScsIGltZyk7CiAgICAgICAgfTsKCiAgICAgICAgLy8g5re75Yqg6ZSZ6K+v5aSE55CGCiAgICAgICAgaW1nLm9uZXJyb3IgPSAoZXJyb3IpID0+IHsKICAgICAgICAgIGNvbnNvbGUubG9nKGDliqDovb3lm77lg4/lpLHotKU6ICR7aW1hZ2VQYXRofWApOwogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZyhg5Yqg6L295Zu+5YOP5aSx6LSlOiAke2ltYWdlUGF0aH1gLCAnZXJyb3InKTsKICAgICAgICB9OwoKICAgICAgICBpbWcuc3JjID0gaW1hZ2VQYXRoOwogICAgICB9CiAgICB9LAoKICAgIEltYWdlR2FpblNldChwYXlsb2FkKSB7CiAgICAgIGNvbnN0IFtzaWduYWwsIHZhbHVlXSA9IHBheWxvYWQuc3BsaXQoJzonKTsgLy8g5ouG5YiG5L+h5Y+35ZKM5YC8CiAgICAgIGNvbnN0IGRvdWJsZVZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7IC8vIOWwhuWAvOi9rOaNouS4uiBkb3VibGUg57G75Z6LCgogICAgICBpZiAoc2lnbmFsID09PSAnSW1hZ2VHYWluUicpIHsKICAgICAgICAvLyDlpITnkIYgSW1hZ2VHYWluUiDkv6Hlj7cKICAgICAgICB0aGlzLkltYWdlR2FpblIgPSBkb3VibGVWYWx1ZTsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdJbWFnZUdhaW5SIGlzIHNldCB0bzonICsgZG91YmxlVmFsdWUsICdpbmZvJyk7CiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnSW1hZ2VHYWluUjonICsgZG91YmxlVmFsdWUpOwogICAgICB9IGVsc2UgaWYgKHNpZ25hbCA9PT0gJ0ltYWdlR2FpbkInKSB7CiAgICAgICAgLy8g5aSE55CGIEltYWdlR2FpbkIg5L+h5Y+3CiAgICAgICAgdGhpcy5JbWFnZUdhaW5CID0gZG91YmxlVmFsdWU7CiAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnSW1hZ2VHYWluQiBpcyBzZXQgdG86JyArIGRvdWJsZVZhbHVlLCAnaW5mbycpOwogICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ0ltYWdlR2FpbkI6JyArIGRvdWJsZVZhbHVlKTsKICAgICAgfQogICAgfSwKCiAgICBJbWFnZU9mZnNldFNldChwYXlsb2FkKSB7CiAgICAgIGNvbnN0IFtzaWduYWwsIHZhbHVlXSA9IHBheWxvYWQuc3BsaXQoJzonKTsgLy8g5ouG5YiG5L+h5Y+35ZKM5YC8CiAgICAgIGNvbnN0IGRvdWJsZVZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7IC8vIOWwhuWAvOi9rOaNouS4uiBkb3VibGUg57G75Z6LCgogICAgICB0aGlzLkltYWdlT2Zmc2V0ID0gZG91YmxlVmFsdWU7CiAgICAgIGNvbnNvbGUubG9nKCdJbWFnZSBPZmZzZXQgaXMgc2V0IHRvOicsIGRvdWJsZVZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnSW1hZ2UgT2Zmc2V0IGlzIHNldCB0bzonICsgZG91YmxlVmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ0ltYWdlT2Zmc2V0OicgKyBkb3VibGVWYWx1ZSk7CiAgICB9LAoKICAgIEJpbm5pbmdTZXQocGF5bG9hZCkgewogICAgICBjb25zdCBbc2lnbmFsLCB2YWx1ZV0gPSBwYXlsb2FkLnNwbGl0KCc6Jyk7IC8vIOaLhuWIhuS/oeWPt+WSjOWAvAogICAgICBjb25zdCBJbnRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTsgLy8g5bCG5YC86L2s5o2i5Li6IEludCDnsbvlnosKICAgICAgdGhpcy5jYW1lcmFCaW4gPSBJbnRWYWx1ZTsKICAgICAgY29uc29sZS5sb2coJ0ltYWdlIEJpbm5pbmcgaXMgc2V0IHRvOicsIEludFZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnSW1hZ2UgQmlubmluZyBpcyBzZXQgdG86JyArIEludFZhbHVlLCAnaW5mbycpOwogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdTZXRCaW5uaW5nOicgKyBJbnRWYWx1ZSk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2V0QmlubmluZ051bScsIEludFZhbHVlKTsKICAgIH0sCgogICAgR2FpblNldChwYXlsb2FkKSB7CiAgICAgIGNvbnN0IFtzaWduYWwsIHZhbHVlXSA9IHBheWxvYWQuc3BsaXQoJzonKTsgLy8g5ouG5YiG5L+h5Y+35ZKM5YC8CiAgICAgIGNvbnN0IEludFZhbHVlID0gcGFyc2VJbnQodmFsdWUpOyAvLyDlsIblgLzovazmjaLkuLogSW50IOexu+WeiwoKICAgICAgY29uc29sZS5sb2coJ0NhbWVyYSBHYWluIGlzIHNldCB0bzonLCBJbnRWYWx1ZSk7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0NhbWVyYSBHYWluIGlzIHNldCB0bzonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ1NldENhbWVyYUdhaW46JyArIEludFZhbHVlKTsKICAgIH0sCgogICAgT2Zmc2V0U2V0KHBheWxvYWQpIHsKICAgICAgY29uc3QgW3NpZ25hbCwgdmFsdWVdID0gcGF5bG9hZC5zcGxpdCgnOicpOyAvLyDmi4bliIbkv6Hlj7flkozlgLwKICAgICAgY29uc3QgSW50VmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7IC8vIOWwhuWAvOi9rOaNouS4uiBJbnQg57G75Z6LCgogICAgICBjb25zb2xlLmxvZygnQ2FtZXJhIE9mZnNldCBpcyBzZXQgdG86JywgSW50VmFsdWUpOwogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYW1lcmEgT2Zmc2V0IGlzIHNldCB0bzonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ1NldENhbWVyYU9mZnNldDonICsgSW50VmFsdWUpOwogICAgfSwKCiAgICBJbWFnZUNGQVNldChwYXlsb2FkKSB7CiAgICAgIGNvbnN0IFtzaWduYWwsIHZhbHVlXSA9IHBheWxvYWQuc3BsaXQoJzonKTsgLy8g5ouG5YiG5L+h5Y+35ZKM5YC8CgogICAgICAvLyBpZiAoWydHUicsICdHQicsICdCRycsICdSR0dCJywnbnVsbCddLmluY2x1ZGVzKHZhbHVlKSkgewogICAgICBpZiAoWydHUicsICdHQicsICdCRycsICdSRycsICdHUkJHJywgJ0dCUkcnLCAnQkdHUicsICdSR0dCJywgJ251bGwnLCAnJ10uaW5jbHVkZXModmFsdWUpKSB7CiAgICAgICAgaWYgKHZhbHVlID09PSAnJykgewogICAgICAgICAgdmFsdWUgPSAnbnVsbCc7CiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ0dSQkcnKSB7CiAgICAgICAgICB2YWx1ZSA9ICdHUic7CiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ0dCUkcnKSB7CiAgICAgICAgICB2YWx1ZSA9ICdHQic7CiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ0JHR1InKSB7CiAgICAgICAgICB2YWx1ZSA9ICdCRyc7CiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ1JHJykgewogICAgICAgICAgdmFsdWUgPSAnUkdHQic7CiAgICAgICAgfQogICAgICAgIHRoaXMuSW1hZ2VDRkEgPSB2YWx1ZTsKICAgICAgICAvLyBjb25zb2xlLmxvZygnSW1hZ2VDRkEgaXMgc2V0IHRvOicsIHZhbHVlKTsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdJbWFnZUNGQSBpcyBzZXQgdG86JyArIHZhbHVlLCAnaW5mbycpOwogICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ0ltYWdlQ0ZBOicgKyB2YWx1ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gY29uc29sZS5sb2coYEludmFsaWQgdmFsdWUgZm9yIEltYWdlQ0ZBOiAnJHt2YWx1ZX0nLiBQbGVhc2Ugc2V0IGl0IHRvIG9uZSBvZiAnR1InLCAnR0InLCAnQkcnLCAnUkdHQicuYCk7CiAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3goYEludmFsaWQgdmFsdWUgZm9yIEltYWdlQ0ZBOiAnJHt2YWx1ZX0nLiBQbGVhc2Ugc2V0IGl0IHRvIG9uZSBvZiAnR1InLCAnR0InLCAnQkcnLCAnUkdHQicuYCwgJ2Vycm9yJyk7CiAgICAgIH0KICAgIH0sCgogICAgQ2FtZXJhVGVtcGVyYXR1cmVTZXQocGF5bG9hZCkgewogICAgICBjb25zdCBbc2lnbmFsLCB2YWx1ZV0gPSBwYXlsb2FkLnNwbGl0KCc6Jyk7IC8vIOaLhuWIhuS/oeWPt+WSjOWAvAogICAgICBjb25zdCBJbnRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTsgLy8g5bCG5YC86L2s5o2i5Li6IEludCDnsbvlnosKCiAgICAgIGNvbnNvbGUubG9nKCdDYW1lcmEgVGVtcGVyYXR1cmUgaXMgc2V0IHRvOicsIEludFZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FtZXJhIFRlbXBlcmF0dXJlIGlzIHNldCB0bzonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1Z1ZV9Db21tYW5kJywgJ1NldENhbWVyYVRlbXBlcmF0dXJlOicgKyBJbnRWYWx1ZSk7CiAgICB9LAoKICAgIEZvY2FsTGVuZ3RoU2V0KHBheWxvYWQpIHsKICAgICAgY29uc3QgW3NpZ25hbCwgdmFsdWVdID0gcGF5bG9hZC5zcGxpdCgnOicpOyAvLyDmi4bliIbkv6Hlj7flkozlgLwKCiAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIHRoaXMuZGV2aWNlcykgewogICAgICAgIGlmIChkZXZpY2UuZHJpdmVyVHlwZSA9PT0gJ1RlbGVzY29wZXMnKSB7CgogICAgICAgICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gTmFOKSB7CiAgICAgICAgICAgIGRldmljZS5kZXZpY2UgPSAnJzsKICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnRm9jYWwgTGVuZ3RoIGlzIHNldCB0bzonICsgMCwgJ2luZm8nKTsKICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTZXRGb2NhbExlbmd0aE51bScsICcnKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IEludFZhbHVlID0gcGFyc2VJbnQodmFsdWUpOyAvLyDlsIblgLzovazmjaLkuLogSW50IOexu+WeiwogICAgICAgICAgICBkZXZpY2UuZGV2aWNlID0gdmFsdWUgKyAnIG1tJzsKICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnRm9jYWwgTGVuZ3RoIGlzIHNldCB0bzonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2V0Rm9jYWxMZW5ndGhOdW0nLCBJbnRWYWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgoKICAgIH0sCgogICAgR3VpZGVyRm9jYWxMZW5ndGhTZXQocGF5bG9hZCkgewogICAgICBjb25zdCBbc2lnbmFsLCB2YWx1ZV0gPSBwYXlsb2FkLnNwbGl0KCc6Jyk7IC8vIOaLhuWIhuS/oeWPt+WSjOWAvAogICAgICBjb25zdCBJbnRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTsgLy8g5bCG5YC86L2s5o2i5Li6IEludCDnsbvlnosKCgogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdHdWlkZXIgRm9jYWwgTGVuZ3RoIGlzIHNldCB0bzonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnR3VpZGVyRm9jYWxMZW5ndGg6JyArIEludFZhbHVlKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdzYXZlVG9Db25maWdGaWxlOkd1aWRlckZvY2FsTGVuZ3RoOicgKyBJbnRWYWx1ZSk7CiAgICB9LAoKICAgIE11bHRpU3Rhckd1aWRlclNldChwYXlsb2FkKSB7CiAgICAgIGNvbnN0IFtzaWduYWwsIHZhbHVlXSA9IHBheWxvYWQuc3BsaXQoJzonKTsgLy8g5ouG5YiG5L+h5Y+35ZKM5YC8CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ011bHRpIFN0YXIgR3VpZGVyIGlzIHNldCB0bzonICsgdmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnTXVsdGlTdGFyR3VpZGVyOicgKyB2YWx1ZSk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnc2F2ZVRvQ29uZmlnRmlsZTpNdWx0aVN0YXJHdWlkZXI6JyArIHZhbHVlKTsKICAgIH0sCgogICAgR3VpZGVyUGl4ZWxTaXplU2V0KHBheWxvYWQpIHsKICAgICAgY29uc3QgW3NpZ25hbCwgdmFsdWVdID0gcGF5bG9hZC5zcGxpdCgnOicpOyAvLyDmi4bliIbkv6Hlj7flkozlgLwKICAgICAgY29uc3QgZG91YmxlVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnR3VpZGVyIFBpeGVsIHNpemUgaXMgc2V0IHRvOicgKyBkb3VibGVWYWx1ZSwgJ2luZm8nKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdHdWlkZXJQaXhlbFNpemU6JyArIGRvdWJsZVZhbHVlKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdzYXZlVG9Db25maWdGaWxlOkd1aWRlclBpeGVsU2l6ZTonICsgZG91YmxlVmFsdWUpOwogICAgfSwKCiAgICBHdWlkZXJHYWluU2V0KHBheWxvYWQpIHsKICAgICAgY29uc3QgW3NpZ25hbCwgdmFsdWVdID0gcGF5bG9hZC5zcGxpdCgnOicpOyAvLyDmi4bliIbkv6Hlj7flkozlgLwKICAgICAgY29uc3QgSW50VmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0d1aWRlciBHYWluIGlzIHNldCB0bzonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnR3VpZGVyR2FpbjonICsgSW50VmFsdWUpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ3NhdmVUb0NvbmZpZ0ZpbGU6R3VpZGVyR2FpbjonICsgSW50VmFsdWUpOwogICAgfSwKCiAgICBDYWxpYnJhdGlvbkR1cmF0aW9uU2V0KHBheWxvYWQpIHsKICAgICAgY29uc3QgW3NpZ25hbCwgdmFsdWVdID0gcGF5bG9hZC5zcGxpdCgnOicpOyAvLyDmi4bliIbkv6Hlj7flkozlgLwKICAgICAgY29uc3QgSW50VmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0d1aWRlciBDYWxpYnJhdGlvbiBzdGVwIGlzIHNldCB0bzonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnQ2FsaWJyYXRpb25EdXJhdGlvbjonICsgSW50VmFsdWUpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ3NhdmVUb0NvbmZpZ0ZpbGU6Q2FsaWJyYXRpb25EdXJhdGlvbjonICsgSW50VmFsdWUpOwogICAgfSwKCiAgICBSYUFnZ3Jlc3Npb25TZXQocGF5bG9hZCkgewogICAgICBjb25zdCBbc2lnbmFsLCB2YWx1ZV0gPSBwYXlsb2FkLnNwbGl0KCc6Jyk7IC8vIOaLhuWIhuS/oeWPt+WSjOWAvAogICAgICBjb25zdCBJbnRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnUmEgQWdncmVzc2lvbiBpcyBzZXQgdG86JyArIEludFZhbHVlLCAnaW5mbycpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ1JhQWdncmVzc2lvbjonICsgSW50VmFsdWUpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ3NhdmVUb0NvbmZpZ0ZpbGU6UmFBZ2dyZXNzaW9uOicgKyBJbnRWYWx1ZSk7CiAgICB9LAoKICAgIERlY0FnZ3Jlc3Npb25TZXQocGF5bG9hZCkgewogICAgICBjb25zdCBbc2lnbmFsLCB2YWx1ZV0gPSBwYXlsb2FkLnNwbGl0KCc6Jyk7IC8vIOaLhuWIhuS/oeWPt+WSjOWAvAogICAgICBjb25zdCBJbnRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnRGVjIEFnZ3Jlc3Npb24gaXMgc2V0IHRvOicgKyBJbnRWYWx1ZSwgJ2luZm8nKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdEZWNBZ2dyZXNzaW9uOicgKyBJbnRWYWx1ZSk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnc2F2ZVRvQ29uZmlnRmlsZTpEZWNBZ2dyZXNzaW9uOicgKyBJbnRWYWx1ZSk7CiAgICB9LAoKICAgIFN5bmNGb2N1c2VyU3RlcChwYXlsb2FkKSB7CiAgICAgIGNvbnN0IFtzaWduYWwsIHZhbHVlXSA9IHBheWxvYWQuc3BsaXQoJzonKTsgLy8g5ouG5YiG5L+h5Y+35ZKM5YC8CiAgICAgIGNvbnN0IEludFZhbHVlID0gcGFyc2VJbnQodmFsdWUpOwogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdTeW5jIEZvY3VzZXIgU3RlcDonICsgSW50VmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnU3luY0ZvY3VzZXJTdGVwOicgKyBJbnRWYWx1ZSk7CiAgICB9LAoKICAgIEdvdG9UaGVuU29sdmUocGF5bG9hZCkgewogICAgICBjb25zdCBbc2lnbmFsLCB2YWx1ZV0gPSBwYXlsb2FkLnNwbGl0KCc6Jyk7IC8vIOaLhuWIhuS/oeWPt+WSjOWAvAogICAgICBjb25zdCBCb29sZWFuVmFsdWUgPSBCb29sZWFuKHZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnR290byBUaGVuIFNvbHZlOicgKyBCb29sZWFuVmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnR290b1RoZW5Tb2x2ZTonICsgQm9vbGVhblZhbHVlKTsKICAgIH0sCgogICAgQXV0b0ZsaXBTZXQocGF5bG9hZCkgewogICAgICBjb25zdCBbc2lnbmFsLCB2YWx1ZV0gPSBwYXlsb2FkLnNwbGl0KCc6Jyk7IC8vIOaLhuWIhuS/oeWPt+WSjOWAvAogICAgICBjb25zdCBCb29sZWFuVmFsdWUgPSBCb29sZWFuKHZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQXV0byBGbGlwOicgKyBCb29sZWFuVmFsdWUsICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnQXV0b0ZsaXA6JyArIEJvb2xlYW5WYWx1ZSk7CiAgICB9LAoKICAgIFdlc3RNaW51dGVzUGFzdE1lcmlkaWFuU2V0KHBheWxvYWQpIHsKICAgICAgY29uc3QgW3NpZ25hbCwgdmFsdWVdID0gcGF5bG9hZC5zcGxpdCgnOicpOyAvLyDmi4bliIbkv6Hlj7flkozlgLwKICAgICAgY29uc3QgV2VzdE1pbnV0ZXNQYXN0TWVyaWRpYW4gPSBwYXJzZUZsb2F0KHZhbHVlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnTWludXRlcyBQYXN0IE1lcmlkaWFuOicgKyBXZXN0TWludXRlc1Bhc3RNZXJpZGlhbiwgJ2luZm8nKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdXZXN0TWludXRlc1Bhc3RNZXJpZGlhbjonICsgV2VzdE1pbnV0ZXNQYXN0TWVyaWRpYW4pOwogICAgfSwKCiAgICBFYXN0TWludXRlc1Bhc3RNZXJpZGlhblNldChwYXlsb2FkKSB7CiAgICAgIGNvbnN0IFtzaWduYWwsIHZhbHVlXSA9IHBheWxvYWQuc3BsaXQoJzonKTsgLy8g5ouG5YiG5L+h5Y+35ZKM5YC8CiAgICAgIGNvbnN0IEVhc3RNaW51dGVzUGFzdE1lcmlkaWFuID0gcGFyc2VGbG9hdCh2YWx1ZSk7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ01pbnV0ZXMgUGFzdCBNZXJpZGlhbjonICsgRWFzdE1pbnV0ZXNQYXN0TWVyaWRpYW4sICdpbmZvJyk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnRWFzdE1pbnV0ZXNQYXN0TWVyaWRpYW46JyArIEVhc3RNaW51dGVzUGFzdE1lcmlkaWFuKTsKICAgIH0sCgogICAgYXN5bmMgcmVhZEJpbkZpbGUoZmlsZU5hbWUsIHJldHJ5Q291bnQgPSAxKSB7CiAgICAgIHdoaWxlICh0aGlzLmlzRG93bmxvYWRpbmdJbWFnZSkgewogICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7CiAgICAgICAgaWYgKCF0aGlzLmlzV2FpdGluZ0xvZ2dlZCkgewogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnVGhlIGltYWdlIGlzIGFscmVhZHkgYmVpbmcgcHJvY2Vzc2VkLiBQbGVhc2Ugd2FpdCBmb3IgdGhlIHByZXZpb3VzIHByb2Nlc3MgdG8gY29tcGxldGUuJywgJ3dhcm5pbmcnKTsKICAgICAgICAgIHRoaXMuaXNXYWl0aW5nTG9nZ2VkID0gdHJ1ZTsgLy8g56Gu5L+d5Y+q6K6w5b2V5LiA5qyh562J5b6F5L+h5oGvCiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nSW1hZ2VOYW1lID09PSBmaWxlTmFtZSkgewogICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1RoZSBpbWFnZSgnICsgZmlsZU5hbWUgKyAnKSBpcyBhbHJlYWR5IHByb2Nlc3NlZC4nLCAnaW5mbycpOwogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nSW1hZ2UgPSB0cnVlOwogICAgICB0aGlzLmlzV2FpdGluZ0xvZ2dlZCA9IGZhbHNlOyAvLyDph43nva7nrYnlvoXml6Xlv5fmoIflv5cKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FwdHVyZVRlc3RUaW1lIHwgUmVhZCBpbWFnZSgnICsgZmlsZU5hbWUgKyAnKSBkYXRhIHN0YXJ0LicsICdpbmZvJyk7CgogICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpOwogICAgICB0cnkgewogICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaWxlTmFtZSBpcyB2YWxpZAogICAgICAgIGlmICghZmlsZU5hbWUgfHwgdHlwZW9mIGZpbGVOYW1lICE9PSAnc3RyaW5nJykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpbGUgbmFtZSBwcm92aWRlZCcpOwogICAgICAgIH0KCiAgICAgICAgLy8gRmV0Y2ggd2l0aCBwcm9ncmVzcyB0cmFja2luZwogICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmlsZU5hbWUsIHsgY2FjaGU6ICduby1zdG9yZScgfSk7CiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2suIFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7CiAgICAgICAgfQoKICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJyk7CiAgICAgICAgaWYgKCFjb250ZW50TGVuZ3RoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnQtTGVuZ3RoIGhlYWRlciBpcyBtaXNzaW5nJyk7CiAgICAgICAgfQoKICAgICAgICBjb25zdCB0b3RhbCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKTsKICAgICAgICBpZiAoaXNOYU4odG90YWwpIHx8IHRvdGFsIDw9IDApIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb250ZW50LWxlbmd0aCB2YWx1ZScpOwogICAgICAgIH0KCiAgICAgICAgbGV0IGxvYWRlZCA9IDA7CgogICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7CiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHsKICAgICAgICAgIHN0YXJ0OiAoY29udHJvbGxlcikgPT4gewogICAgICAgICAgICBjb25zdCBwdXNoID0gKCkgPT4gewogICAgICAgICAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7CiAgICAgICAgICAgICAgICBpZiAoZG9uZSkgewogICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7CiAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoOwogICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IChsb2FkZWQgLyB0b3RhbCkgKiAxMDA7CiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChwZXJjZW50KSAlIDEwID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIC8vIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coYFByb2dyZXNzOiAke01hdGgucm91bmQocGVyY2VudCl9JWAsICdpbmZvJyk7CiAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FwdHVyZUltYWdlUHJvZ3Jlc3MoTWF0aC5yb3VuZChwZXJjZW50KSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLyB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKGDlvZPliY3ov5vluqY6ICR7TWF0aC5yb3VuZChwZXJjZW50KX0lYCwgJ2luZm8nKTsKICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7CiAgICAgICAgICAgICAgICBwdXNoKCk7CiAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gewogICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignU3RyZWFtIHJlYWRpbmcgZXJyb3I6JywgZXJyb3IpOwogICAgICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnU3RyZWFtIHJlYWRpbmcgZXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlLCAnZXJyb3InKTsKICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9OwogICAgICAgICAgICBwdXNoKCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHN0cmVhbSk7CiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG5ld1Jlc3BvbnNlLmJsb2IoKTsKCiAgICAgICAgLy8gRmlsZVJlYWRlciB3aXRoIHByb2dyZXNzIHRyYWNraW5nCiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7CiAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoKSA9PiB7CiAgICAgICAgICB0aGlzLkltYWdlQXJyYXlCdWZmZXIgPSBmaWxlUmVhZGVyLnJlc3VsdDsKCiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKTsKICAgICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpOwogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FwdHVyZVRlc3RUaW1lIHwgUmVhZCBpbWFnZSBkYXRhIGVuZDogJyArIGVsYXBzZWRUaW1lICsgJyBtcycsICdpbmZvJyk7CiAgICAgICAgICBpZiAoIXRoaXMuaXNQb2xhckF4aXNNb2RlKSB7CiAgICAgICAgICAgIHRoaXMuY2FsbFNob3dNZXNzYWdlQm94KGBSZWFkIGltYWdlIGRhdGEgZW5kOiAnJHtlbGFwc2VkVGltZX0nIG1zLmAsICdpbmZvJyk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmdJbWFnZU5hbWUgPSBmaWxlTmFtZTsKICAgICAgICAgIHRoaXMucHJvY2Vzc0ltYWdlKHRoaXMuSW1hZ2VBcnJheUJ1ZmZlcik7CiAgICAgICAgfTsKCiAgICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGaWxlUmVhZGVyIGVycm9yOicsIGVycm9yKTsKICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0ZpbGVSZWFkZXIgZXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlLCAnZXJyb3InKTsKICAgICAgICB9OwoKICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpOwogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZXJlIHdhcyBhIHByb2JsZW0gd2l0aCB0aGUgZmV0Y2ggb3BlcmF0aW9uOicsIGVycm9yKTsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdUaGVyZSB3YXMgYSBwcm9ibGVtIHdpdGggdGhlIGZldGNoIG9wZXJhdGlvbjogJyArIGVycm9yLm1lc3NhZ2UsICdlcnJvcicpOwoKICAgICAgICAvLyDkuIvovb3lpLHotKXvvIzph43or5UKICAgICAgICBpZiAocmV0cnlDb3VudCA+IDApIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXRyeWluZyBkb3dubG9hZC4uLicpOwogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnUmV0cnlpbmcgZG93bmxvYWQuLi4nLCAnd2FybmluZycpOwogICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nSW1hZ2UgPSBmYWxzZTsKICAgICAgICAgIHRoaXMudXBkYXRlQ2FwdHVyZUltYWdlUHJvZ3Jlc3MoMTAwKTsKICAgICAgICAgIGF3YWl0IHRoaXMucmVhZEJpbkZpbGUoZmlsZU5hbWUsIHJldHJ5Q291bnQgLSAxKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnTWF4IHJldHJpZXMgcmVhY2hlZC4gRG93bmxvYWQgZmFpbGVkLicsICdlcnJvcicpOwogICAgICAgIH0KICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmdJbWFnZSA9IGZhbHNlOyAvLyDnoa7kv53lnKjku7vkvZXmg4XlhrXkuIvpg73ph43nva7nirbmgIEKICAgICAgfQogICAgfSwKCgogICAgLy8gYXN5bmMgcmVhZEJpbkZpbGUoZmlsZU5hbWUsIHJldHJ5Q291bnQgPSAxKSB7CiAgICAvLyAgIHdoaWxlICh0aGlzLmlzRG93bmxvYWRpbmdJbWFnZSkgewogICAgLy8gICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7CiAgICAvLyAgICAgaWYgKCF0aGlzLmlzV2FpdGluZ0xvZ2dlZCkgewogICAgLy8gICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnVGhlIGltYWdlIGlzIGFscmVhZHkgYmVpbmcgcHJvY2Vzc2VkLiBQbGVhc2Ugd2FpdCBmb3IgdGhlIHByZXZpb3VzIHByb2Nlc3MgdG8gY29tcGxldGUuJywgJ3dhcm5pbmcnKTsKICAgIC8vICAgICAgIHRoaXMuaXNXYWl0aW5nTG9nZ2VkID0gdHJ1ZTsgLy8g56Gu5L+d5Y+q6K6w5b2V5LiA5qyh562J5b6F5L+h5oGvCiAgICAvLyAgICAgfQogICAgLy8gICB9CgogICAgLy8gICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nSW1hZ2VOYW1lID09PSBmaWxlTmFtZSkgewogICAgLy8gICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1RoZSBpbWFnZSgnICsgZmlsZU5hbWUgKyAnKSBpcyBhbHJlYWR5IHByb2Nlc3NlZC4nLCAnaW5mbycpOwogICAgLy8gICAgIHJldHVybjsKICAgIC8vICAgfQoKICAgIC8vICAgdGhpcy5pc0Rvd25sb2FkaW5nSW1hZ2UgPSB0cnVlOwogICAgLy8gICB0aGlzLmlzV2FpdGluZ0xvZ2dlZCA9IGZhbHNlOyAvLyDph43nva7nrYnlvoXml6Xlv5fmoIflv5cKICAgIC8vICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FwdHVyZVRlc3RUaW1lIHwgUmVhZCBpbWFnZSgnICsgZmlsZU5hbWUgKyAnKSBkYXRhIHN0YXJ0LicsICdpbmZvJyk7CgogICAgLy8gICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpOwogICAgLy8gICB0cnkgewogICAgLy8gICAgIC8vIEZldGNoIHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmcKICAgIC8vICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZpbGVOYW1lKTsKICAgIC8vICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAvLyAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpOwogICAgLy8gICAgIH0KCiAgICAvLyAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpOwogICAgLy8gICAgIGlmICghY29udGVudExlbmd0aCkgewogICAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50LUxlbmd0aCBoZWFkZXIgaXMgbWlzc2luZycpOwogICAgLy8gICAgIH0KCiAgICAvLyAgICAgY29uc3QgdG90YWwgPSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCk7CiAgICAvLyAgICAgbGV0IGxvYWRlZCA9IDA7CgogICAgLy8gICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7CiAgICAvLyAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHsKICAgIC8vICAgICAgIHN0YXJ0OiAoY29udHJvbGxlcikgPT4gewogICAgLy8gICAgICAgICBjb25zdCBwdXNoID0gKCkgPT4gewogICAgLy8gICAgICAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7CiAgICAvLyAgICAgICAgICAgICBpZiAoZG9uZSkgewogICAgLy8gICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7CiAgICAvLyAgICAgICAgICAgICAgIHJldHVybjsKICAgIC8vICAgICAgICAgICAgIH0KICAgIC8vICAgICAgICAgICAgIGxvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoOwogICAgLy8gICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IChsb2FkZWQgLyB0b3RhbCkgKiAxMDA7CiAgICAvLyAgICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChwZXJjZW50KSAlIDEwID09PSAwKSB7CiAgICAvLyAgICAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coYFByb2dyZXNzOiAke01hdGgucm91bmQocGVyY2VudCl9JWAsJ2luZm8nKTsKICAgIC8vICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYXB0dXJlSW1hZ2VQcm9ncmVzcyhNYXRoLnJvdW5kKHBlcmNlbnQpKTsKICAgIC8vICAgICAgICAgICAgIH0KICAgIC8vICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7CiAgICAvLyAgICAgICAgICAgICBwdXNoKCk7CiAgICAvLyAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gewogICAgLy8gICAgICAgICAgICAgY29uc29sZS5lcnJvcignU3RyZWFtIHJlYWRpbmcgZXJyb3I6JywgZXJyb3IpOwogICAgLy8gICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7CiAgICAvLyAgICAgICAgICAgfSk7CiAgICAvLyAgICAgICAgIH07CiAgICAvLyAgICAgICAgIHB1c2goKTsKICAgIC8vICAgICAgIH0KICAgIC8vICAgICB9KTsKCiAgICAvLyAgICAgY29uc3QgbmV3UmVzcG9uc2UgPSBuZXcgUmVzcG9uc2Uoc3RyZWFtKTsKICAgIC8vICAgICBjb25zdCBibG9iID0gYXdhaXQgbmV3UmVzcG9uc2UuYmxvYigpOwoKICAgIC8vICAgICAvLyBGaWxlUmVhZGVyIHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmcKICAgIC8vICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTsKICAgIC8vICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9ICgpID0+IHsKICAgIC8vICAgICAgIHRoaXMuSW1hZ2VBcnJheUJ1ZmZlciA9IGZpbGVSZWFkZXIucmVzdWx0OwoKICAgIC8vICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpOwogICAgLy8gICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBlbmRUaW1lLmdldFRpbWUoKSAtIHN0YXJ0VGltZS5nZXRUaW1lKCk7CiAgICAvLyAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYXB0dXJlVGVzdFRpbWUgfCBSZWFkIGltYWdlIGRhdGEgZW5kOiAnICsgZWxhcHNlZFRpbWUgKyAnIG1zJywgJ2luZm8nKTsKICAgIC8vICAgICAgIGlmICghdGhpcy5pc1BvbGFyQXhpc01vZGUpIHsKICAgIC8vICAgICAgICAgdGhpcy5jYWxsU2hvd01lc3NhZ2VCb3goYFJlYWQgaW1hZ2UgZGF0YSBlbmQ6ICcke2VsYXBzZWRUaW1lfScgbXMuYCwgJ2luZm8nKTsKICAgIC8vICAgICAgIH0KICAgIC8vICAgICAgIHRoaXMuaXNEb3dubG9hZGluZ0ltYWdlTmFtZSA9IGZpbGVOYW1lOwogICAgLy8gICAgICAgdGhpcy5wcm9jZXNzSW1hZ2UodGhpcy5JbWFnZUFycmF5QnVmZmVyKTsKICAgIC8vICAgICB9OwoKICAgIC8vICAgICBmaWxlUmVhZGVyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHsKICAgIC8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbGVSZWFkZXIgZXJyb3I6JywgZXJyb3IpOwogICAgLy8gICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnRmlsZVJlYWRlciBlcnJvcjonICsgZXJyb3IsICdlcnJvcicpOwogICAgLy8gICAgIH07CgogICAgLy8gICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7CiAgICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAvLyAgICAgY29uc29sZS5lcnJvcignVGhlcmUgd2FzIGEgcHJvYmxlbSB3aXRoIHRoZSBmZXRjaCBvcGVyYXRpb246JywgZXJyb3IpOwogICAgLy8gICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1RoZXJlIHdhcyBhIHByb2JsZW0gd2l0aCB0aGUgZmV0Y2ggb3BlcmF0aW9uOicgKyBlcnJvciwgJ2Vycm9yJyk7CgogICAgLy8gICAgIC8vIOS4i+i9veWksei0pe+8jOmHjeivlQogICAgLy8gICAgIGlmIChyZXRyeUNvdW50ID4gMCkgewogICAgLy8gICAgICAgY29uc29sZS5sb2coJ1JldHJ5aW5nIGRvd25sb2FkLi4uJyk7CiAgICAvLyAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdSZXRyeWluZyBkb3dubG9hZC4uLicsICd3YXJuaW5nJyk7CiAgICAvLyAgICAgICB0aGlzLmlzRG93bmxvYWRpbmdJbWFnZSA9IGZhbHNlOwogICAgLy8gICAgICAgdGhpcy51cGRhdGVDYXB0dXJlSW1hZ2VQcm9ncmVzcygxMDApOwogICAgLy8gICAgICAgYXdhaXQgdGhpcy5yZWFkQmluRmlsZShmaWxlTmFtZSwgcmV0cnlDb3VudCAtIDEpOwogICAgLy8gICAgIH0KICAgIC8vICAgfSBmaW5hbGx5IHsKICAgIC8vICAgICB0aGlzLmlzRG93bmxvYWRpbmdJbWFnZSA9IGZhbHNlOyAvLyDnoa7kv53lnKjku7vkvZXmg4XlhrXkuIvpg73ph43nva7nirbmgIEKICAgIC8vICAgfQogICAgLy8gfSwKCiAgICB1cGRhdGVDYXB0dXJlSW1hZ2VQcm9ncmVzcyhudW0pIHsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTaG93Q2FwdHVyZUltYWdlUHJvZ3Jlc3MnLCBudW0pOwogICAgfSwKCiAgICBzZXRJbWFnZVByb3BvcnRpb24odmFsdWUpIHsKICAgICAgdGhpcy5JbWFnZVByb3BvcnRpb24gPSB2YWx1ZTsKICAgIH0sCgogICAgYXN5bmMgcHJvY2Vzc0ltYWdlKGltZ0FycmF5LCBoaXN0b2dyYW1NaW4gPSAtMSwgaGlzdG9ncmFtTWF4ID0gLTEsIG9wdGlvbnMgPSB7fSkgewogICAgICBsZXQgeyBjYWxjdWxhdGVIaXN0b2dyYW0gPSB0cnVlIH0gPSBvcHRpb25zOwogICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSAwOwogICAgICB0aGlzLnByb2dyZXNzRGVzY3JpcHRpb24gPSB0aGlzLiRpMThuLmxvY2FsZSA9PT0gJ2NuJyA/ICflvIDlp4vlpITnkIblm77lg48uLi4nIDogJ1Byb2Nlc3NpbmcgaW1hZ2UuLi4nOwogICAgICBsZXQgbWF0ID0gbnVsbDsKICAgICAgbGV0IHRhcmdldEltZzggPSBudWxsOwogICAgICBsZXQgcmVzaXplSW1nID0gbnVsbDsKCiAgICAgIC8vIOS9v+eUqHNldFRpbWVvdXTlkoxQcm9taXNl5Yib5bu66Z2e6Zi75aGe5aSE55CGCiAgICAgIGNvbnN0IHByb2Nlc3NBc3luYyA9IChmbikgPT4gewogICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHsKICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbigpOwogICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7CiAgICAgICAgICB9LCAwKTsKICAgICAgICB9KTsKICAgICAgfTsKCiAgICAgIHRyeSB7CiAgICAgICAgaWYgKCEoaW1nQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiYgIUFycmF5QnVmZmVyLmlzVmlldyhpbWdBcnJheSkpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW5wdXQgbXVzdCBiZSBBcnJheUJ1ZmZlciBvciBUeXBlZEFycmF5Iik7CiAgICAgICAgfQogICAgICAgIGxldCB1aW50QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoaW1nQXJyYXkpOwoKICAgICAgICBpZiAodWludEFycmF5Lmxlbmd0aCAhPSBwYXJzZUludCh0aGlzLm1haW5DYW1lcmFTaXplWSkgKiBwYXJzZUludCh0aGlzLm1haW5DYW1lcmFTaXplWCkpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW1hZ2Ugc2l6ZSBtaXNtYXRjaCIpOwogICAgICAgIH0KICAgICAgICAvLyDliJvlu7pNYXTlr7nosaEKICAgICAgICBhd2FpdCBwcm9jZXNzQXN5bmMoKCkgPT4gewogICAgICAgICAgbWF0ID0gbmV3IGN2Lk1hdChwYXJzZUludCh0aGlzLm1haW5DYW1lcmFTaXplWSksIHBhcnNlSW50KHRoaXMubWFpbkNhbWVyYVNpemVYKSwgY3YuQ1ZfMTZVQzEpOwogICAgICAgICAgbWF0LmRhdGExNlUuc2V0KHVpbnRBcnJheSk7CiAgICAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSAxMDsKICAgICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9IHRoaXMuJGkxOG4ubG9jYWxlID09PSAnY24nID8gJ+WIm+W7uk1hdOWvueixoS4uLicgOiAnQ3JlYXRpbmcgTWF0IG9iamVjdC4uLic7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9KTsKCiAgICAgICAgLy8g55So5oi36Ieq5a6a5LmJ5Y+C5pWwCiAgICAgICAgbGV0IENGQSA9IHRoaXMuSW1hZ2VDRkE7CiAgICAgICAgbGV0IGlzQ29sb3JDYW1lcmEgPSBmYWxzZTsKICAgICAgICBsZXQgbW9kZSA9IDE7CiAgICAgICAgbGV0IGJsYWNrTGV2ZWwsIHdoaXRlTGV2ZWw7CgogICAgICAgIGlmIChoaXN0b2dyYW1NaW4gPT0gLTEgJiYgaGlzdG9ncmFtTWF4ID09IC0xKSB7CiAgICAgICAgICAvLyDojrflj5boh6rliqjmi4nkvLjlj4LmlbAKICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NBc3luYygoKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuR2V0QXV0b1N0cmV0Y2gobWF0LCBtb2RlKTsKICAgICAgICAgICAgdGhpcy5wcm9ncmVzc1ZhbHVlID0gMjA7CiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9IHRoaXMuJGkxOG4ubG9jYWxlID09PSAnY24nID8gJ+iOt+WPluiHquWKqOaLieS8uOWPguaVsC4uLicgOiAnR2V0dGluZyBhdXRvIHN0cmV0Y2ggcGFyYW1ldGVycy4uLic7CiAgICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgICB9KTsKCiAgICAgICAgICBjYWxjdWxhdGVIaXN0b2dyYW0gPSB0cnVlOwogICAgICAgICAgLy8g5LuO57uT5p6c5Lit5o+Q5Y+W5YC8CiAgICAgICAgICBibGFja0xldmVsID0gcmVzdWx0LmJsYWNrTGV2ZWw7CiAgICAgICAgICB3aGl0ZUxldmVsID0gcmVzdWx0LndoaXRlTGV2ZWw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJsYWNrTGV2ZWwgPSBoaXN0b2dyYW1NaW47ICAvLyDnjrDlnKjlj6/ku6XmraPluLjlt6XkvZwKICAgICAgICAgIHdoaXRlTGV2ZWwgPSBoaXN0b2dyYW1NYXg7ICAvLyDnjrDlnKjlj6/ku6XmraPluLjlt6XkvZwKICAgICAgICB9CgogICAgICAgIC8vIOagueaNrkNGQeiuvue9ruminOiJsui9rOaNouaooeW8jwogICAgICAgIGlmIChDRkEgPT09ICdHUicpIHsKICAgICAgICAgIGlzQ29sb3JDYW1lcmEgPSB0cnVlOwogICAgICAgIH0gZWxzZSBpZiAoQ0ZBID09PSAnR0InKSB7CiAgICAgICAgICBpc0NvbG9yQ2FtZXJhID0gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKENGQSA9PT0gJ0JHJykgewogICAgICAgICAgaXNDb2xvckNhbWVyYSA9IHRydWU7CiAgICAgICAgfSBlbHNlIGlmIChDRkEgPT09ICdSR0dCJykgewogICAgICAgICAgaXNDb2xvckNhbWVyYSA9IHRydWU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlzQ29sb3JDYW1lcmEgPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgY29uc29sZS5sb2coIuW9k+WJjeaLjeaRhOWPguaVsDppc0NvbG9yQ2FtZXJhOiIsIGlzQ29sb3JDYW1lcmEsICJDRkE6IiwgQ0ZBKTsKICAgICAgICAvLyDorqHnrpfnm7Tmlrnlm74KICAgICAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHByb2Nlc3NBc3luYygoKSA9PiB7CiAgICAgICAgICBjb25zdCByZXN1bHQgPSBpc0NvbG9yQ2FtZXJhCiAgICAgICAgICAgID8gdGhpcy5hbmFseXplSW1hZ2VTdGF0aXN0aWNzKG1hdCwgJ2JheWVyJywgQ0ZBLCB7IGNhbGN1bGF0ZUdhaW46IHRoaXMuY2FsY3VsYXRlR2FpbiwgY2FsY3VsYXRlSGlzdG9ncmFtOiBjYWxjdWxhdGVIaXN0b2dyYW0gfSkKICAgICAgICAgICAgOiB0aGlzLmFuYWx5emVJbWFnZVN0YXRpc3RpY3MobWF0LCAnZ3JheScsIHsgY2FsY3VsYXRlR2FpbjogdGhpcy5jYWxjdWxhdGVHYWluLCBjYWxjdWxhdGVIaXN0b2dyYW06IGNhbGN1bGF0ZUhpc3RvZ3JhbSB9KTsKCiAgICAgICAgICBpZiAodGhpcy5JbWFnZUdhaW5SICE9IDEgfHwgdGhpcy5JbWFnZUdhaW5CICE9IDEgfHwgdGhpcy5JbWFnZU9mZnNldCAhPSAwKSB7CiAgICAgICAgICAgIHJlc3VsdC5nYWluUiA9IHRoaXMuSW1hZ2VHYWluUjsKICAgICAgICAgICAgcmVzdWx0LmdhaW5CID0gdGhpcy5JbWFnZUdhaW5COwogICAgICAgICAgICByZXN1bHQub2Zmc2V0ID0gdGhpcy5JbWFnZU9mZnNldDsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSA0MDsKICAgICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9IHRoaXMuJGkxOG4ubG9jYWxlID09PSAnY24nID8gJ+iuoeeul+ebtOaWueWbvi4uLicgOiAnQ2FsY3VsYXRpbmcgaGlzdG9ncmFtLi4uJzsKICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfSk7CgogICAgICAgIGlmIChhbmFseXNpcy5oaXN0b2dyYW0pIHsKICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2hvd0hpc3RvZ3JhbScsIGFuYWx5c2lzLmhpc3RvZ3JhbSk7ICAvLyDmm7TmlrAg55u05pa55Zu+5pWw5o2uCiAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0NoYW5nZURpYWxQb3NpdGlvbicsIGJsYWNrTGV2ZWwsIHdoaXRlTGV2ZWwpOyAgLy8g5pu05paw55u05pa55Zu+55qE5pi+56S66L20CiAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0F1dG9IaXN0b2dyYW1OdW0nLCBibGFja0xldmVsLCB3aGl0ZUxldmVsKTsKICAgICAgICB9CgogICAgICAgIHRoaXMubGFzdEltYWdlUHJvY2Vzc1BhcmFtcyA9IHsKICAgICAgICAgIGJsYWNrTGV2ZWw6IGJsYWNrTGV2ZWwsCiAgICAgICAgICB3aGl0ZUxldmVsOiB3aGl0ZUxldmVsLAogICAgICAgICAgQ0ZBOiBDRkEsCiAgICAgICAgICBhbmFseXNpczogYW5hbHlzaXMsCiAgICAgICAgICBpc0NvbG9yQ2FtZXJhOiBpc0NvbG9yQ2FtZXJhLAogICAgICAgIH07CgogICAgICAgIC8vIOS9v+eUqOWinuebiuWSjOaLieS8uO+8jOW5tui9rOWMluS4ujjkvY3lm77lg48KICAgICAgICB0YXJnZXRJbWc4ID0gYXdhaXQgcHJvY2Vzc0FzeW5jKCgpID0+IHsKICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGlzQ29sb3JDYW1lcmEKICAgICAgICAgICAgPyB0aGlzLmFwcGx5U3RyZXRjaEFuZEdhaW4obWF0LCBhbmFseXNpcywgJ2JheWVyJywgQ0ZBLCBibGFja0xldmVsLCB3aGl0ZUxldmVsKQogICAgICAgICAgICA6IHRoaXMuYXBwbHlTdHJldGNoQW5kR2FpbihtYXQsIGFuYWx5c2lzLCAnZ3JheScsIENGQSwgYmxhY2tMZXZlbCwgd2hpdGVMZXZlbCk7CgogICAgICAgICAgLy8g6YeK5pS+bWF0CiAgICAgICAgICBpZiAobWF0KSB7CiAgICAgICAgICAgIG1hdC5kZWxldGUoKTsKICAgICAgICAgICAgbWF0ID0gbnVsbDsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSA2MDsKICAgICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9IHRoaXMuJGkxOG4ubG9jYWxlID09PSAnY24nID8gJ+agueaNruWPguaVsOWkhOeQhi4uLicgOiAnUHJvY2Vzc2luZyB3aXRoIHBhcmFtZXRlcnMuLi4nOwogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9KTsKCiAgICAgICAgLy8g5qC55o2u5qih5byP5aSE55CG5Zu+5YOPCiAgICAgICAgaWYgKHRoaXMuaXNQb2xhckF4aXNNb2RlKSB7CiAgICAgICAgICBhd2FpdCBwcm9jZXNzQXN5bmMoKCkgPT4gewogICAgICAgICAgICByZXNpemVJbWcgPSBuZXcgY3YuTWF0KCk7CiAgICAgICAgICAgIGN2LnJlc2l6ZSh0YXJnZXRJbWc4LCByZXNpemVJbWcsIG5ldyBjdi5TaXplKHRoaXMuQ2FudmFzV2lkdGgsIHRoaXMuQ2FudmFzSGVpZ2h0KSwgMCwgMCwgY3YuSU5URVJfTElORUFSKTsKCiAgICAgICAgICAgIGlmICh0YXJnZXRJbWc4KSB7CiAgICAgICAgICAgICAgdGFyZ2V0SW1nOC5kZWxldGUoKTsKICAgICAgICAgICAgICB0YXJnZXRJbWc4ID0gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSAwOwogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0pOwoKICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2hvd1NvbHZlSW1hZ2UnLCByZXNpemVJbWcpOwoKICAgICAgICAgIGlmIChyZXNpemVJbWcpIHsKICAgICAgICAgICAgcmVzaXplSW1nLmRlbGV0ZSgpOwogICAgICAgICAgICByZXNpemVJbWcgPSBudWxsOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyDovazmjaLkuLpJbWFnZURhdGHlr7nosaEKICAgICAgICAgIGNvbnN0IGNvbG9yRGF0YSA9IGF3YWl0IHByb2Nlc3NBc3luYygoKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW1hZ2VEYXRhKAogICAgICAgICAgICAgIG5ldyBVaW50OENsYW1wZWRBcnJheSh0YXJnZXRJbWc4LmRhdGEpLAogICAgICAgICAgICAgIHRhcmdldEltZzguY29scywKICAgICAgICAgICAgICB0YXJnZXRJbWc4LnJvd3MKICAgICAgICAgICAgKTsKCiAgICAgICAgICAgIGlmICh0YXJnZXRJbWc4KSB7CiAgICAgICAgICAgICAgdGFyZ2V0SW1nOC5kZWxldGUoKTsKICAgICAgICAgICAgICB0YXJnZXRJbWc4ID0gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocmVzaXplSW1nKSB7CiAgICAgICAgICAgICAgcmVzaXplSW1nLmRlbGV0ZSgpOwogICAgICAgICAgICAgIHJlc2l6ZUltZyA9IG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5wcm9ncmVzc1ZhbHVlID0gODA7CiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9IHRoaXMuJGkxOG4ubG9jYWxlID09PSAnY24nID8gJ+i9rOaNouS4ukltYWdlRGF0YeWvueixoS4uLicgOiAnQ29udmVydGluZyB0byBJbWFnZURhdGEgb2JqZWN0Li4uJzsKICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICB9KTsKCiAgICAgICAgICB0aGlzLmRyYXdJbWdEYXRhID0gdHJ1ZTsKCiAgICAgICAgICAvLyDorr7nva7nvJPlhrLnlLvluIMKICAgICAgICAgIGF3YWl0IHByb2Nlc3NBc3luYygoKSA9PiB7CiAgICAgICAgICAgIHRoaXMuYnVmZmVyQ2FudmFzLndpZHRoID0gY29sb3JEYXRhLndpZHRoOwogICAgICAgICAgICB0aGlzLmJ1ZmZlckNhbnZhcy5oZWlnaHQgPSBjb2xvckRhdGEuaGVpZ2h0OwogICAgICAgICAgICB0aGlzLmJ1ZmZlckN0eC5wdXRJbWFnZURhdGEoY29sb3JEYXRhLCAwLCAwKTsKICAgICAgICAgICAgdGhpcy5wcm9ncmVzc1ZhbHVlID0gOTA7CiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9IHRoaXMuJGkxOG4ubG9jYWxlID09PSAnY24nID8gJ+e7mOWItue8k+WGsueUu+W4g+WbvuWDjy4uLicgOiAnRHJhd2luZyBidWZmZXIgY2FudmFzIGltYWdlLi4uJzsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9KTsKCiAgICAgICAgICAvLyDnu5jliLbkuLvnlLvluIPlm77lg48KICAgICAgICAgIHRoaXMucHJvZ3Jlc3NWYWx1ZSA9IDEwMDsKICAgICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9IHRoaXMuJGkxOG4ubG9jYWxlID09PSAnY24nID8gJ+e7mOWItuS4u+eUu+W4g+WbvuWDjy4uLicgOiAnRHJhd2luZyBtYWluIGNhbnZhcyBpbWFnZS4uLic7CiAgICAgICAgICB0aGlzLmRyYXdJbWFnZURhdGEoKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcignUHJvY2VzcyBpbWFnZSBkYXRhIGVycm9yJywgJ3Byb2Nlc3NJbWFnZScsIGVycm9yKTsKICAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSAwOwogICAgICAgIHRoaXMucHJvZ3Jlc3NEZXNjcmlwdGlvbiA9ICcnOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRoaXMucHJvZ3Jlc3NWYWx1ZSA9IDA7CiAgICAgICAgLy8g56Gu5L+d5omA5pyJTWF05a+56LGh6YO96KKr6YeK5pS+CiAgICAgICAgaWYgKG1hdCkgewogICAgICAgICAgbWF0LmRlbGV0ZSgpOwogICAgICAgICAgbWF0ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgaWYgKHRhcmdldEltZzgpIHsKICAgICAgICAgIHRhcmdldEltZzguZGVsZXRlKCk7CiAgICAgICAgICB0YXJnZXRJbWc4ID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgaWYgKHJlc2l6ZUltZykgewogICAgICAgICAgcmVzaXplSW1nLmRlbGV0ZSgpOwogICAgICAgICAgcmVzaXplSW1nID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgLy8g5aSE55CG5ZCO5qOA5p+l5YaF5a2YCiAgICAgICAgdGhpcy5jaGVja01lbW9yeVVzYWdlKCk7CiAgICAgICAgLy8g5Zyo5aSE55CG5a6M5aSn6YeP5pWw5o2u5ZCO5omL5Yqo6K+35rGC5Z6D5Zy+5Zue5pS2CiAgICAgICAgaWYgKHdpbmRvdy5nYykgewogICAgICAgICAgdHJ5IHsgd2luZG93LmdjKCk7IH0gY2F0Y2ggKGUpIHsgfQogICAgICAgIH0KICAgICAgfQogICAgfSwKCgogICAgLyoqCiAgICAgKiDojrflj5boh6rliqjmi4nkvLjlj4LmlbDvvIzov5Tlm57pu5HoibLlkoznmb3oibLpmIjlgLwKICAgICAqIEBwYXJhbSB7Y3YuTWF0fSBpbWdNYXQg6L6T5YWl55qE5Zu+5YOPTWF05a+56LGhCiAgICAgKiBAcGFyYW0ge2ludH0gbW9kZSDmqKHlvI8KICAgICAqIEByZXR1cm5zIHtpbnTvvIxpbnR9IOm7keiJsuWSjOeZveiJsumYiOWAvAogICAgICovCiAgICBHZXRBdXRvU3RyZXRjaChpbWdNYXQsIG1vZGUpIHsKICAgICAgLy8g5LuF5pSv5oyBIE1hdCDnsbvlnovovpPlhaXvvIzlubblgYflrprkuLoxNuS9jeWbvuWDjwogICAgICAvLyDkvb/nlKggT3BlbkNWIOeahCBtZWFuU3RkRGV2IOWHveaVsOebtOaOpeiuoeeul+Wdh+WAvOWSjOagh+WHhuW3rgogICAgICBjb25zdCBtZWFucyA9IG5ldyBjdi5NYXQoKTsKICAgICAgY29uc3Qgc3RkRGV2cyA9IG5ldyBjdi5NYXQoKTsKCiAgICAgIC8vIOmrmOaViOiuoeeul+Wdh+WAvOWSjOagh+WHhuW3rgogICAgICBjdi5tZWFuU3RkRGV2KGltZ01hdCwgbWVhbnMsIHN0ZERldnMpOwoKICAgICAgLy8g6I635Y+W6K6h566X57uT5p6cCiAgICAgIGNvbnN0IG1lYW4gPSBtZWFucy5kb3VibGVBdCgwLCAwKTsKICAgICAgY29uc3Qgc3RkRGV2ID0gc3RkRGV2cy5kb3VibGVBdCgwLCAwKTsKCiAgICAgIC8vIOmHiuaUvuS4tOaXtiBNYXQg5a+56LGhCiAgICAgIG1lYW5zLmRlbGV0ZSgpOwogICAgICBzdGREZXZzLmRlbGV0ZSgpOwoKICAgICAgLy8g5qC55o2u5qih5byP6K6+572u5qCH5YeG5beu5YCN5pWwCiAgICAgIGxldCBhLCBiOwogICAgICBzd2l0Y2ggKG1vZGUpIHsKICAgICAgICBjYXNlIDA6IGEgPSAzOyBiID0gNTsgYnJlYWs7CiAgICAgICAgY2FzZSAxOiBhID0gMjsgYiA9IDU7IGJyZWFrOwogICAgICAgIGNhc2UgMjogYSA9IDM7IGIgPSA4OyBicmVhazsKICAgICAgICBkZWZhdWx0OiBhID0gMjsgYiA9IDg7CiAgICAgIH0KCiAgICAgIC8vIOWbuuWumuS4ujE25L2N5Zu+5YOP5aSE55CGCiAgICAgIGNvbnN0IG1heFZhbHVlID0gNjU1MzU7CgogICAgICAvLyDorqHnrpfpu5Hnmb3ngrkKICAgICAgbGV0IGJsYWNrTGV2ZWwgPSBNYXRoLnJvdW5kKE1hdGgubWF4KDAsIG1lYW4gLSBzdGREZXYgKiBhKSk7CiAgICAgIGxldCB3aGl0ZUxldmVsID0gTWF0aC5yb3VuZChNYXRoLm1pbihtYXhWYWx1ZSwgbWVhbiArIHN0ZERldiAqIGIpKTsKCiAgICAgIC8vIOehruS/nSBibGFja0xldmVsIDwgd2hpdGVMZXZlbAogICAgICBpZiAoYmxhY2tMZXZlbCA+PSB3aGl0ZUxldmVsKSB7CiAgICAgICAgYmxhY2tMZXZlbCA9IHdoaXRlTGV2ZWwgLSAxOwogICAgICB9CgogICAgICByZXR1cm4geyBibGFja0xldmVsLCB3aGl0ZUxldmVsIH07CiAgICB9LAoKICAgIC8qKgogICAgICog5YiG5p6QMTbkvY3lm77lg4/lubborqHnrpfnm7Tmlrnlm77lkoznmb3lubPooaHlop7nm4oKICAgICAqIEBwYXJhbSB7Y3YuTWF0fSBpbWcxNiAtIOi+k+WFpeeahDE25L2N5Zu+5YOPTWF05a+56LGhCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VUeXBlIC0g5Zu+5YOP57G75Z6LOiAnZ3JheSco54Gw5bqm5Zu+KSDmiJYgJ2JheWVyJyhCYXllcuagvOW8jykKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXllclBhdHRlcm4gLSBCYXllcuaooeW8j++8jOWmguaenGltYWdlVHlwZeS4uidiYXllcifliJnpnIDmj5Dkvps6ICdSR0dCJywgJ0dSJywgJ0dCJywgJ0JHJwogICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSDlj6/pgInlj4LmlbAKICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmJpbnMgLSDnm7Tmlrnlm77nrrHmlbDvvIzpu5jorqQyNTYKICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jYWxjdWxhdGVHYWluIC0g5piv5ZCm6K6h566X55m95bmz6KGh5aKe55uK5Y+C5pWw77yM6buY6K6kdHJ1ZQogICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnVzZVBlcmNlbnRpbGUgLSDmmK/lkKbkvb/nlKjnmb7liIbkvY3orqHnrpflop7nm4rvvIzpu5jorqR0cnVlCiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sb3dQZXJjZW50aWxlIC0g5LiL5oiq5pat55m+5YiG5L2N77yM6buY6K6kMQogICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGlnaFBlcmNlbnRpbGUgLSDkuIrmiKrmlq3nmb7liIbkvY3vvIzpu5jorqQ5OQogICAgICogQHJldHVybnMge09iamVjdH0g55u05pa55Zu+5pWw5o2u5ZKM5aKe55uK5Y+C5pWwCiAgICAgKi8KICAgIGFuYWx5emVJbWFnZVN0YXRpc3RpY3MoaW1nMTYsIGltYWdlVHlwZSwgYmF5ZXJQYXR0ZXJuID0gJ1JHR0InLCBvcHRpb25zID0ge30pIHsKICAgICAgLy8g6aaW5YWI5qOA5p+l6L6T5YWlTWF05piv5ZCm5pyJ5pWICiAgICAgIGlmICghaW1nMTYgfHwgaW1nMTYucm93cyA8PSAwIHx8IGltZzE2LmNvbHMgPD0gMCkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+aXoOaViOeahOWbvuWDj+aVsOaNricpOwogICAgICAgIHJldHVybiB7fTsKICAgICAgfQoKICAgICAgY29uc3QgeyBjYWxjdWxhdGVHYWluID0gdHJ1ZSwgY2FsY3VsYXRlSGlzdG9ncmFtID0gdHJ1ZSB9ID0gb3B0aW9uczsKICAgICAgY29uc3QgcmVzdWx0ID0ge307CgoKICAgICAgLy8g6K6+572u55u05pa55Zu+5Y+C5pWwCiAgICAgIGNvbnN0IHN0ZXAgPSA0OwoKICAgICAgLy8g5a6J5YWo6K6/6Zeu5Ye95pWwCiAgICAgIGNvbnN0IHNhZmVVc2hvcnRBdCA9IChtYXQsIHksIHgpID0+IHsKICAgICAgICBpZiAoeSA+PSAwICYmIHkgPCBtYXQucm93cyAmJiB4ID49IDAgJiYgeCA8IG1hdC5jb2xzKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gbWF0LnVzaG9ydEF0KHksIHgpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGDorr/pl67kvY3nva7plJnor686ICgke3l9LCR7eH0pYCk7CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKCiAgICAgIC8vIOWuieWFqOaOqeeggeiuvue9ru+8iHNldHRlcu+8ie+8mk9wZW5DVi5qcyDorr7nva7lg4/ntKDpnIDkvb/nlKggdWNoYXJQdHIg6L+U5Zue55qE6KeG5Zu+5YaN6LWL5YC8CiAgICAgIGNvbnN0IHNhZmVTZXRNYXNrID0gKG1hc2ssIHksIHgsIHZhbHVlKSA9PiB7CiAgICAgICAgaWYgKHkgPj0gMCAmJiB5IDwgbWFzay5yb3dzICYmIHggPj0gMCAmJiB4IDwgbWFzay5jb2xzKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBjb25zdCBwdHIgPSBtYXNrLnVjaGFyUHRyKHksIHgpOwogICAgICAgICAgICBpZiAocHRyICYmIHB0ci5sZW5ndGggPiAwKSBwdHJbMF0gPSB2YWx1ZTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihg6K6+572u5o6p56CB6ZSZ6K+vOiAoJHt5fSwke3h9KWApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKCiAgICAgIGlmIChpbWFnZVR5cGUgPT09ICdncmF5JykgewogICAgICAgIGlmIChjYWxjdWxhdGVIaXN0b2dyYW0pIHsKICAgICAgICAgIC8vIOiuoeeul+ebtOaWueWbvgogICAgICAgICAgY29uc3QgaGlzdERhdGEgPSBBcnJheSg2NTUzNikuZmlsbCgwKTsKICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1nMTYucm93czsgaSArPSBzdGVwKSB7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW1nMTYuY29sczsgaiArPSBzdGVwKSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGhpc3REYXRhW3NhZmVVc2hvcnRBdChpbWcxNiwgaSwgaildKys7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgLy8g5b+955Wl6ZSZ6K+v57un57ut5omn6KGMCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQuaGlzdG9ncmFtID0gaGlzdERhdGE7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGltYWdlVHlwZSA9PT0gJ2JheWVyJykgewogICAgICAgIC8vIOehruS/neWbvuWDj+Wkp+Wwj+i2s+Wkn+i/m+ihjEJheWVy5aSE55CGCiAgICAgICAgaWYgKGltZzE2LnJvd3MgPCAyIHx8IGltZzE2LmNvbHMgPCAyKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCflm77lg4/lsLrlr7jov4flsI/vvIzml6Dms5Xov5vooYxCYXllcuWkhOeQhicpOwogICAgICAgICAgcmV0dXJuIHt9OwogICAgICAgIH0KCiAgICAgICAgY29uc3Qgcm93cyA9IGltZzE2LnJvd3M7CiAgICAgICAgY29uc3QgY29scyA9IGltZzE2LmNvbHM7CgogICAgICAgIC8vIOWIm+W7uuaOqeeggSAtIOS9v+eUqOeogOeWj+mHh+agtwogICAgICAgIGNvbnN0IG1hc2tSID0gbmV3IGN2Lk1hdChyb3dzLCBjb2xzLCBjdi5DVl84VUMxLCBuZXcgY3YuU2NhbGFyKDApKTsKICAgICAgICBjb25zdCBtYXNrRyA9IG5ldyBjdi5NYXQocm93cywgY29scywgY3YuQ1ZfOFVDMSwgbmV3IGN2LlNjYWxhcigwKSk7CiAgICAgICAgY29uc3QgbWFza0IgPSBuZXcgY3YuTWF0KHJvd3MsIGNvbHMsIGN2LkNWXzhVQzEsIG5ldyBjdi5TY2FsYXIoMCkpOwoKICAgICAgICAvLyDnoa7lrprph4fmoLfmraXplb8gLSDlpKflm77lg4/ml7bph4fnlKjmm7TlpKfmraXplb8KICAgICAgICBjb25zdCBzYW1wbGVTdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcihNYXRoLm1pbihyb3dzLCBjb2xzKSAvIDIwMCkgKiAyKTsKCiAgICAgICAgLy8g56Gu5a6aQmF5ZXLmqKHlvI/kvY3nva4KICAgICAgICBsZXQgck9mZnNldHMsIGdPZmZzZXRzLCBiT2Zmc2V0czsKICAgICAgICBzd2l0Y2ggKGJheWVyUGF0dGVybikgewogICAgICAgICAgY2FzZSAnUkdHQic6CiAgICAgICAgICAgIHJPZmZzZXRzID0gW3sgeTogMCwgeDogMCB9XTsKICAgICAgICAgICAgZ09mZnNldHMgPSBbeyB5OiAwLCB4OiAxIH0sIHsgeTogMSwgeDogMCB9XTsKICAgICAgICAgICAgYk9mZnNldHMgPSBbeyB5OiAxLCB4OiAxIH1dOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgJ0dSJzoKICAgICAgICAgICAgZ09mZnNldHMgPSBbeyB5OiAwLCB4OiAwIH0sIHsgeTogMSwgeDogMSB9XTsKICAgICAgICAgICAgck9mZnNldHMgPSBbeyB5OiAwLCB4OiAxIH1dOwogICAgICAgICAgICBiT2Zmc2V0cyA9IFt7IHk6IDEsIHg6IDAgfV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAnR0InOgogICAgICAgICAgICBnT2Zmc2V0cyA9IFt7IHk6IDAsIHg6IDAgfSwgeyB5OiAxLCB4OiAxIH1dOwogICAgICAgICAgICBiT2Zmc2V0cyA9IFt7IHk6IDAsIHg6IDEgfV07CiAgICAgICAgICAgIHJPZmZzZXRzID0gW3sgeTogMSwgeDogMCB9XTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICdCRyc6CiAgICAgICAgICAgIGJPZmZzZXRzID0gW3sgeTogMCwgeDogMCB9XTsKICAgICAgICAgICAgZ09mZnNldHMgPSBbeyB5OiAwLCB4OiAxIH0sIHsgeTogMSwgeDogMCB9XTsKICAgICAgICAgICAgck9mZnNldHMgPSBbeyB5OiAxLCB4OiAxIH1dOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJPZmZzZXRzID0gW3sgeTogMCwgeDogMCB9XTsKICAgICAgICAgICAgZ09mZnNldHMgPSBbeyB5OiAwLCB4OiAxIH0sIHsgeTogMSwgeDogMCB9XTsKICAgICAgICAgICAgYk9mZnNldHMgPSBbeyB5OiAxLCB4OiAxIH1dOwogICAgICAgIH0KCiAgICAgICAgLy8g6YeH5qC35pWw5o2u55So5LqO5aKe55uK6K6h566XCiAgICAgICAgY29uc3QgclZhbHVlcyA9IFtdOwogICAgICAgIGNvbnN0IGdWYWx1ZXMgPSBbXTsKICAgICAgICBjb25zdCBiVmFsdWVzID0gW107CgogICAgICAgIC8vIOmHh+agt+iuvue9ruaOqeeggeWSjOaUtumbhumHh+agt+aVsOaNrgogICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcm93czsgeSArPSBzYW1wbGVTdGVwKSB7CiAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNvbHM7IHggKz0gc2FtcGxlU3RlcCkgewogICAgICAgICAgICAvLyDlpITnkIbnuqLoibLpgJrpgZMKICAgICAgICAgICAgZm9yIChjb25zdCBwb3Mgb2Ygck9mZnNldHMpIHsKICAgICAgICAgICAgICBjb25zdCBweSA9IHkgKyBwb3MueTsKICAgICAgICAgICAgICBjb25zdCBweCA9IHggKyBwb3MueDsKICAgICAgICAgICAgICBpZiAocHkgPCByb3dzICYmIHB4IDwgY29scyAmJiBweSA+PSAwICYmIHB4ID49IDApIHsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIHNhZmVTZXRNYXNrKG1hc2tSLCBweSwgcHgsIDI1NSk7CiAgICAgICAgICAgICAgICAgIGlmIChjYWxjdWxhdGVHYWluICYmIHkgJSAoc2FtcGxlU3RlcCAqIDIpID09PSAwICYmIHggJSAoc2FtcGxlU3RlcCAqIDIpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgclZhbHVlcy5wdXNoKHNhZmVVc2hvcnRBdChpbWcxNiwgcHksIHB4KSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUumAmumBk+mUmeivr++8migke3B5fSwke3B4fSlgLCBlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIOWkhOeQhue7v+iJsumAmumBkwogICAgICAgICAgICBmb3IgKGNvbnN0IHBvcyBvZiBnT2Zmc2V0cykgewogICAgICAgICAgICAgIGNvbnN0IHB5ID0geSArIHBvcy55OwogICAgICAgICAgICAgIGNvbnN0IHB4ID0geCArIHBvcy54OwogICAgICAgICAgICAgIGlmIChweSA8IHJvd3MgJiYgcHggPCBjb2xzICYmIHB5ID49IDAgJiYgcHggPj0gMCkgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgc2FmZVNldE1hc2sobWFza0csIHB5LCBweCwgMjU1KTsKICAgICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZUdhaW4gJiYgeSAlIChzYW1wbGVTdGVwICogMikgPT09IDAgJiYgeCAlIChzYW1wbGVTdGVwICogMikgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBnVmFsdWVzLnB1c2goc2FmZVVzaG9ydEF0KGltZzE2LCBweSwgcHgpKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBH6YCa6YGT6ZSZ6K+v77yaKCR7cHl9LCR7cHh9KWAsIGUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8g5aSE55CG6JOd6Imy6YCa6YGTCiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zIG9mIGJPZmZzZXRzKSB7CiAgICAgICAgICAgICAgY29uc3QgcHkgPSB5ICsgcG9zLnk7CiAgICAgICAgICAgICAgY29uc3QgcHggPSB4ICsgcG9zLng7CiAgICAgICAgICAgICAgaWYgKHB5IDwgcm93cyAmJiBweCA8IGNvbHMgJiYgcHkgPj0gMCAmJiBweCA+PSAwKSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICBzYWZlU2V0TWFzayhtYXNrQiwgcHksIHB4LCAyNTUpOwogICAgICAgICAgICAgICAgICBpZiAoY2FsY3VsYXRlR2FpbiAmJiB5ICUgKHNhbXBsZVN0ZXAgKiAyKSA9PT0gMCAmJiB4ICUgKHNhbXBsZVN0ZXAgKiAyKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJWYWx1ZXMucHVzaChzYWZlVXNob3J0QXQoaW1nMTYsIHB5LCBweCkpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYELpgJrpgZPplJnor6/vvJooJHtweX0sJHtweH0pYCwgZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoY2FsY3VsYXRlSGlzdG9ncmFtKSB7CiAgICAgICAgICAvLyDorqHnrpfkuInkuKrpgJrpgZPnmoTnm7Tmlrnlm74KICAgICAgICAgIGNvbnN0IGhpc3REYXRhUiA9IEFycmF5KDY1NTM2KS5maWxsKDApOwogICAgICAgICAgY29uc3QgaGlzdERhdGFHID0gQXJyYXkoNjU1MzYpLmZpbGwoMCk7CiAgICAgICAgICBjb25zdCBoaXN0RGF0YUIgPSBBcnJheSg2NTUzNikuZmlsbCgwKTsKCiAgICAgICAgICAvLyDnoa7kv53lronlhajorr/pl64KICAgICAgICAgIGNvbnN0IG1heFJvd3MgPSByb3dzIC0gMTsKICAgICAgICAgIGNvbnN0IG1heENvbHMgPSBjb2xzIC0gMTsKCiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFJvd3M7IGkgKz0gMikgewogICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heENvbHM7IGogKz0gMikgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBpZiAoYmF5ZXJQYXR0ZXJuID09PSAnUkdHQicpIHsKICAgICAgICAgICAgICAgICAgaGlzdERhdGFSW3NhZmVVc2hvcnRBdChpbWcxNiwgaSwgaildKys7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGcxID0gc2FmZVVzaG9ydEF0KGltZzE2LCBpICsgMSwgaik7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGcyID0gc2FmZVVzaG9ydEF0KGltZzE2LCBpLCBqICsgMSk7CiAgICAgICAgICAgICAgICAgIGhpc3REYXRhR1tNYXRoLmZsb29yKChnMSArIGcyKSAvIDIpXSsrOwogICAgICAgICAgICAgICAgICBoaXN0RGF0YUJbc2FmZVVzaG9ydEF0KGltZzE2LCBpICsgMSwgaiArIDEpXSsrOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXllclBhdHRlcm4gPT09ICdHUicpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgZzEgPSBzYWZlVXNob3J0QXQoaW1nMTYsIGksIGopOwogICAgICAgICAgICAgICAgICBjb25zdCBnMiA9IHNhZmVVc2hvcnRBdChpbWcxNiwgaSArIDEsIGogKyAxKTsKICAgICAgICAgICAgICAgICAgaGlzdERhdGFHW01hdGguZmxvb3IoKGcxICsgZzIpIC8gMildKys7CiAgICAgICAgICAgICAgICAgIGhpc3REYXRhUltzYWZlVXNob3J0QXQoaW1nMTYsIGkgKyAxLCBqKV0rKzsKICAgICAgICAgICAgICAgICAgaGlzdERhdGFCW3NhZmVVc2hvcnRBdChpbWcxNiwgaSwgaiArIDEpXSsrOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXllclBhdHRlcm4gPT09ICdHQicpIHsKICAgICAgICAgICAgICAgICAgY29uc3QgZzEgPSBzYWZlVXNob3J0QXQoaW1nMTYsIGksIGopOwogICAgICAgICAgICAgICAgICBjb25zdCBnMiA9IHNhZmVVc2hvcnRBdChpbWcxNiwgaSArIDEsIGogKyAxKTsKICAgICAgICAgICAgICAgICAgaGlzdERhdGFHW01hdGguZmxvb3IoKGcxICsgZzIpIC8gMildKys7CiAgICAgICAgICAgICAgICAgIGhpc3REYXRhQltzYWZlVXNob3J0QXQoaW1nMTYsIGkgKyAxLCBqKV0rKzsKICAgICAgICAgICAgICAgICAgaGlzdERhdGFSW3NhZmVVc2hvcnRBdChpbWcxNiwgaSwgaiArIDEpXSsrOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXllclBhdHRlcm4gPT09ICdCRycpIHsKICAgICAgICAgICAgICAgICAgaGlzdERhdGFCW3NhZmVVc2hvcnRBdChpbWcxNiwgaSwgaildKys7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGcxID0gc2FmZVVzaG9ydEF0KGltZzE2LCBpICsgMSwgaik7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGcyID0gc2FmZVVzaG9ydEF0KGltZzE2LCBpLCBqICsgMSk7CiAgICAgICAgICAgICAgICAgIGhpc3REYXRhR1tNYXRoLmZsb29yKChnMSArIGcyKSAvIDIpXSsrOwogICAgICAgICAgICAgICAgICBoaXN0RGF0YVJbc2FmZVVzaG9ydEF0KGltZzE2LCBpICsgMSwgaiArIDEpXSsrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOebtOaWueWbvuiuoeeul+mUmeivr++8migke2l9LCR7an0pYCwgZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXN1bHQuaGlzdG9ncmFtID0gW2hpc3REYXRhUiwgaGlzdERhdGFHLCBoaXN0RGF0YUJdOwogICAgICAgIH0KCiAgICAgICAgLy8g6K6h566X55m95bmz6KGh5aKe55uK5Y+C5pWwIC0g5L2/55So5b+r6YCf5Lit5L2N5pWw6L+R5Ly85rOVCiAgICAgICAgaWYgKGNhbGN1bGF0ZUdhaW4gJiYgclZhbHVlcy5sZW5ndGggPiAwICYmIGdWYWx1ZXMubGVuZ3RoID4gMCAmJiBiVmFsdWVzLmxlbmd0aCA+IDApIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIC8vIOW/q+mAn+iuoeeul+S4reS9jeaVsOiAjOmdnuaOkuW6j+WFqOmDqOaVsOe7hAogICAgICAgICAgICBjb25zdCByTWVhbiA9IHRoaXMudHJ1bmNhdGVkTWVhbihyVmFsdWVzKTsKICAgICAgICAgICAgY29uc3QgZ01lYW4gPSB0aGlzLnRydW5jYXRlZE1lYW4oZ1ZhbHVlcyk7CiAgICAgICAgICAgIGNvbnN0IGJNZWFuID0gdGhpcy50cnVuY2F0ZWRNZWFuKGJWYWx1ZXMpOwoKICAgICAgICAgICAgLy8g6K6h566X5aKe55uKCiAgICAgICAgICAgIGNvbnN0IGdhaW5SID0gTWF0aC5taW4oTWF0aC5tYXgoZ01lYW4gLyByTWVhbiwgMC4xKSwgMik7CiAgICAgICAgICAgIGNvbnN0IGdhaW5CID0gTWF0aC5taW4oTWF0aC5tYXgoZ01lYW4gLyBiTWVhbiwgMC4xKSwgMik7CgogICAgICAgICAgICByZXN1bHQud2hpdGVCYWxhbmNlID0gewogICAgICAgICAgICAgIGdhaW5SOiBnYWluUiwKICAgICAgICAgICAgICBnYWluQjogZ2FpbkIKICAgICAgICAgICAgfTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcigi55m95bmz6KGh5aKe55uK6K6h566X6ZSZ6K+vIiwgZSk7CiAgICAgICAgICAgIHJlc3VsdC53aGl0ZUJhbGFuY2UgPSB7IGdhaW5SOiAxLjAsIGdhaW5COiAxLjAgfTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIOmHiuaUvui1hOa6kAogICAgICAgIHRyeSB7CiAgICAgICAgICBtYXNrUi5kZWxldGUoKTsKICAgICAgICAgIG1hc2tHLmRlbGV0ZSgpOwogICAgICAgICAgbWFza0IuZGVsZXRlKCk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgY29uc29sZS5lcnJvcigi6YeK5pS+6LWE5rqQ6ZSZ6K+vIiwgZSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfSwKCiAgICAvKioKICAgICAqIOS9v+eUqOaIquaWreWdh+WAvOiuoeeulyAtIOWOu+mZpOS4iuS4i+S4gOWumuavlOS+i+eahOaegeWAvOWQjuiuoeeul+W5s+Wdh+WAvAogICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0g6L6T5YWl5pWw5o2u5pWw57uECiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXJQZXJjZW50IC0g5LiL5oiq5pat55m+5YiG5q+U77yM6buY6K6kNSUKICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlclBlcmNlbnQgLSDkuIrmiKrmlq3nmb7liIbmr5TvvIzpu5jorqQ1JQogICAgICogQHJldHVybnMge251bWJlcn0g5oiq5pat5Z2H5YC8CiAgICAgKi8KICAgIHRydW5jYXRlZE1lYW4oYXJyLCBsb3dlclBlcmNlbnQgPSA1LCB1cHBlclBlcmNlbnQgPSA1KSB7CiAgICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSByZXR1cm4gMDsKCiAgICAgIC8vIOi/h+a7pOaegeerr+m7keeCueWSjOi/h+mlseWSjOeCuQogICAgICBjb25zdCBmaWx0ZXJlZCA9IGFyci5maWx0ZXIodiA9PiB2ID4gMTAwICYmIHYgPCA2NTAwMCk7CiAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDApIHJldHVybiBhcnIubGVuZ3RoID4gMCA/IGFyclswXSA6IDA7CgogICAgICAvLyDlr7nkuo7nibnliKvlpKfnmoTmlbDnu4TvvIzph4fmoLflpITnkIYKICAgICAgbGV0IHdvcmtpbmdBcnJheSA9IGZpbHRlcmVkOwogICAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID4gMTAwMDApIHsKICAgICAgICB3b3JraW5nQXJyYXkgPSBbXTsKICAgICAgICBjb25zdCBzdGVwID0gTWF0aC5jZWlsKGZpbHRlcmVkLmxlbmd0aCAvIDUwMDApOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWQubGVuZ3RoOyBpICs9IHN0ZXApIHsKICAgICAgICAgIHdvcmtpbmdBcnJheS5wdXNoKGZpbHRlcmVkW2ldKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIC8vIOaOkuW6j+aVsOe7hAogICAgICB3b3JraW5nQXJyYXkuc29ydCgoYSwgYikgPT4gYSAtIGIpOwoKICAgICAgLy8g6K6h566X5oiq5pat54K5CiAgICAgIGNvbnN0IGxvd2VyQ3V0b2ZmID0gTWF0aC5mbG9vcih3b3JraW5nQXJyYXkubGVuZ3RoICogKGxvd2VyUGVyY2VudCAvIDEwMCkpOwogICAgICBjb25zdCB1cHBlckN1dG9mZiA9IE1hdGguZmxvb3Iod29ya2luZ0FycmF5Lmxlbmd0aCAqICgxIC0gdXBwZXJQZXJjZW50IC8gMTAwKSk7CgogICAgICAvLyDojrflj5bmiKrmlq3lkI7nmoTlrZDmlbDnu4QKICAgICAgY29uc3QgdHJ1bmNhdGVkID0gd29ya2luZ0FycmF5LnNsaWNlKGxvd2VyQ3V0b2ZmLCB1cHBlckN1dG9mZik7CgogICAgICAvLyDorqHnrpflubPlnYflgLwKICAgICAgaWYgKHRydW5jYXRlZC5sZW5ndGggPT09IDApIHJldHVybiB3b3JraW5nQXJyYXlbTWF0aC5mbG9vcih3b3JraW5nQXJyYXkubGVuZ3RoIC8gMildOwoKICAgICAgY29uc3Qgc3VtID0gdHJ1bmNhdGVkLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7CiAgICAgIHJldHVybiBzdW0gLyB0cnVuY2F0ZWQubGVuZ3RoOwogICAgfSwKICAgIC8qKgogICAgICog5b+r6YCf6K6h566X5Lit5L2N5pWwIC0g5L2/55So6ZqP5py66YCJ5oup566X5rOVCiAgICAgKi8KICAgIHF1aWNrTWVkaWFuKGFycikgewogICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7CiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMTAwKSB7CiAgICAgICAgLy8g5bCP5pWw57uE55u05o6l5o6S5bqPCiAgICAgICAgY29uc3Qgc29ydGVkQXJyID0gWy4uLmFycl0uc29ydCgoYSwgYikgPT4gYSAtIGIpOwogICAgICAgIHJldHVybiBzb3J0ZWRBcnJbTWF0aC5mbG9vcihzb3J0ZWRBcnIubGVuZ3RoIC8gMildOwogICAgICB9CgogICAgICAvLyDlpKfmlbDnu4Tpmo/mnLrph4fmoLcKICAgICAgY29uc3Qgc2FtcGxlcyA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7CiAgICAgICAgc2FtcGxlcy5wdXNoKGFycltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnIubGVuZ3RoKV0pOwogICAgICB9CiAgICAgIHNhbXBsZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpOwogICAgICByZXR1cm4gc2FtcGxlc1s1MF07IC8vIOi/lOWbnumHh+agt+eahOS4reS9jeaVsAogICAgfSwKCiAgICAvKioKICAgICAqIOW6lOeUqOeZveW5s+ihoeWSjOS6ruW6puaLieS8uO+8jOWwhjE25L2N5Zu+5YOP6L2s5o2i5Li6OOS9jeWbvuWDjwogICAgICogQHBhcmFtIHtjdi5NYXR9IGltZzE2IC0g6L6T5YWl55qEMTbkvY3lm77lg49NYXTlr7nosaEKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbmFseXNpcyAtIOS7jmFuYWx5emVJbWFnZVN0YXRpc3RpY3Pojrflj5bnmoTliIbmnpDnu5PmnpwKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVR5cGUgLSDlm77lg4/nsbvlnos6ICdncmF5JyjngbDluqblm74pIOaIliAnYmF5ZXInKOW9qeiJsuebuOacuikKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXllclBhdHRlcm4gLSBCYXllcuaooeW8j++8jOS7heW9k2ltYWdlVHlwZeS4uidiYXllcifml7bpnIDopoEKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJldGNoUGFyYW1zIC0g5omL5Yqo5oyH5a6a5ouJ5Ly45Y+C5pWw77yM5Y+v6YCJCiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyZXRjaFBhcmFtcy5ibGFja0xldmVsIC0g6buR54K55YC8IAogICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmV0Y2hQYXJhbXMud2hpdGVMZXZlbCAtIOeZveeCueWAvAogICAgICogQHJldHVybnMge2N2Lk1hdH0g5aSE55CG5ZCO55qEOOS9jVJHQkHlm77lg48KICAgICAqLwogICAgYXBwbHlTdHJldGNoQW5kR2FpbihpbWcxNiwgYW5hbHlzaXMsIGltYWdlVHlwZSwgYmF5ZXJQYXR0ZXJuID0gJ1JHR0InLCBibGFja0xldmVsLCB3aGl0ZUxldmVsKSB7CiAgICAgIC8vIOehruS/nem7keeCueWwj+S6jueZveeCuQogICAgICBpZiAoYmxhY2tMZXZlbCA+PSB3aGl0ZUxldmVsKSB7CiAgICAgICAgYmxhY2tMZXZlbCA9IHdoaXRlTGV2ZWwgLSAxOwogICAgICB9CgogICAgICAvLyDorqHnrpfovazmjaLmr5TkvovlkozlgY/np7sKICAgICAgY29uc3Qgc2NhbGUgPSAyNTUuMCAvICh3aGl0ZUxldmVsIC0gYmxhY2tMZXZlbCk7CiAgICAgIGNvbnN0IG9mZnNldCA9IC1ibGFja0xldmVsICogc2NhbGU7CgogICAgICBpZiAoaW1hZ2VUeXBlID09PSAnZ3JheScpIHsKICAgICAgICAvLyDljZXoibLnm7jmnLogLSDkuIDmraXovazmjaLliLA45L2NUkdCQQogICAgICAgIGNvbnN0IHJnYmFJbWcgPSBuZXcgY3YuTWF0KCk7CiAgICAgICAgY29uc3QgZ3JheTggPSBuZXcgY3YuTWF0KCk7CgogICAgICAgIGltZzE2LmNvbnZlcnRUbyhncmF5OCwgY3YuQ1ZfOFUsIHNjYWxlLCBvZmZzZXQpOwogICAgICAgIGN2LmN2dENvbG9yKGdyYXk4LCByZ2JhSW1nLCBjdi5DT0xPUl9HUkFZMlJHQkEpOwogICAgICAgIGdyYXk4LmRlbGV0ZSgpOwoKICAgICAgICByZXR1cm4gcmdiYUltZzsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyDlvanoibLnm7jmnLrlpITnkIYKICAgICAgICBsZXQgZ2FpblIgPSAxLjAsIGdhaW5CID0gMS4wOwogICAgICAgIGlmIChhbmFseXNpcyAmJiBhbmFseXNpcy53aGl0ZUJhbGFuY2UpIHsKICAgICAgICAgIGdhaW5SID0gYW5hbHlzaXMud2hpdGVCYWxhbmNlLmdhaW5SOwogICAgICAgICAgZ2FpbkIgPSBhbmFseXNpcy53aGl0ZUJhbGFuY2UuZ2FpbkI7CiAgICAgICAgfQoKICAgICAgICAvLyDkvb/nlKhMVVTkvJjljJbnmb3lubPooaHlkozmi4nkvLgKICAgICAgICAvLyAxLiDliJvlu7rkuInkuKpMVVTooagKICAgICAgICBjb25zdCB7IGx1dFIsIGx1dEcsIGx1dEIgfSA9IHRoaXMuZ2V0TFVUKGJsYWNrTGV2ZWwsIHdoaXRlTGV2ZWwsIGdhaW5SLCBnYWluQik7CgogICAgICAgIC8vIDMuIOWIm+W7ujjkvY3ovpPlh7rlm77lg48KICAgICAgICBjb25zdCBpbWc4ID0gbmV3IGN2Lk1hdChpbWcxNi5yb3dzLCBpbWcxNi5jb2xzLCBjdi5DVl84VUMxKTsKCiAgICAgICAgLy8gNC4g5L2/55SoTFVU5bqU55So55m95bmz6KGh5ZKM5ouJ5Ly4CiAgICAgICAgLy8g5Li66YG/5YWN5YOP57Sg6YGN5Y6G77yM5oiR5Lus5L2/55So5pu06auY5pWI55qE5pa55byPCiAgICAgICAgY29uc3Qgcm93cyA9IGltZzE2LnJvd3M7CiAgICAgICAgY29uc3QgY29scyA9IGltZzE2LmNvbHM7CiAgICAgICAgY29uc3QgZGF0YTggPSBpbWc4LmRhdGE7CgogICAgICAgIC8vIOehruWumkJheWVy5qih5byP55qE5L2N572uCiAgICAgICAgbGV0IHJPZmZzZXRzLCBnT2Zmc2V0cywgYk9mZnNldHM7CiAgICAgICAgc3dpdGNoIChiYXllclBhdHRlcm4pIHsKICAgICAgICAgIGNhc2UgJ1JHR0InOgogICAgICAgICAgICByT2Zmc2V0cyA9IFt7IHk6IDAsIHg6IDAgfV07CiAgICAgICAgICAgIGdPZmZzZXRzID0gW3sgeTogMCwgeDogMSB9LCB7IHk6IDEsIHg6IDAgfV07CiAgICAgICAgICAgIGJPZmZzZXRzID0gW3sgeTogMSwgeDogMSB9XTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICdHUic6CiAgICAgICAgICAgIGdPZmZzZXRzID0gW3sgeTogMCwgeDogMCB9LCB7IHk6IDEsIHg6IDEgfV07CiAgICAgICAgICAgIHJPZmZzZXRzID0gW3sgeTogMCwgeDogMSB9XTsKICAgICAgICAgICAgYk9mZnNldHMgPSBbeyB5OiAxLCB4OiAwIH1dOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgJ0dCJzoKICAgICAgICAgICAgZ09mZnNldHMgPSBbeyB5OiAwLCB4OiAwIH0sIHsgeTogMSwgeDogMSB9XTsKICAgICAgICAgICAgYk9mZnNldHMgPSBbeyB5OiAwLCB4OiAxIH1dOwogICAgICAgICAgICByT2Zmc2V0cyA9IFt7IHk6IDEsIHg6IDAgfV07CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAnQkcnOgogICAgICAgICAgICBiT2Zmc2V0cyA9IFt7IHk6IDAsIHg6IDAgfV07CiAgICAgICAgICAgIGdPZmZzZXRzID0gW3sgeTogMCwgeDogMSB9LCB7IHk6IDEsIHg6IDAgfV07CiAgICAgICAgICAgIHJPZmZzZXRzID0gW3sgeTogMSwgeDogMSB9XTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICByT2Zmc2V0cyA9IFt7IHk6IDAsIHg6IDAgfV07CiAgICAgICAgICAgIGdPZmZzZXRzID0gW3sgeTogMCwgeDogMSB9LCB7IHk6IDEsIHg6IDAgfV07CiAgICAgICAgICAgIGJPZmZzZXRzID0gW3sgeTogMSwgeDogMSB9XTsKICAgICAgICB9CgogICAgICAgIC8vIOS9v+eUqFR5cGVkQXJyYXnmlrnlvI/lpITnkIYgLSDmr5TpgJDkuKrlg4/ntKDlpITnkIbmm7Tlv6sKICAgICAgICBjb25zdCBkYXRhMTZVID0gaW1nMTYuZGF0YTE2VTsKCiAgICAgICAgLy8g5L2/55SoQmF5ZXLmjqnnoIHliJvlu7rovazmjaJMVVTvvIzmibnph4/lpITnkIYKICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJvd3M7IHkgKz0gMikgewogICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjb2xzOyB4ICs9IDIpIHsKICAgICAgICAgICAgLy8g5aSE55CGMngy5Z2XCiAgICAgICAgICAgIC8vIFLkvY3nva4KICAgICAgICAgICAgZm9yIChjb25zdCBwb3Mgb2Ygck9mZnNldHMpIHsKICAgICAgICAgICAgICBjb25zdCBpZHggPSAoeSArIHBvcy55KSAqIGNvbHMgKyAoeCArIHBvcy54KTsKICAgICAgICAgICAgICBpZiAoaWR4IDwgZGF0YTE2VS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIGRhdGE4W2lkeF0gPSBsdXRSW2RhdGExNlVbaWR4XV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBH5L2N572uCiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zIG9mIGdPZmZzZXRzKSB7CiAgICAgICAgICAgICAgY29uc3QgaWR4ID0gKHkgKyBwb3MueSkgKiBjb2xzICsgKHggKyBwb3MueCk7CiAgICAgICAgICAgICAgaWYgKGlkeCA8IGRhdGExNlUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBkYXRhOFtpZHhdID0gbHV0R1tkYXRhMTZVW2lkeF1dOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gQuS9jee9rgogICAgICAgICAgICBmb3IgKGNvbnN0IHBvcyBvZiBiT2Zmc2V0cykgewogICAgICAgICAgICAgIGNvbnN0IGlkeCA9ICh5ICsgcG9zLnkpICogY29scyArICh4ICsgcG9zLngpOwogICAgICAgICAgICAgIGlmIChpZHggPCBkYXRhMTZVLmxlbmd0aCkgewogICAgICAgICAgICAgICAgZGF0YThbaWR4XSA9IGx1dEJbZGF0YTE2VVtpZHhdXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIDUuIOWwhjjkvY3ljZXpgJrpgZPovazkuLpSR0JBCiAgICAgICAgY29uc3QgcmdiYUltZyA9IG5ldyBjdi5NYXQoKTsKICAgICAgICBsZXQgY3Ztb2RlOwogICAgICAgIHN3aXRjaCAoYmF5ZXJQYXR0ZXJuKSB7CiAgICAgICAgICBjYXNlICdSR0dCJzogY3Ztb2RlID0gY3YuQ09MT1JfQmF5ZXJSRzJSR0JBOyBicmVhazsKICAgICAgICAgIGNhc2UgJ0dSJzogY3Ztb2RlID0gY3YuQ09MT1JfQmF5ZXJHUjJSR0JBOyBicmVhazsKICAgICAgICAgIGNhc2UgJ0dCJzogY3Ztb2RlID0gY3YuQ09MT1JfQmF5ZXJHQjJSR0JBOyBicmVhazsKICAgICAgICAgIGNhc2UgJ0JHJzogY3Ztb2RlID0gY3YuQ09MT1JfQmF5ZXJCRzJSR0JBOyBicmVhazsKICAgICAgICAgIGRlZmF1bHQ6IGN2bW9kZSA9IGN2LkNPTE9SX0dSQVkyUkdCQTsKICAgICAgICB9CgogICAgICAgIGN2LmN2dENvbG9yKGltZzgsIHJnYmFJbWcsIGN2bW9kZSk7CiAgICAgICAgaW1nOC5kZWxldGUoKTsKCiAgICAgICAgcmV0dXJuIHJnYmFJbWc7CiAgICAgIH0KICAgIH0sCiAgICAvKioKICAgICAqIOiOt+WPluaIluiuoeeul0xVVOihqAogICAgICogQHBhcmFtIHtudW1iZXJ9IGJsYWNrTGV2ZWwgLSDpu5HngrnlgLwKICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aGl0ZUxldmVsIC0g55m954K55YC8CiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FpblIgLSDnuqLoibLlop7nm4oKICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnYWluQiAtIOiTneiJsuWinuebigogICAgICogQHJldHVybnMge09iamVjdH0g5YyF5ZCrTFVU6KGo55qET2JqZWN0CiAgICAgKi8KICAgIGdldExVVChibGFja0xldmVsLCB3aGl0ZUxldmVsLCBnYWluUiwgZ2FpbkIpIHsKICAgICAgLy8g5Yib5bu65b2T5YmN5Y+C5pWw55qE5b+r54WnCiAgICAgIGNvbnN0IGN1cnJlbnRQYXJhbXMgPSBgJHtibGFja0xldmVsfV8ke3doaXRlTGV2ZWx9XyR7Z2FpblJ9XyR7Z2FpbkJ9YDsKCiAgICAgIC8vIOWmguaenOWPguaVsOacquWPmOWMlu+8jOebtOaOpei/lOWbnue8k+WtmOeahExVVOihqAogICAgICBpZiAodGhpcy5sdXRDYWNoZS5sYXN0UGFyYW1zID09PSBjdXJyZW50UGFyYW1zICYmCiAgICAgICAgdGhpcy5sdXRDYWNoZS5sdXRSICYmIHRoaXMubHV0Q2FjaGUubHV0RyAmJiB0aGlzLmx1dENhY2hlLmx1dEIpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgbHV0UjogdGhpcy5sdXRDYWNoZS5sdXRSLAogICAgICAgICAgbHV0RzogdGhpcy5sdXRDYWNoZS5sdXRHLAogICAgICAgICAgbHV0QjogdGhpcy5sdXRDYWNoZS5sdXRCCiAgICAgICAgfTsKICAgICAgfQoKICAgICAgLy8g5Y+C5pWw5Y+Y5YyW77yM6ZyA6KaB6YeN5paw6K6h566XTFVU6KGoCiAgICAgIGNvbnNvbGUubG9nKCfph43mlrDorqHnrpdMVVTooagnKTsKCiAgICAgIC8vIOiuoeeul+i9rOaNouavlOS+iwogICAgICBjb25zdCBzY2FsZSA9IDI1NS4wIC8gKHdoaXRlTGV2ZWwgLSBibGFja0xldmVsKTsKCiAgICAgIC8vIOWIm+W7ukxVVOihqAogICAgICBjb25zdCBsdXRSID0gdGhpcy5sdXRDYWNoZS5sdXRSIHx8IG5ldyBVaW50OEFycmF5KDY1NTM2KTsKICAgICAgY29uc3QgbHV0RyA9IHRoaXMubHV0Q2FjaGUubHV0RyB8fCBuZXcgVWludDhBcnJheSg2NTUzNik7CiAgICAgIGNvbnN0IGx1dEIgPSB0aGlzLmx1dENhY2hlLmx1dEIgfHwgbmV3IFVpbnQ4QXJyYXkoNjU1MzYpOwoKICAgICAgLy8g6K6h566XTFVU6KGoCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjU1MzY7IGkrKykgewogICAgICAgIGx1dFJbaV0gPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIE1hdGgucm91bmQoKGkgKiBnYWluUiAtIGJsYWNrTGV2ZWwpICogc2NhbGUpKSk7CiAgICAgICAgbHV0R1tpXSA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoaSAtIGJsYWNrTGV2ZWwpICogc2NhbGUpKSk7CiAgICAgICAgbHV0QltpXSA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoaSAqIGdhaW5CIC0gYmxhY2tMZXZlbCkgKiBzY2FsZSkpKTsKICAgICAgfQoKICAgICAgLy8g5pu05paw57yT5a2YCiAgICAgIHRoaXMubHV0Q2FjaGUubGFzdFBhcmFtcyA9IGN1cnJlbnRQYXJhbXM7CiAgICAgIHRoaXMubHV0Q2FjaGUubHV0UiA9IGx1dFI7CiAgICAgIHRoaXMubHV0Q2FjaGUubHV0RyA9IGx1dEc7CiAgICAgIHRoaXMubHV0Q2FjaGUubHV0QiA9IGx1dEI7CgogICAgICByZXR1cm4geyBsdXRSLCBsdXRHLCBsdXRCIH07CiAgICB9LAogICAgLy8gY2hlY2tJbWFnZURhdGEoaW1nKSB7CiAgICAvLyAgIC8vIOajgOafpeaYr+WQpuS4uiBjdi5NYXQg57G75Z6LCiAgICAvLyAgIGlmICghKGltZyBpbnN0YW5jZW9mIGN2Lk1hdCkpIHsKICAgIC8vICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdUaGUgaW1hZ2UgaXMgbm90IGEgdmFsaWQgY3YuTWF0IG9iamVjdC4nLCAnZXJyb3InKTsKICAgIC8vICAgICByZXR1cm4gZmFsc2U7CiAgICAvLyAgIH0KCiAgICAvLyAgIC8vIOajgOafpeWbvuWDj+aYr+WQpuS4uuepugogICAgLy8gICBpZiAoaW1nLmVtcHR5KCkpIHsKICAgIC8vICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdUaGUgaW1hZ2UgaXMgZW1wdHkuJywgJ2Vycm9yJyk7CiAgICAvLyAgICAgcmV0dXJuIGZhbHNlOwogICAgLy8gICB9CgogICAgLy8gICAvLyDmo4Dmn6Xlm77lg4/mt7HluqbmmK/lkKbkuLogOCDkvY3miJYgMTYg5L2NCiAgICAvLyAgIGNvbnN0IGRlcHRoID0gaW1nLnR5cGUoKSAmIGN2LkNWX01BVF9ERVBUSF9NQVNLOwogICAgLy8gICBpZiAoZGVwdGggIT09IGN2LkNWXzhVICYmIGRlcHRoICE9PSBjdi5DVl8xNlUpIHsKICAgIC8vICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdUaGUgaW1hZ2UgZGVwdGggaXMgbm90IDgtYml0IG9yIDE2LWJpdC4nLCAnZXJyb3InKTsKICAgIC8vICAgICByZXR1cm4gZmFsc2U7CiAgICAvLyAgIH0KCiAgICAvLyAgIC8vIOajgOafpeWbvuWDj+WwuuWvuOaYr+WQpuWQiOeQhgogICAgLy8gICBpZiAoaW1nLnJvd3MgPD0gMCB8fCBpbWcuY29scyA8PSAwKSB7CiAgICAvLyAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnVGhlIGltYWdlIGRpbWVuc2lvbnMgYXJlIG5vdCB2YWxpZC4nLCAnZXJyb3InKTsKICAgIC8vICAgICByZXR1cm4gZmFsc2U7CiAgICAvLyAgIH0KCiAgICAvLyAgIC8vIOajgOafpeWbvuWDj+aVsOaNruaYr+WQpui2heWHuuiMg+WbtOaIluWFqOS4ujAKICAgIC8vICAgY29uc3QgZGF0YSA9IGltZy5kYXRhOwogICAgLy8gICBsZXQgaXNBbGxaZXJvID0gdHJ1ZTsKICAgIC8vICAgY29uc3QgbWF4VmFsdWUgPSBkZXB0aCA9PT0gY3YuQ1ZfOFUgPyAyNTUgOiA2NTUzNTsKCiAgICAvLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykgewogICAgLy8gICAgIGlmIChkYXRhW2ldIDwgMCB8fCBkYXRhW2ldID4gbWF4VmFsdWUpIHsKICAgIC8vICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1RoZSBpbWFnZSBkYXRhIGNvbnRhaW5zIG91dC1vZi1yYW5nZSB2YWx1ZXMuJywgJ2Vycm9yJyk7CiAgICAvLyAgICAgICByZXR1cm4gZmFsc2U7CiAgICAvLyAgICAgfQogICAgLy8gICAgIGlmIChkYXRhW2ldICE9PSAwKSB7CiAgICAvLyAgICAgICBpc0FsbFplcm8gPSBmYWxzZTsKICAgIC8vICAgICB9CiAgICAvLyAgIH0KCiAgICAvLyAgIGlmIChpc0FsbFplcm8pIHsKICAgIC8vICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdUaGUgaW1hZ2UgZGF0YSBpcyBhbGwgemVyby4nLCAnZXJyb3InKTsKICAgIC8vICAgICByZXR1cm4gZmFsc2U7CiAgICAvLyAgIH0KICAgIC8vICAgcmV0dXJuIHRydWU7CiAgICAvLyB9LAoKCiAgICAvLyBwcm9jZXNzSW1hZ2UoaW1nQXJyYXkpIHsKICAgIC8vICAgdGhpcy5wcm9ncmVzc1ZhbHVlID0gMDsKICAgIC8vICAgdHJ5IHsKICAgIC8vICAgICBpZiAoIShpbWdBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KGltZ0FycmF5KSkgewogICAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnB1dCBtdXN0IGJlIEFycmF5QnVmZmVyIG9yIFR5cGVkQXJyYXkiKTsKICAgIC8vICAgICB9CiAgICAvLyAgICAgY29uc3QgdG90YWxTdGFydFRpbWUgPSBuZXcgRGF0ZSgpOyAvLyDmgLvlvIDlp4vml7bpl7QKCiAgICAvLyAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FwdHVyZVRlc3RUaW1lIHwgUHJvY2VzcyBpbWFnZSBkYXRhIHN0YXJ0LicsICdpbmZvJyk7CiAgICAvLyAgICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKTsKICAgIC8vICAgICBsZXQgaW1nX2JpdCA9IC0xOwogICAgLy8gICAgIGxldCB1aW50QXJyYXk7CiAgICAvLyAgICAgaWYgKGltZ0FycmF5LmJ5dGVMZW5ndGggPT09IHRoaXMubWFpbkNhbWVyYVNpemVYICogdGhpcy5tYWluQ2FtZXJhU2l6ZVkgKiAyICl7CiAgICAvLyAgICAgICB1aW50QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoaW1nQXJyYXkpOwogICAgLy8gICAgICAgaW1nX2JpdCA9IDE2OwogICAgLy8gICAgIH1lbHNlIGlmKGltZ0FycmF5LmJ5dGVMZW5ndGggPT09IHRoaXMubWFpbkNhbWVyYVNpemVYICogdGhpcy5tYWluQ2FtZXJhU2l6ZVkpewogICAgLy8gICAgICAgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW1nQXJyYXkpOwogICAgLy8gICAgICAgaW1nX2JpdCA9IDg7CiAgICAvLyAgICAgfWVsc2V7CiAgICAvLyAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKGBJbWFnZSBkYXRhIGlzIHVuZGVyZmluZCBiaXRgLCAnZXJyb3InKTsKICAgIC8vICAgICAgIHJldHVybjsKICAgIC8vICAgICB9CgogICAgLy8gICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coYEltYWdlIGRhdGEgZGV0ZWN0ZWQgYXMgJHtpbWdfYml0fS1iaXQuYCwgJ2luZm8nKTsKCgoKICAgIC8vICAgICAvLyDorr7nva7nlLvluIPlrr3pq5jluLjph48KICAgIC8vICAgICBjb25zdCBjYW52YXNXaWR0aCA9IHBhcnNlSW50KHRoaXMubWFpbkNhbWVyYVNpemVYKTsKICAgIC8vICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBwYXJzZUludCh0aGlzLm1haW5DYW1lcmFTaXplWSk7CgogICAgLy8gICAgIC8vIOiOt+WPluWOn+Wni+eUu+W4g+WSjOS/ruaUueWQjueahOeUu+W4g+S7peWPiuWvueW6lOS4iuS4i+aWhwogICAgLy8gICAgIGNvbnN0IG1vZGlmaWVkQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW5DYW1lcmEtY2FudmFzJyk7CiAgICAvLyAgICAgY29uc3QgbW9kaWZpZWRDdHggPSBtb2RpZmllZENhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwoKCgogICAgLy8gICAgIG1vZGlmaWVkQ2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7CiAgICAvLyAgICAgbW9kaWZpZWRDYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0OwoKICAgIC8vICAgICBsZXQgbWF0OwogICAgLy8gICAgIGlmIChpbWdfYml0ID09PSAxNil7CiAgICAvLyAgICAgICBtYXQgPSBuZXcgY3YuTWF0KGNhbnZhc0hlaWdodCwgY2FudmFzV2lkdGgsIGN2LkNWXzE2VUMxKTsKICAgIC8vICAgICAgIG1hdC5kYXRhMTZVLnNldCh1aW50QXJyYXkpOwogICAgLy8gICAgIH1lbHNlewogICAgLy8gICAgICAgbWF0ID0gbmV3IGN2Lk1hdChjYW52YXNIZWlnaHQsIGNhbnZhc1dpZHRoLCBjdi5DVl84VUMxKTsKICAgIC8vICAgICAgIG1hdC5kYXRhLnNldCh1aW50QXJyYXkpOwogICAgLy8gICAgIH0KICAgIC8vICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSAxMDsKCiAgICAvLyAgICAgY29uc3QgbWF0RW5kVGltZSA9IG5ldyBEYXRlKCk7IC8vIG1hdCDnu5PmnZ/ml7bpl7QKICAgIC8vICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYXB0dXJlVGVzdFRpbWUgfCBNYXQgY3JlYXRpb24gdGltZTogJyArIChtYXRFbmRUaW1lLmdldFRpbWUoKSAtIHN0YXJ0VGltZS5nZXRUaW1lKCkpICsgJyBtcycsICdpbmZvJyk7CgogICAgLy8gICAgIC8vIOeUqOaIt+iHquWumuS5ieWPguaVsAogICAgLy8gICAgIGxldCBnYWluUiA9IHRoaXMuSW1hZ2VHYWluUjsKICAgIC8vICAgICBsZXQgZ2FpbkIgPSB0aGlzLkltYWdlR2FpbkI7CiAgICAvLyAgICAgbGV0IG9mZnNldCA9IHRoaXMuSW1hZ2VPZmZzZXQ7CiAgICAvLyAgICAgbGV0IENGQSA9IHRoaXMuSW1hZ2VDRkE7CiAgICAvLyAgICAgbGV0IG1vZGUgPSAxOwoKICAgIC8vICAgICAvLyDlj4LmlbAKICAgIC8vICAgICBsZXQgQiA9IDA7CiAgICAvLyAgICAgbGV0IFcgPSA2NTUzNTsKICAgIC8vICAgICBsZXQgY3Ztb2RlID0gMDsKCiAgICAvLyAgICAgY29uc3QgeyBibGFja0xldmVsLCB3aGl0ZUxldmVsIH0gPSB0aGlzLkdldEF1dG9TdHJldGNoKHVpbnRBcnJheSwgbW9kZSwgaW1nX2JpdCk7CiAgICAvLyAgICAgQiA9IGJsYWNrTGV2ZWw7CiAgICAvLyAgICAgVyA9IHdoaXRlTGV2ZWw7CiAgICAvLyAgICAgdGhpcy5wcm9ncmVzc1ZhbHVlID0gMzA7CiAgICAvLyAgICAgY29uc3QgR2V0QXV0b1N0cmV0Y2hFbmRUaW1lID0gbmV3IERhdGUoKTsgLy8gR2V0QXV0b1N0cmV0Y2gg57uT5p2f5pe26Ze0CiAgICAvLyAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FwdHVyZVRlc3RUaW1lIHwgR2V0QXV0b1N0cmV0Y2ggdGltZTogJyArIChHZXRBdXRvU3RyZXRjaEVuZFRpbWUuZ2V0VGltZSgpIC0gbWF0RW5kVGltZS5nZXRUaW1lKCkpICsgJyBtcycsICdpbmZvJyk7CgogICAgLy8gICAgIC8vIOagueaNrkNGQeiuvue9ruminOiJsui9rOaNouaooeW8jwogICAgLy8gICAgIGlmIChDRkEgPT09ICdHUicpIHsKICAgIC8vICAgICAgIGN2bW9kZSA9IGN2LkNPTE9SX0JheWVyR1IyUkdCQTsKICAgIC8vICAgICB9IGVsc2UgaWYgKENGQSA9PT0gJ0dCJykgewogICAgLy8gICAgICAgY3Ztb2RlID0gY3YuQ09MT1JfQmF5ZXJHQjJSR0JBOwogICAgLy8gICAgIH0gZWxzZSBpZiAoQ0ZBID09PSAnQkcnKSB7CiAgICAvLyAgICAgICBjdm1vZGUgPSBjdi5DT0xPUl9CYXllckJHMlJHQkE7CiAgICAvLyAgICAgfSBlbHNlIGlmIChDRkEgPT09ICdSR0dCJykgewogICAgLy8gICAgICAgY3Ztb2RlID0gY3YuQ09MT1JfQmF5ZXJSRzJSR0JBOwogICAgLy8gICAgIH1lbHNlewogICAgLy8gICAgICAgY3Ztb2RlID0gY3YuQ09MT1JfR1JBWTJSR0JBCiAgICAvLyAgICAgfQoKICAgIC8vICAgICAvLyDlr7nnm67moIflm77lg4/ov5vooYzpopzoibLovazmjaIKICAgIC8vICAgICBsZXQgZHN0ID0gbmV3IGN2Lk1hdCgpOwoKICAgIC8vICAgICB0cnkgewogICAgLy8gICAgICAgY3YuY3Z0Q29sb3IobWF0LCBkc3QsIGN2bW9kZSk7CiAgICAvLyAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgIC8vICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoJ2N2dENvbG9yIOWHuumUmScsICdjdnRDb2xvcicsIGVycm9yKTsKICAgIC8vICAgICAgIG1hdC5kZWxldGUoKTsKICAgIC8vICAgICAgIHJldHVybjsKICAgIC8vICAgICB9CgogICAgLy8gICAgIHRoaXMucHJvZ3Jlc3NWYWx1ZSA9IDUwOwoKICAgIC8vICAgICBjb25zdCBjdnRDb2xvckVuZFRpbWUgPSBuZXcgRGF0ZSgpOyAvLyBjdnRDb2xvciDnu5PmnZ/ml7bpl7QKICAgIC8vICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYXB0dXJlVGVzdFRpbWUgfCBjdnRDb2xvciB0aW1lOiAnICsgKGN2dENvbG9yRW5kVGltZS5nZXRUaW1lKCkgLSBHZXRBdXRvU3RyZXRjaEVuZFRpbWUuZ2V0VGltZSgpKSArICcgbXMnLCAnaW5mbycpOwoKICAgIC8vICAgICBtYXQuZGVsZXRlKCk7CgogICAgLy8gICAgIC8vIOiwg+aVtOWbvuWDj+Wkp+WwjwogICAgLy8gICAgIC8vIGN2LnJlc2l6ZShkc3QsIHJlc2l6ZUltZywgbmV3IGN2LlNpemUodGhpcy5DYW52YXNXaWR0aCwgdGhpcy5DYW52YXNIZWlnaHQpLCAwLCAwLCBjdi5JTlRFUl9MSU5FQVIpOwogICAgLy8gICAgIC8vIGRzdC5kZWxldGUoKTsKCiAgICAvLyAgICAgLy8gbGV0IG9yaWdpbmFsSW1nOCA9IHRoaXMuQml0MTZUbzhfU3RyZXRjaChyZXNpemVJbWcsIEIsIFcpOwogICAgLy8gICAgIC8vIHJlc2l6ZUltZy5kZWxldGUoKTsKCiAgICAvLyAgICAgbGV0IHJlc2l6ZUltZyA9IG5ldyBjdi5NYXQoKTsgLy8g55So5p2l5a2Y5YKo6LCD5pW05ZCO55qE5Zu+5YOPCiAgICAvLyAgICAgaWYgKHRoaXMuaXNQb2xhckF4aXNNb2RlKSB7CiAgICAvLyAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSAwOwogICAgLy8gICAgICAgLy8g6LCD5pW05Zu+5YOP5aSn5bCPCiAgICAvLyAgICAgICBjdi5yZXNpemUoZHN0LCByZXNpemVJbWcsIG5ldyBjdi5TaXplKHRoaXMuQ2FudmFzV2lkdGgsIHRoaXMuQ2FudmFzSGVpZ2h0KSwgMCwgMCwgY3YuSU5URVJfTElORUFSKTsKICAgIC8vICAgICAgIGRzdC5kZWxldGUoKTsKCiAgICAvLyAgICAgICBsZXQgb3JpZ2luYWxJbWc4OwogICAgLy8gICAgICAgaWYgKGltZ19iaXQgPT09IDE2KXsKICAgIC8vICAgICAgICAgb3JpZ2luYWxJbWc4ID0gdGhpcy5CaXQxNlRvOF9TdHJldGNoKHJlc2l6ZUltZywgQiwgVyk7CiAgICAvLyAgICAgICB9ZWxzZXsKICAgIC8vICAgICAgICAgb3JpZ2luYWxJbWc4ID0gcmVzaXplSW1nOwogICAgLy8gICAgICAgfQoKICAgIC8vICAgICAgIHJlc2l6ZUltZy5kZWxldGUoKTsKCiAgICAvLyAgICAgICBjb25zdCBCaXQxNlRvOF9TdHJldGNoRW5kVGltZSA9IG5ldyBEYXRlKCk7IC8vIEJpdDE2VG84X1N0cmV0Y2gg57uT5p2f5pe26Ze0CiAgICAvLyAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYXB0dXJlVGVzdFRpbWUgfCBCaXQxNlRvOF9TdHJldGNoIHRpbWU6ICcgKyAoQml0MTZUbzhfU3RyZXRjaEVuZFRpbWUuZ2V0VGltZSgpIC0gR2V0QXV0b1N0cmV0Y2hFbmRUaW1lLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKCiAgICAvLyAgICAgICBsZXQgdGFyZ2V0SW1nOCA9IHRoaXMuSW1hZ2VTb2Z0QVdCKG9yaWdpbmFsSW1nOCwgZ2FpblIsIGdhaW5CLCBvZmZzZXQpOwogICAgLy8gICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzaG93U29sdmVJbWFnZScsIHRhcmdldEltZzgpOwoKICAgIC8vICAgICAgIGNvbnN0IEltYWdlU29mdEFXQkVuZFRpbWUgPSBuZXcgRGF0ZSgpOyAvLyBJbWFnZVNvZnRBV0Ig57uT5p2f5pe26Ze0CiAgICAvLyAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYXB0dXJlVGVzdFRpbWUgfCBJbWFnZVNvZnRBV0IgdGltZTogJyArIChJbWFnZVNvZnRBV0JFbmRUaW1lLmdldFRpbWUoKSAtIEJpdDE2VG84X1N0cmV0Y2hFbmRUaW1lLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKICAgIC8vICAgICB9IGVsc2UgewogICAgLy8gICAgICAgbW9kaWZpZWRDdHguY2xlYXJSZWN0KDAsIDAsIG1vZGlmaWVkQ2FudmFzLndpZHRoLCBtb2RpZmllZENhbnZhcy5oZWlnaHQpOwogICAgLy8gICAgICAgY3YucmVzaXplKGRzdCwgcmVzaXplSW1nLCBuZXcgY3YuU2l6ZSh0aGlzLkNhbnZhc1dpZHRoLCB0aGlzLkNhbnZhc0hlaWdodCksIDAsIDAsIGN2LklOVEVSX0xJTkVBUik7CiAgICAvLyAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSA3MDsKICAgIC8vICAgICAgIGxldCBvcmlnaW5hbFJlc2l6ZUltZzggPSB0aGlzLkJpdDE2VG84X1N0cmV0Y2gocmVzaXplSW1nLCBCLCBXKTsKICAgIC8vICAgICAgIHRoaXMuT3JpZ2luYWxJbWFnZSA9IG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG9yaWdpbmFsUmVzaXplSW1nOC5kYXRhKSwgb3JpZ2luYWxSZXNpemVJbWc4LmNvbHMsIG9yaWdpbmFsUmVzaXplSW1nOC5yb3dzKTsKICAgIC8vICAgICAgIHJlc2l6ZUltZy5kZWxldGUoKTsKICAgIC8vICAgICAgIG9yaWdpbmFsUmVzaXplSW1nOC5kZWxldGUoKTsKICAgIC8vICAgICAgIGNvbnNvbGUubG9nKCdkc3QuZGF0YS5sZW5ndGg6ICcsIGRzdC5kYXRhLmxlbmd0aCk7CiAgICAvLyAgICAgICBjb25zb2xlLmxvZygnZHN0LmNvbHM6ICcsIGRzdC5jb2xzKTsKICAgIC8vICAgICAgIGNvbnNvbGUubG9nKCdkc3Qucm93czogJywgZHN0LnJvd3MpOwogICAgLy8gICAgICAgbGV0IG9yaWdpbmFsSW1nOCA9IHRoaXMuQml0MTZUbzhfU3RyZXRjaChkc3QsIEIsIFcpOwogICAgLy8gICAgICAgZHN0LmRlbGV0ZSgpOwogICAgLy8gICAgICAgdGhpcy5wcm9ncmVzc1ZhbHVlID0gODA7CgogICAgLy8gICAgICAgY29uc3QgQml0MTZUbzhfU3RyZXRjaEVuZFRpbWUgPSBuZXcgRGF0ZSgpOyAvLyBCaXQxNlRvOF9TdHJldGNoIOe7k+adn+aXtumXtAogICAgLy8gICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FwdHVyZVRlc3RUaW1lIHwgQml0MTZUbzhfU3RyZXRjaCB0aW1lOiAnICsgKEJpdDE2VG84X1N0cmV0Y2hFbmRUaW1lLmdldFRpbWUoKSAtIEdldEF1dG9TdHJldGNoRW5kVGltZS5nZXRUaW1lKCkpICsgJyBtcycsICdpbmZvJyk7CgogICAgLy8gICAgICAgLy8gbGV0IHRhcmdldEltZzggPSB0aGlzLkltYWdlU29mdEFXQihvcmlnaW5hbEltZzgsIGdhaW5SLCBnYWluQiwgb2Zmc2V0KTsKCiAgICAvLyAgICAgICAvLyBjb25zdCBJbWFnZVNvZnRBV0JFbmRUaW1lID0gbmV3IERhdGUoKTsgLy8gSW1hZ2VTb2Z0QVdCIOe7k+adn+aXtumXtAogICAgLy8gICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnQ2FwdHVyZVRlc3RUaW1lIHwgSW1hZ2VTb2Z0QVdCIHRpbWU6ICcgKyAoSW1hZ2VTb2Z0QVdCRW5kVGltZS5nZXRUaW1lKCkgLSBCaXQxNlRvOF9TdHJldGNoRW5kVGltZS5nZXRUaW1lKCkpICsgJyBtcycsICdpbmZvJyk7CgogICAgLy8gICAgICAgLy8gb3JpZ2luYWxJbWc4LmRlbGV0ZSgpOwoKICAgIC8vICAgICAgIHRoaXMubGFzdEltYWdlUHJvY2Vzc1BhcmFtcyA9IHsKICAgIC8vICAgICAgICAgZ2FpblI6IGdhaW5SLAogICAgLy8gICAgICAgICBnYWluQjogZ2FpbkIsCiAgICAvLyAgICAgICAgIG9mZnNldDogb2Zmc2V0LAogICAgLy8gICAgICAgICBDRkE6IENGQSwKICAgIC8vICAgICAgICAgbW9kZTogbW9kZSwKICAgIC8vICAgICAgICAgQjogQiwKICAgIC8vICAgICAgICAgVzogVywKICAgIC8vICAgICAgICAgY3Ztb2RlOiBjdm1vZGUsCiAgICAvLyAgICAgICB9OwoKICAgIC8vICAgICAgIG1vZGlmaWVkQ2FudmFzLndpZHRoID0gdGhpcy5DYW52YXNXaWR0aDsKICAgIC8vICAgICAgIG1vZGlmaWVkQ2FudmFzLmhlaWdodCA9IHRoaXMuQ2FudmFzSGVpZ2h0OwogICAgLy8gICAgICAgbGV0IGNvbG9yRGF0YSA9IG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG9yaWdpbmFsSW1nOC5kYXRhKSwgb3JpZ2luYWxJbWc4LmNvbHMsIG9yaWdpbmFsSW1nOC5yb3dzKTsKICAgIC8vICAgICAgIG9yaWdpbmFsSW1nOC5kZWxldGUoKTsKICAgIC8vICAgICAgIHRoaXMuZHJhd0ltZ0RhdGEgPSBjb2xvckRhdGE7CiAgICAvLyAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSA5MDsKICAgIC8vICAgICAgIC8vIOiuvue9rue8k+WGsueUu+W4g+WuvemrmAogICAgLy8gICAgICAgdGhpcy5idWZmZXJDYW52YXMud2lkdGggPSBjb2xvckRhdGEud2lkdGg7CiAgICAvLyAgICAgICB0aGlzLmJ1ZmZlckNhbnZhcy5oZWlnaHQgPSBjb2xvckRhdGEuaGVpZ2h0OwogICAgLy8gICAgICAgLy8g57uY5Yi257yT5a2Y55S75biD5Zu+5YOPCiAgICAvLyAgICAgICB0aGlzLmJ1ZmZlckN0eC5wdXRJbWFnZURhdGEoY29sb3JEYXRhLCAwLCAwKTsKICAgIC8vICAgICAgIC8vIOe7mOWItuS4u+eUu+W4g+WbvuWDjwogICAgLy8gICAgICAgdGhpcy5kcmF3SW1hZ2VEYXRhKCk7CiAgICAvLyAgICAgICB0aGlzLnByb2dyZXNzVmFsdWUgPSAxMDA7CiAgICAvLyAgICAgICBjb25zdCBEcmF3SW1hZ2VEYXRhRW5kVGltZSA9IG5ldyBEYXRlKCk7IC8vIERyYXdJbWFnZURhdGEg57uT5p2f5pe26Ze0CiAgICAvLyAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYXB0dXJlVGVzdFRpbWUgfCBEcmF3SW1hZ2VEYXRhIHRpbWU6ICcgKyAoRHJhd0ltYWdlRGF0YUVuZFRpbWUuZ2V0VGltZSgpIC0gQml0MTZUbzhfU3RyZXRjaEVuZFRpbWUuZ2V0VGltZSgpKSArICcgbXMnLCAnaW5mbycpOwoKICAgIC8vICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpOwogICAgLy8gICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBlbmRUaW1lLmdldFRpbWUoKSAtIHN0YXJ0VGltZS5nZXRUaW1lKCk7CiAgICAvLyAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdDYXB0dXJlVGVzdFRpbWUgfCBQcm9jZXNzIGltYWdlIGRhdGEgZW5kOicgKyBlbGFwc2VkVGltZSArICcgbWlsbGlzZWNvbmRzJywgJ2luZm8nKTsKCiAgICAvLyAgICAgICBjb25zdCB0b3RhbEVuZFRpbWUgPSBuZXcgRGF0ZSgpOyAvLyDmgLvnu5PmnZ/ml7bpl7QKICAgIC8vICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0NhcHR1cmVUZXN0VGltZSB8IFRvdGFsIHByb2Nlc3MgaW1hZ2UgZGF0YSB0aW1lOiAnICsgKHRvdGFsRW5kVGltZS5nZXRUaW1lKCkgLSB0b3RhbFN0YXJ0VGltZS5nZXRUaW1lKCkpICsgJyBtcycsICdpbmZvJyk7CgogICAgLy8gICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzaG93Q2FwdHVyZUltYWdlJyk7CiAgICAvLyAgICAgICB0aGlzLk1ha2VIaXN0b2dyYW0oY29sb3JEYXRhKTsKICAgIC8vICAgICAgIHRoaXMuaGlzdG9ncmFtSW1hZ2UgPSBjb2xvckRhdGE7CgogICAgLy8gICAgICAgY29uc3QgY2hlY2tEZXRlY3RlZFN0YXJzRmluaXNoID0gKCkgPT4gewogICAgLy8gICAgICAgICBpZiAodGhpcy5EZXRlY3RlZFN0YXJzRmluaXNoKSB7CiAgICAvLyAgICAgICAgICAgdGhpcy5kZXRlY3RTdGFyc0ltZyA9IHRoaXMuRHJhd0RldGVjdFN0YXJzKHRhcmdldEltZzgsIHRoaXMuRGV0ZWN0ZWRTdGFyc0xpc3QpOwogICAgLy8gICAgICAgICAgIHRhcmdldEltZzguZGVsZXRlKCk7CiAgICAvLyAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTsKICAgIC8vICAgICAgICAgfQogICAgLy8gICAgICAgfTsKCiAgICAvLyAgICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoY2hlY2tEZXRlY3RlZFN0YXJzRmluaXNoLCAxMDAwKTsKICAgIC8vICAgICB9CgogICAgLy8gICAgIC8vIGlmICh0aGlzLmlzTm90RHJhd1N0YXJzKSB7CiAgICAvLyAgICAgLy8gICB0aGlzLmRyYXdJbWFnZURhdGEodGhpcy5kcmF3SW1nRGF0YSk7CiAgICAvLyAgICAgLy8gfSBlbHNlIHsKICAgIC8vICAgICAvLyAgIGlmICh0aGlzLmRldGVjdFN0YXJzSW1nICE9IG51bGwpIHsKICAgIC8vICAgICAvLyAgICAgdGhpcy5kcmF3SW1hZ2VEYXRhKHRoaXMuZGV0ZWN0U3RhcnNJbWcpOwogICAgLy8gICAgIC8vICAgfSBlbHNlIHsKICAgIC8vICAgICAvLyAgICAgdGhpcy5kcmF3SW1hZ2VEYXRhKHRoaXMuZHJhd0ltZ0RhdGEpOwogICAgLy8gICAgIC8vICAgfQogICAgLy8gICAgIC8vIH0KCiAgICAvLyAgICAgLy8gY29uc3Qgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDsKICAgIC8vICAgICAvLyBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7CgogICAgLy8gICAgIC8vIGNvbnN0IG1pblRyYW5zbGF0ZVggPSB0aGlzLmltYWdlV2lkdGggLSB0aGlzLkNhbnZhc1dpZHRoOwogICAgLy8gICAgIC8vIGNvbnN0IG1pblRyYW5zbGF0ZVkgPSB0aGlzLmltYWdlSGVpZ2h0IC0gdGhpcy5DYW52YXNIZWlnaHQ7CgogICAgLy8gICAgIC8vIOiuoeeul+WIneWni+eahCBTY2FsZUltYWdlU2l6ZV9YIOWSjCBTY2FsZUltYWdlU2l6ZV9ZCiAgICAvLyAgICAgLy8gdGhpcy5TY2FsZUltYWdlU2l6ZV9YID0gTWF0aC5mbG9vcihtaW5UcmFuc2xhdGVYIC8gdGhpcy5DYW52YXNXaWR0aCAqIHdpbmRvd1dpZHRoICsgd2luZG93V2lkdGgpOwogICAgLy8gICAgIC8vIHRoaXMuU2NhbGVJbWFnZVNpemVfWSA9IE1hdGguZmxvb3IobWluVHJhbnNsYXRlWSAvIHRoaXMuQ2FudmFzSGVpZ2h0ICogd2luZG93SGVpZ2h0ICsgd2luZG93SGVpZ2h0KTsKCiAgICAvLyAgICAgLy8gdGhpcy4kYnVzLiRlbWl0KCdTY2FsZUltYWdlU2l6ZScsIHRoaXMuU2NhbGVJbWFnZVNpemVfWCwgdGhpcy5TY2FsZUltYWdlU2l6ZV9ZKTsKCiAgICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAvLyAgICAgdGhpcy5oYW5kbGVFcnJvcignUHJvY2VzcyBpbWFnZSBkYXRhIGVycm9yJywgJ3Byb2Nlc3NJbWFnZScsIGVycm9yKTsKICAgIC8vICAgICBpZiAobWF0KSB7CiAgICAvLyAgICAgICBtYXQuZGVsZXRlKCk7CiAgICAvLyAgICAgfQogICAgLy8gICAgIGlmIChyZXNpemVJbWcpIHsKICAgIC8vICAgICAgIHJlc2l6ZUltZy5kZWxldGUoKTsKICAgIC8vICAgICB9CiAgICAvLyAgICAgaWYgKG9yaWdpbmFsSW1nOCkgewogICAgLy8gICAgICAgb3JpZ2luYWxJbWc4LmRlbGV0ZSgpOwogICAgLy8gICAgIH0KICAgIC8vICAgICBpZiAodGFyZ2V0SW1nOCkgewogICAgLy8gICAgICAgdGFyZ2V0SW1nOC5kZWxldGUoKTsKICAgIC8vICAgICB9CiAgICAvLyAgIH0KICAgIC8vIH0sCgogICAgLy8gaGlzdG9ncmFtU3RyZXRjaChpbWFnZURhdGEsIG1pbiwgbWF4KSB7CiAgICAvLyAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7CiAgICAvLyAgIC8vIENvbnZlcnQgSW1hZ2VEYXRhIHRvIGN2Lk1hdAogICAgLy8gICBjb25zdCBpbWFnZSA9IGN2Lm1hdEZyb21JbWFnZURhdGEoaW1hZ2VEYXRhKTsKICAgIC8vICAgbGV0IFRpbWUxID0gbmV3IERhdGUoKTsKICAgIC8vICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnaGlzdG9ncmFtU3RyZXRjaCB8IOi9rOaNouWbvuWDj+aVsOaNruaXtumXtDogJyArIChUaW1lMS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpKSArICcgbXMnLCAnaW5mbycpOwogICAgLy8gICAvLyBQZXJmb3JtIHRoZSBoaXN0b2dyYW0gc3RyZXRjaAogICAgLy8gICBjb25zdCBjaGFubmVscyA9IG5ldyBjdi5NYXRWZWN0b3IoKTsKICAgIC8vICAgY3Yuc3BsaXQoaW1hZ2UsIGNoYW5uZWxzKTsgLy8gU3BsaXQgY2hhbm5lbHMgKEJHUikgaW50byBzZXBhcmF0ZSBNYXQgb2JqZWN0cwogICAgLy8gICBsZXQgVGltZTIgPSBuZXcgRGF0ZSgpOwogICAgLy8gICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdoaXN0b2dyYW1TdHJldGNoIHwg5YiG5Ymy6YCa6YGT5pe26Ze0OiAnICsgKFRpbWUyLmdldFRpbWUoKSAtIFRpbWUxLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKICAgIC8vICAgLy8gQ2FsY3VsYXRlIGFscGhhIGFuZCBiZXRhIGZvciBlYWNoIGNoYW5uZWwKICAgIC8vICAgbGV0IGFscGhhID0gMjU1LjAgLyAobWF4IC0gbWluKTsKICAgIC8vICAgbGV0IGJldGEgPSAtbWluICogYWxwaGE7CgogICAgLy8gICBpZiAoYWxwaGEgPCAwKSB7CiAgICAvLyAgICAgYWxwaGEgPSAwOwogICAgLy8gICAgIGJldGEgPSAwOwogICAgLy8gICB9IGVsc2UgaWYgKGFscGhhID4gMjU1KSB7CiAgICAvLyAgICAgYWxwaGEgPSAyNTU7CiAgICAvLyAgICAgYmV0YSA9IDA7CiAgICAvLyAgIH0KICAgIC8vICAgVGltZTEgPSBuZXcgRGF0ZSgpOwogICAgLy8gICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdoaXN0b2dyYW1TdHJldGNoIHwg6K6h566XYWxwaGHlkoxiZXRh5pe26Ze0OiAnICsgKFRpbWUxLmdldFRpbWUoKSAtIFRpbWUyLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKICAgIC8vICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggY2hhbm5lbCBhbmQgYXBwbHkgaGlzdG9ncmFtIHN0cmV0Y2hpbmcKICAgIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVscy5zaXplKCk7IGkrKykgewogICAgLy8gICAgIGxldCBjaGFubmVsID0gY2hhbm5lbHMuZ2V0KGkpOwoKCiAgICAvLyAgICAgLy8gQXBwbHkgaGlzdG9ncmFtIHN0cmV0Y2hpbmcgdG8gdGhlIGNoYW5uZWwKICAgIC8vICAgICBjaGFubmVsLmNvbnZlcnRUbyhjaGFubmVsLCAtMSwgYWxwaGEsIGJldGEpOwoKICAgIC8vICAgICAvLyBSZWxlYXNlIHRoZSBtZW1vcnkgb2YgY2hhbm5lbAogICAgLy8gICAgIGNoYW5uZWwuZGVsZXRlKCk7CiAgICAvLyAgIH0KICAgIC8vICAgVGltZTIgPSBuZXcgRGF0ZSgpOwogICAgLy8gICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdoaXN0b2dyYW1TdHJldGNoIHwg5ZCE6YCa6YGT5ouJ5Ly45pe26Ze0OiAnICsgKFRpbWUyLmdldFRpbWUoKSAtIFRpbWUxLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKICAgIC8vICAgLy8gTWVyZ2UgdGhlIGNoYW5uZWxzIGJhY2sgaW50byBhIHNpbmdsZSBpbWFnZQogICAgLy8gICBjb25zdCBzdHJldGNoSW1hZ2UgPSBuZXcgY3YuTWF0KCk7CiAgICAvLyAgIGN2Lm1lcmdlKGNoYW5uZWxzLCBzdHJldGNoSW1hZ2UpOwogICAgLy8gICBUaW1lMSA9IG5ldyBEYXRlKCk7CiAgICAvLyAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ2hpc3RvZ3JhbVN0cmV0Y2ggfCDlkIjlubbpgJrpgZPml7bpl7Q6ICcgKyAoVGltZTEuZ2V0VGltZSgpIC0gVGltZTIuZ2V0VGltZSgpKSArICcgbXMnLCAnaW5mbycpOwogICAgLy8gICAvLyBSZWxlYXNlIHRoZSBtZW1vcnkgb2YgY2hhbm5lbHMgYW5kIE1hdFZlY3RvcgogICAgLy8gICBjaGFubmVscy5kZWxldGUoKTsKCiAgICAvLyAgIC8vIENvbnZlcnQgY3YuTWF0IGJhY2sgdG8gSW1hZ2VEYXRhCiAgICAvLyAgIGNvbnN0IHN0cmV0Y2hlZEltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHN0cmV0Y2hJbWFnZS5kYXRhKSwgc3RyZXRjaEltYWdlLmNvbHMsIHN0cmV0Y2hJbWFnZS5yb3dzKTsKICAgIC8vICAgVGltZTIgPSBuZXcgRGF0ZSgpOwogICAgLy8gICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdoaXN0b2dyYW1TdHJldGNoIHwg6L2s5o2i5Zu+5YOP5pWw5o2u5pe26Ze0OiAnICsgKFRpbWUyLmdldFRpbWUoKSAtIFRpbWUxLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKICAgIC8vICAgLy8gQ2xlYW4gdXAKICAgIC8vICAgaW1hZ2UuZGVsZXRlKCk7CiAgICAvLyAgIHN0cmV0Y2hJbWFnZS5kZWxldGUoKTsKICAgIC8vICAgVGltZTEgPSBuZXcgRGF0ZSgpOwogICAgLy8gICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdoaXN0b2dyYW1TdHJldGNoIHwg6YeK5pS+5YaF5a2Y5pe26Ze0OiAnICsgKFRpbWUxLmdldFRpbWUoKSAtIFRpbWUyLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKICAgIC8vICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnaGlzdG9ncmFtU3RyZXRjaCB8IOaAu+aXtumXtDogJyArIChUaW1lMS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpKSArICcgbXMnLCAnaW5mbycpOwogICAgLy8gICByZXR1cm4gc3RyZXRjaGVkSW1hZ2VEYXRhOwogICAgLy8gfSwKCiAgICBoaXN0b2dyYW1TdHJldGNoKGltYWdlRGF0YSwgbWluLCBtYXgpIHsKICAgICAgaWYgKG1heCA8IG1pbikgewogICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ2hpc3RvZ3JhbVN0cmV0Y2ggfCBtYXggPCBtaW4sIHJldHVybiBvcmlnaW5hbCBpbWFnZURhdGEnLCAnd2FybmluZycpOwogICAgICAgIG1heCA9IG1pbjsKICAgICAgfQogICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpOwogICAgICAvLyBDYWxjdWxhdGUgYWxwaGEgYW5kIGJldGEKICAgICAgbGV0IGFscGhhID0gMjU1LjAgLyAobWF4IC0gbWluKTsKICAgICAgbGV0IGJldGEgPSAtbWluICogYWxwaGE7CgogICAgICBpZiAoYWxwaGEgPCAwKSB7CiAgICAgICAgYWxwaGEgPSAwOwogICAgICAgIGJldGEgPSAwOwogICAgICB9IGVsc2UgaWYgKGFscGhhID4gMjU1KSB7CiAgICAgICAgYWxwaGEgPSAyNTU7CiAgICAgICAgYmV0YSA9IDA7CiAgICAgIH0KCiAgICAgIC8vIEFwcGx5IGhpc3RvZ3JhbSBzdHJldGNoaW5nIGRpcmVjdGx5IG9uIEltYWdlRGF0YQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5kYXRhLmxlbmd0aDsgaSArPSA0KSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHsgLy8gRm9yIGVhY2ggY29sb3IgY2hhbm5lbAogICAgICAgICAgbGV0IHZhbHVlID0gaW1hZ2VEYXRhLmRhdGFbaSArIGpdOwogICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGFscGhhICsgYmV0YTsKICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2kgKyBqXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgdmFsdWUpKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpOwogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdoaXN0b2dyYW1TdHJldGNoIHwg5oC75pe26Ze0OiAnICsgKGVuZFRpbWUuZ2V0VGltZSgpIC0gc3RhcnRUaW1lLmdldFRpbWUoKSkgKyAnIG1zJywgJ2luZm8nKTsKICAgICAgcmV0dXJuIGltYWdlRGF0YTsKICAgIH0sCiAgICBsb2NhbFdoaXRlQmFsYW5jZUFkanVzdG1lbnQoaW1hZ2VEYXRhLCBnYWluUiwgZ2FpbkIsIG9mZnNldCkgewogICAgICAvLyDliIbnprvpgJrpgZMKICAgICAgbGV0IHZhbHVlOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5kYXRhLmxlbmd0aDsgaSArPSA0KSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHsgLy8gRm9yIGVhY2ggY29sb3IgY2hhbm5lbAogICAgICAgICAgaWYgKGogPT0gMCkgewogICAgICAgICAgICB2YWx1ZSA9IGltYWdlRGF0YS5kYXRhW2kgKyBqXTsKICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGdhaW5CICsgb2Zmc2V0OwogICAgICAgICAgfSBlbHNlIGlmIChqID09IDIpIHsKICAgICAgICAgICAgdmFsdWUgPSBpbWFnZURhdGEuZGF0YVtpICsgal07CiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBnYWluUiArIG9mZnNldDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhbHVlID0gaW1hZ2VEYXRhLmRhdGFbaSArIGpdOwogICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogMSArIG9mZnNldDsKICAgICAgICAgIH0KICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2kgKyBqXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgdmFsdWUpKTsKICAgICAgICB9CiAgICAgIH0KCgogICAgICByZXR1cm4gaW1hZ2VEYXRhOwogICAgfSwKCiAgICBpbml0Q2FudmFzKCkgewogICAgICB0aGlzLmJ1ZmZlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOwogICAgICB0aGlzLmJ1ZmZlckN0eCA9IHRoaXMuYnVmZmVyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7CgogICAgICB0aGlzLnRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsKICAgICAgdGhpcy50ZW1wQ3R4ID0gdGhpcy50ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICB9LAoKICAgIC8vKi8qLyovKi8qLyovKi8qLyovKi8qLwogICAgU3dpdGNoSW1hZ2VUb1Nob3coaXNPcmlnaW5hbCkgewogICAgICAvLyBjb25zb2xlLmxvZygnU2hvdyBPcmlnaW5hbCBJbWFnZTogJywgaXNPcmlnaW5hbCk7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1Nob3cgT3JpZ2luYWwgSW1hZ2U6JyArIGlzT3JpZ2luYWwsICdpbmZvJyk7CiAgICAgIHRoaXMuaXNOb3REcmF3U3RhcnMgPSBpc09yaWdpbmFsOwogICAgICBpZiAoaXNPcmlnaW5hbCkgewogICAgICAgIC8vIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVUb3VjaE9yTW91c2VEb3duKTsKICAgICAgICB0aGlzLmVuYWJsZU1haW5DYW52YXNDbGljayA9IGZhbHNlOwogICAgICAgIHRoaXMuZHJhd0ltYWdlRGF0YSgpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVUb3VjaE9yTW91c2VEb3duKTsKICAgICAgICB0aGlzLmVuYWJsZU1haW5DYW52YXNDbGljayA9IHRydWU7CiAgICAgICAgLy8gdGhpcy5kcmF3SW1hZ2VEYXRhKHRoaXMuZGV0ZWN0U3RhcnNJbWcpOwogICAgICB9CiAgICB9LAoKCgogICAgZHJhd0ltYWdlRGF0YSgpIHsKICAgICAgaWYgKHRoaXMuYnVmZmVyQ2FudmFzID09IG51bGwpIHsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdkcmF3SW1hZ2VEYXRhIGVycm9yOiBidWZmZXJDYW52YXMgaXMgbnVsbCBvciB1bmRlZmluZWQuJywgJ2Vycm9yJyk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGlmICghdGhpcy5kcmF3SW1nRGF0YSkgcmV0dXJuOwoKICAgICAgLy8g5Y+v55So55u45YWz5Y+C5pWwCiAgICAgIC8vIHdpbmRvdy5pbm5lcldpZHRoOyAvLyDnqpflj6Plrr3luqYKICAgICAgLy8gd2luZG93LmlubmVySGVpZ2h0OyAvLyDnqpflj6Ppq5jluqYKICAgICAgLy8gdGhpcy5zY2FsZSDnvKnmlL7mr5TkvosKICAgICAgLy8gdGhpcy50cmFuc2xhdGVYIOW5s+enu3jlnZDmoIcKICAgICAgLy8gdGhpcy50cmFuc2xhdGVZIOW5s+enu3nlnZDmoIcKICAgICAgLy8gdGhpcy5DYW52YXNXaWR0aCDkuLvnlLvluIPlrr3luqYgMTkyMAogICAgICAvLyB0aGlzLkNhbnZhc0hlaWdodCDkuLvnlLvluIPpq5jluqYgMTA4MAogICAgICAvLyB0aGlzLm1haW5DYW1lcmFTaXplWCDljp/lp4vlm77lg4/lrr3luqYKICAgICAgLy8gdGhpcy5tYWluQ2FtZXJhU2l6ZVkg5Y6f5aeL5Zu+5YOP6auY5bqmCiAgICAgIC8vIHRoaXMuYnVmZmVyQ2FudmFzLndpZHRoIOe8k+WGsueUu+W4g+WuveW6pgogICAgICAvLyB0aGlzLmJ1ZmZlckNhbnZhcy5oZWlnaHQg57yT5Yay55S75biD6auY5bqmCiAgICAgIC8vIHRoaXMuSW1hZ2VQcm9wb3J0aW9uIOWbvuWDj+avlOS+iwogICAgICAvLyB0aGlzLlJPSV94IFJPSeeahHjlnZDmoIcKICAgICAgLy8gdGhpcy5ST0lfeSBST0nnmoR55Z2Q5qCHCiAgICAgIC8vIHRoaXMuUk9JX2xlbmd0aCBST0nnmoTplb/luqYKCiAgICAgIC8vIGNvbnNvbGUubG9nKCflvZPliY3nlLvluIPlj4LmlbA6XG4gYnVmZmVyQ2FudmFzLndpZHRoOiAnLCB0aGlzLmJ1ZmZlckNhbnZhcy53aWR0aCwgJ1xuIGJ1ZmZlckNhbnZhcy5oZWlnaHQ6ICcsIHRoaXMuYnVmZmVyQ2FudmFzLmhlaWdodCwgJ1xuIEltYWdlUHJvcG9ydGlvbjogJywgdGhpcy5JbWFnZVByb3BvcnRpb24sICdcbiBzY2FsZTogJywgdGhpcy5zY2FsZSwgJ1xuIHZpc2libGVYOiAnLCB0aGlzLnZpc2libGVYLCAnXG4gdmlzaWJsZVk6ICcsIHRoaXMudmlzaWJsZVksICdcbiB2aXNpYmxlV2lkdGg6ICcsIHRoaXMudmlzaWJsZVdpZHRoLCAnXG4gdmlzaWJsZUhlaWdodDogJywgdGhpcy52aXNpYmxlSGVpZ2h0LCAnXG4gUk9JX3g6ICcsIHRoaXMuUk9JX3gsICdcbiBST0lfeTogJywgdGhpcy5ST0lfeSwgJ1xuIFJPSV9sZW5ndGg6ICcsIHRoaXMuUk9JX2xlbmd0aCk7CgoKICAgICAgLy8g6K6h566X5Y+v6KeB5Yy65Z+fCiAgICAgIGNvbnN0IG5ld1Zpc2libGVXaWR0aCA9IHRoaXMuYnVmZmVyQ2FudmFzLndpZHRoICogdGhpcy5zY2FsZTsKICAgICAgY29uc3QgbmV3VmlzaWJsZUhlaWdodCA9IG5ld1Zpc2libGVXaWR0aCAvIHRoaXMuSW1hZ2VQcm9wb3J0aW9uOwoKICAgICAgLy8g6K6h566X5Y+v6KeB5Yy65Z+feOWdkOaghwogICAgICBsZXQgbmV3VmlzaWJsZVggPSB0aGlzLnZpc2libGVYOwogICAgICAvLyDorqHnrpflj6/op4HljLrln5955Z2Q5qCHCiAgICAgIGxldCBuZXdWaXNpYmxlWSA9IHRoaXMudmlzaWJsZVk7CgogICAgICAvLyDpgb/lhY3lm77lg4/otornlYwKICAgICAgaWYgKG5ld1Zpc2libGVYIC0gbmV3VmlzaWJsZVdpZHRoIC8gMiA8IDApIHsKICAgICAgICBuZXdWaXNpYmxlWCA9IG5ld1Zpc2libGVXaWR0aCAvIDI7CiAgICAgIH0gZWxzZSBpZiAobmV3VmlzaWJsZVggKyBuZXdWaXNpYmxlV2lkdGggLyAyID4gdGhpcy5idWZmZXJDYW52YXMud2lkdGgpIHsKICAgICAgICBuZXdWaXNpYmxlWCA9IHRoaXMuYnVmZmVyQ2FudmFzLndpZHRoIC0gbmV3VmlzaWJsZVdpZHRoIC8gMjsKICAgICAgfQoKICAgICAgaWYgKG5ld1Zpc2libGVZIC0gbmV3VmlzaWJsZUhlaWdodCAvIDIgPCAwKSB7CiAgICAgICAgbmV3VmlzaWJsZVkgPSBuZXdWaXNpYmxlSGVpZ2h0IC8gMjsKICAgICAgfSBlbHNlIGlmIChuZXdWaXNpYmxlWSArIG5ld1Zpc2libGVIZWlnaHQgLyAyID4gdGhpcy5idWZmZXJDYW52YXMuaGVpZ2h0KSB7CiAgICAgICAgbmV3VmlzaWJsZVkgPSB0aGlzLmJ1ZmZlckNhbnZhcy5oZWlnaHQgLSBuZXdWaXNpYmxlSGVpZ2h0IC8gMjsKICAgICAgfQoKICAgICAgLy8g5pu05pawUk9J5Yy65Z+fCiAgICAgIC8vIOiuoeeul+WPr+ingeWMuuWfn+eahOi+ueeVjAogICAgICBjb25zdCB2aXNpYmxlTGVmdCA9IG5ld1Zpc2libGVYIC0gbmV3VmlzaWJsZVdpZHRoIC8gMjsKICAgICAgY29uc3QgdmlzaWJsZVJpZ2h0ID0gbmV3VmlzaWJsZVggKyBuZXdWaXNpYmxlV2lkdGggLyAyOwogICAgICBjb25zdCB2aXNpYmxlVG9wID0gbmV3VmlzaWJsZVkgLSBuZXdWaXNpYmxlSGVpZ2h0IC8gMjsKICAgICAgY29uc3QgdmlzaWJsZUJvdHRvbSA9IG5ld1Zpc2libGVZICsgbmV3VmlzaWJsZUhlaWdodCAvIDI7CgogICAgICAvLyDorqHnrpcgUk9JIOWMuuWfn+eahOi+ueeVjAogICAgICBjb25zdCByb2lMZWZ0ID0gdGhpcy5ST0lfeDsKICAgICAgY29uc3Qgcm9pUmlnaHQgPSB0aGlzLlJPSV94ICsgdGhpcy5ST0lfbGVuZ3RoOwogICAgICBjb25zdCByb2lUb3AgPSB0aGlzLlJPSV95OwogICAgICBjb25zdCByb2lCb3R0b20gPSB0aGlzLlJPSV95ICsgdGhpcy5ST0lfbGVuZ3RoOwoKICAgICAgLy8g5Yik5patIFJPSSDljLrln5/mmK/lkKblnKjlj6/op4HljLrln5/lhoUKICAgICAgY29uc3QgaXNSb2lJblZpc2libGUgPSByb2lSaWdodCA+PSB2aXNpYmxlTGVmdCAmJiByb2lMZWZ0IDw9IHZpc2libGVSaWdodCAmJiByb2lCb3R0b20gPj0gdmlzaWJsZVRvcCAmJiByb2lUb3AgPD0gdmlzaWJsZUJvdHRvbTsKCiAgICAgIC8vIOiuoeeulyBST0kg5Yy65Z+f5Zyo5bGP5bmV5LiK55qE5L2N572u77yM5Lit5b+D54K55Z2Q5qCHCiAgICAgIGNvbnN0IHJvaVNjcmVlblggPSAodGhpcy5ST0lfeCAtIHZpc2libGVMZWZ0KSAqICh3aW5kb3cuaW5uZXJXaWR0aCAvIG5ld1Zpc2libGVXaWR0aCkgKyB0aGlzLlJlZEJveFNpZGVMZW5ndGggKiB3aW5kb3cuaW5uZXJXaWR0aCAvIG5ld1Zpc2libGVXaWR0aCAvIDI7CiAgICAgIGNvbnN0IHJvaVNjcmVlblkgPSAodGhpcy5ST0lfeSAtIHZpc2libGVUb3ApICogKHdpbmRvdy5pbm5lckhlaWdodCAvIG5ld1Zpc2libGVIZWlnaHQpICsgdGhpcy5SZWRCb3hTaWRlTGVuZ3RoICogd2luZG93LmlubmVySGVpZ2h0IC8gbmV3VmlzaWJsZUhlaWdodCAvIDI7CiAgICAgIC8vIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1JPSSDljLrln5/lnKjlsY/luZXkuIrnmoTkvY3nva46ICcgKyByb2lTY3JlZW5YICsgJyonICsgcm9pU2NyZWVuWSArICfplb/luqYgJyArIHRoaXMuUmVkQm94U2lkZUxlbmd0aCAqIHdpbmRvdy5pbm5lcldpZHRoIC8gbmV3VmlzaWJsZVdpZHRoICsgJyonICsgdGhpcy5SZWRCb3hTaWRlTGVuZ3RoICogd2luZG93LmlubmVySGVpZ2h0IC8gbmV3VmlzaWJsZUhlaWdodCwgJ2luZm8nKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzZXRSZWRCb3hMZW5ndGgnLCB0aGlzLlJlZEJveFNpZGVMZW5ndGggKiB3aW5kb3cuaW5uZXJXaWR0aCAvIG5ld1Zpc2libGVXaWR0aCwgdGhpcy5SZWRCb3hTaWRlTGVuZ3RoICogd2luZG93LmlubmVySGVpZ2h0IC8gbmV3VmlzaWJsZUhlaWdodCk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2V0UmVkQm94UG9zaXRpb24nLCByb2lTY3JlZW5YLCByb2lTY3JlZW5ZKTsKCgogICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLm1haW5DYW52YXM7CiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICBjYW52YXMud2lkdGggPSB0aGlzLkNhbnZhc1dpZHRoOwogICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5DYW52YXNIZWlnaHQ7CgogICAgICBjdHguZHJhd0ltYWdlKHRoaXMuYnVmZmVyQ2FudmFzLCB2aXNpYmxlTGVmdCwgdmlzaWJsZVRvcCwgbmV3VmlzaWJsZVdpZHRoLCBuZXdWaXNpYmxlSGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpOwoKICAgICAgdGhpcy52aXNpYmxlWCA9IG5ld1Zpc2libGVYOwogICAgICB0aGlzLnZpc2libGVZID0gbmV3VmlzaWJsZVk7CiAgICAgIHRoaXMudmlzaWJsZVdpZHRoID0gbmV3VmlzaWJsZVdpZHRoOwogICAgICB0aGlzLnZpc2libGVIZWlnaHQgPSBuZXdWaXNpYmxlSGVpZ2h0OwoKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzZXRDdXJyZW50TWFpbkNhbnZhc0hhc0ltYWdlJywgdHJ1ZSk7IC8vIOWPkemAgee7meeUteiwg++8jOeUqOS6juWIpOaWreaYr+WQpuWPr+S7pei/m+ihjOW+queOr+aLjeaRhAogICAgICAvLyDlj5HpgIHmtojmga/nu5lRVOWuouaIt+err++8jOeUqOS6juS/oeaBr+WbvuaghwogICAgICAvLyDnu5/kuIDlnZDmoIfvvJrlj5HpgIHnu5kgUVQg55qEIFJPSSDlnZDmoIfph4fnlKjkvKDmhJ/lmajlg4/ntKDlnZDmoIfvvIjkuI3lho3mjIkgYmluIOaUvuWkp++8ie+8jOmBv+WFjeWcqOWbnueOr+S4reiiq+mHjeWkjeS5mOS7pSBiaW4g5a+86Ie05oyH5pWw57qn5aKe6ZW/CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnc2VuZFZpc2libGVBcmVhOicgKyB0aGlzLnZpc2libGVYICsgJzonICsgdGhpcy52aXNpYmxlWSArICc6JyArIHRoaXMuc2NhbGUpOwoKICAgICAgLy8g5aaC5p6c6YCJ5oup5LqG5pif54K577yM5YiZ5qC55o2u6YCJ5oup5L2N572u77yM5ZyoUk9J5Yy65Z+f5Lit57uY5Yi25LiA5Liq5ZyGCiAgICAgIGlmICh0aGlzLkRyYXdTZWxlY3RTdGFyWCAhPSAtMSAmJiB0aGlzLkRyYXdTZWxlY3RTdGFyWSAhPSAtMSAmJiB0aGlzLnNob3dTZWxlY3RTdGFyKSB7CiAgICAgICAgbGV0IHJhZGl1cywgY2FudmFzU3RhclgsIGNhbnZhc1N0YXJZLCBjb2xvcjsKICAgICAgICAvLyDlpoLmnpzmnInmmJ/ngrkKICAgICAgICBpZiAodGhpcy5EcmF3U2VsZWN0U3RhckhGUiAhPSAtMSkgewogICAgICAgICAgcmFkaXVzID0gdGhpcy5EcmF3U2VsZWN0U3RhckhGUiAvIHRoaXMuc2NhbGUgKiAyOwogICAgICAgICAgaWYgKHJhZGl1cyA8PSAxKSByYWRpdXMgPSAxOwogICAgICAgICAgY2FudmFzU3RhclggPSAodGhpcy5EcmF3U2VsZWN0U3RhclggLyB0aGlzLmNhbWVyYUJpbiArIHRoaXMuUk9JX3ggLSB2aXNpYmxlTGVmdCkgKiBjdHguY2FudmFzLndpZHRoIC8gbmV3VmlzaWJsZVdpZHRoOwogICAgICAgICAgY2FudmFzU3RhclkgPSAodGhpcy5EcmF3U2VsZWN0U3RhclkgLyB0aGlzLmNhbWVyYUJpbiArIHRoaXMuUk9JX3kgLSB2aXNpYmxlVG9wKSAqIGN0eC5jYW52YXMuaGVpZ2h0IC8gbmV3VmlzaWJsZUhlaWdodDsKICAgICAgICAgIGNvbG9yID0gJ2dyZWVuJzsgLy8g5pyJ5pif54K577yM57uY5Yi257u/6Imy55qE5ZyGCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIOWQpuWIme+8jOWcqOmAieaLqeeahOS9jee9rue7mOWItuS4gOS4quWchgogICAgICAgICAgcmFkaXVzID0gMTAgLyB0aGlzLnNjYWxlOyAvLyDkvaDlj6/ku6XmoLnmja7pnIDopoHosIPmlbTov5nkuKrlgLwKICAgICAgICAgIGNhbnZhc1N0YXJYID0gKHRoaXMuRHJhd1NlbGVjdFN0YXJYIC8gdGhpcy5jYW1lcmFCaW4gKyB0aGlzLlJPSV94IC0gdmlzaWJsZUxlZnQpICogY3R4LmNhbnZhcy53aWR0aCAvIG5ld1Zpc2libGVXaWR0aDsKICAgICAgICAgIGNhbnZhc1N0YXJZID0gKHRoaXMuRHJhd1NlbGVjdFN0YXJZIC8gdGhpcy5jYW1lcmFCaW4gKyB0aGlzLlJPSV95IC0gdmlzaWJsZVRvcCkgKiBjdHguY2FudmFzLmhlaWdodCAvIG5ld1Zpc2libGVIZWlnaHQ7CiAgICAgICAgICBjb2xvciA9ICdyZWQnOyAvLyDml6DmmJ/ngrnvvIznu5jliLbnuqLoibLnmoTlnIYKICAgICAgICB9CgogICAgICAgIC8vIOiOt+WPlue7mOWItuWchueahOS9jee9rueahOWbvuWDj+aVsOaNrgogICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoY2FudmFzU3RhclggLSByYWRpdXMsIGNhbnZhc1N0YXJZIC0gcmFkaXVzLCAyICogcmFkaXVzLCAyICogcmFkaXVzKTsKICAgICAgICAvLyDlj5HpgIHlm77lg4/mlbDmja7nu5nmmL7npLrmoYYKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3NlbGVjdFN0YXJJbWFnZScsIGltYWdlRGF0YSk7CiAgICAgICAgY29uc29sZS5sb2coJ+e7mOWItuaYn+eCueeahOS9jee9ruWSjOWkp+WwjzogeCA9JywgY2FudmFzU3RhclgsICd5ID0nLCBjYW52YXNTdGFyWSwgJ3JhZGl1cyA9JywgcmFkaXVzKTsKICAgICAgICAvLyDlnKjmjIflrprkvY3nva7lvIDlp4vnu5jliLblnIYKICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgY3R4LmFyYyhjYW52YXNTdGFyWCwgY2FudmFzU3RhclksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpOwogICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yOwogICAgICAgIGN0eC5saW5lV2lkdGggPSAzOwogICAgICAgIGN0eC5zdHJva2UoKTsKICAgICAgICBjdHguY2xvc2VQYXRoKCk7CiAgICAgIH0KCiAgICB9LAoKICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkgewoKICAgIH0sCgogICAgLy8g6IqC5rWB5Ye95pWwCiAgICB0aHJvdHRsZShmdW5jLCBkZWxheSkgewogICAgICBsZXQgbGFzdEV4ZWN1dGVkID0gMDsKICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7CiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTsKICAgICAgICBpZiAobm93IC0gbGFzdEV4ZWN1dGVkID49IGRlbGF5KSB7CiAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgICAgICAgbGFzdEV4ZWN1dGVkID0gbm93OwogICAgICAgIH0KICAgICAgfTsKICAgIH0sCgogICAgQml0MTZUbzhfU3RyZXRjaChpbWcxNiwgQiwgVykgewogICAgICBjb25zb2xlLmxvZygnQml0MTZUbzhfU3RyZXRjaCB8IEIgPSAnICsgQiArICcsIFcgPSAnICsgVyk7CiAgICAgIGxldCBpbWc4ID0gbmV3IGN2Lk1hdChpbWcxNi5yb3dzLCBpbWcxNi5jb2xzLCBjdi5DVl84VUM0KTsKICAgICAgaW1nMTYuY29udmVydFRvKGltZzgsIGN2LkNWXzhVLCAyNTUuMCAvIChXIC0gQiksIC1CICogMjU1LjAgLyAoVyAtIEIpKTsKICAgICAgcmV0dXJuIGltZzg7CiAgICB9LAoKICAgIERyYXdEZXRlY3RTdGFycyhpbWFnZSwgU3RhcnMpIHsKICAgICAgY29uc29sZS5sb2coJ0RyYXcgY2lyY2xlIG9uIHRoZSBDYXB0dXJlIEltYWdlKCcsIGltYWdlLmNvbHMsICcsJywgaW1hZ2Uucm93cywgJykuJyk7CiAgICAgIGlmICghKGltYWdlIGluc3RhbmNlb2YgY3YuTWF0KSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbWFnZSBkYXRhJyk7CiAgICAgIH0KICAgICAgU3RhcnMuZm9yRWFjaChzdGFyID0+IHsKICAgICAgICBsZXQgY2VudGVyWCA9IE1hdGgucm91bmQoc3Rhci54IC8gKHRoaXMubWFpbkNhbWVyYVNpemVYIC8gaW1hZ2UuY29scykpOwogICAgICAgIGxldCBjZW50ZXJZID0gTWF0aC5yb3VuZChzdGFyLnkgLyAodGhpcy5tYWluQ2FtZXJhU2l6ZVkgLyBpbWFnZS5yb3dzKSk7CiAgICAgICAgbGV0IHJhZGl1cyA9IE1hdGgucm91bmQoc3Rhci5oZnIpOwoKICAgICAgICBjb25zb2xlLmxvZygnRHJhdyBjaXJjbGUgYXQoJywgY2VudGVyWCwgJywnLCBjZW50ZXJZLCAnKSB3aXRoIHJhZGl1czonLCByYWRpdXMpOwoKICAgICAgICBsZXQgY2VudGVyID0gbmV3IGN2LlBvaW50KGNlbnRlclgsIGNlbnRlclkpOwogICAgICAgIGxldCBjb2xvciA9IG5ldyBjdi5TY2FsYXIoMjU1LCAwLCAwLCAyNTUpOwogICAgICAgIGxldCB0aGlja25lc3MgPSAyOyAvLyDlnIblnIjljprluqYKCiAgICAgICAgY3YuY2lyY2xlKGltYWdlLCBjZW50ZXIsIHJhZGl1cywgY29sb3IsIHRoaWNrbmVzcyk7CgogICAgICAgIC8vIOa3u+WKoCBoZnIg5YC85Yiw5ZyG55qE5LiK5pa5CiAgICAgICAgLy8g56Gu5L+dIHN0YXIuaGZyIOaYr+S4gOS4quaVsOWtlwogICAgICAgIGxldCBoZnJWYWx1ZSA9IHBhcnNlRmxvYXQoc3Rhci5oZnIpOwogICAgICAgIGlmIChpc05hTihoZnJWYWx1ZSkpIHsKICAgICAgICAgIGhmclZhbHVlID0gMDsgLy8g5aaC5p6cIHN0YXIuaGZyIOS4jeiDvei9rOaNouS4uuaVsOWtl++8jOWImem7mOiupOWAvOiuvuS4ujAKICAgICAgICB9CgogICAgICAgIC8vIOS/neeVmeWIsOWwj+aVsOeCueWQjjLkvY0KICAgICAgICBsZXQgdGV4dCA9IGhmclZhbHVlLnRvRml4ZWQoMik7CiAgICAgICAgbGV0IGZvbnRGYWNlID0gY3YuRk9OVF9IRVJTSEVZX1NJTVBMRVg7CiAgICAgICAgbGV0IGZvbnRTY2FsZSA9IDE7CiAgICAgICAgbGV0IHRleHRDb2xvciA9IG5ldyBjdi5TY2FsYXIoMjU1LCAwLCAwLCAyNTUpOwogICAgICAgIGxldCB0ZXh0VGhpY2tuZXNzID0gMjsKCiAgICAgICAgLy8g5omL5Yqo6K6+572u5paH5pys55qE5L2N572u77yM5YGH6K6+5a2X5L2T6auY5bqm5aSn57qm5Li6MTDlg4/ntKAKICAgICAgICBsZXQgdGV4dFggPSBjZW50ZXJYIC0gKHRleHQubGVuZ3RoICogMTApOyAvLyDkvLDnrpfmr4/kuKrlrZfnrKblrr3luqbkuLo15YOP57SgCiAgICAgICAgbGV0IHRleHRZID0gY2VudGVyWSAtIHJhZGl1cyAtIDM7IC8vIOWchueahOS4iuaWuSAzIOWDj+e0oAoKICAgICAgICAvLyDlnKjlm77lg4/kuIrnu5jliLbmlofmnKwKICAgICAgICBjdi5wdXRUZXh0KGltYWdlLCB0ZXh0LCBuZXcgY3YuUG9pbnQodGV4dFgsIHRleHRZKSwgZm9udEZhY2UsIGZvbnRTY2FsZSwgdGV4dENvbG9yLCB0ZXh0VGhpY2tuZXNzKTsKICAgICAgfSk7CgogICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShpbWFnZS5kYXRhKSwgaW1hZ2UuY29scywgaW1hZ2Uucm93cyk7CgogICAgICByZXR1cm4gaW1hZ2VEYXRhOwogICAgfSwKCiAgICBEcmF3UEhEMkJveChQSEQySW1hZ2VTaXplX1gsIFBIRDJJbWFnZVNpemVfWSwgQm94X1gsIEJveF9ZKSB7CiAgICAgIGNvbnN0IHJhdGlvWm9vbVggPSBQSEQySW1hZ2VTaXplX1ggLyB3aW5kb3cuaW5uZXJXaWR0aDsKICAgICAgY29uc3QgcmF0aW9ab29tWSA9IFBIRDJJbWFnZVNpemVfWSAvIHdpbmRvdy5pbm5lckhlaWdodDsKCiAgICAgIGNvbnN0IEJveFdpZHRoID0gMjAgLyByYXRpb1pvb21YOwogICAgICBjb25zdCBCb3hIZWlnaHQgPSAyMCAvIHJhdGlvWm9vbVk7CgogICAgICBjb25zdCBCb3hTdGFydFggPSBCb3hfWCAvIHJhdGlvWm9vbVggLSBCb3hXaWR0aCAvIDI7CiAgICAgIGNvbnN0IEJveFN0YXJ0WSA9IEJveF9ZIC8gcmF0aW9ab29tWSAtIEJveEhlaWdodCAvIDI7CgogICAgICB0aGlzLiRidXMuJGVtaXQoJ1BIRDJCb3hQb3NpdGlvbicsIEJveFN0YXJ0WCwgQm94U3RhcnRZLCBCb3hXaWR0aCwgQm94SGVpZ2h0KTsKICAgIH0sCgogICAgRHJhd1BIRDJDcm9zcyhQSEQySW1hZ2VTaXplX1gsIFBIRDJJbWFnZVNpemVfWSwgQ3Jvc3NfWCwgQ3Jvc3NfWSkgewogICAgICBjb25zdCByYXRpb1pvb21YID0gUEhEMkltYWdlU2l6ZV9YIC8gd2luZG93LmlubmVyV2lkdGg7CiAgICAgIGNvbnN0IHJhdGlvWm9vbVkgPSBQSEQySW1hZ2VTaXplX1kgLyB3aW5kb3cuaW5uZXJIZWlnaHQ7CgogICAgICBjb25zdCBDcm9zc1N0YXJ0WCA9IENyb3NzX1ggLyByYXRpb1pvb21YOwogICAgICBjb25zdCBDcm9zc1N0YXJ0WSA9IENyb3NzX1kgLyByYXRpb1pvb21ZOwoKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdQSEQyQ3Jvc3NQb3NpdGlvbicsIENyb3NzU3RhcnRYLCBDcm9zc1N0YXJ0WSk7CiAgICB9LAoKICAgIERyYXdQSEQyTXVsdGlTdGFycyhQSEQySW1hZ2VTaXplX1gsIFBIRDJJbWFnZVNpemVfWSwgU3Rhcl9YLCBTdGFyX1kpIHsKICAgICAgY29uc3QgcmF0aW9ab29tWCA9IFBIRDJJbWFnZVNpemVfWCAvIHdpbmRvdy5pbm5lcldpZHRoOwogICAgICBjb25zdCByYXRpb1pvb21ZID0gUEhEMkltYWdlU2l6ZV9ZIC8gd2luZG93LmlubmVySGVpZ2h0OwoKICAgICAgY29uc3QgU3RhclN0YXJ0WCA9IFN0YXJfWCAvIHJhdGlvWm9vbVggLSAxMiAvIDI7CiAgICAgIGNvbnN0IFN0YXJTdGFydFkgPSBTdGFyX1kgLyByYXRpb1pvb21ZIC0gMTIgLyAyOwoKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdQSEQyTXVsdGlTdGFyc1Bvc2l0aW9uJywgU3RhclN0YXJ0WCwgU3RhclN0YXJ0WSk7CiAgICB9LAoKICAgIGNhbGN1bGF0ZUhpc3RvZ3JhbShpbWFnZURhdGEpIHsKICAgICAgY29uc29sZS5sb2coJ1FIWUNDRCB8IGNhbGN1bGF0ZUhpc3RvZ3JhbScpOwogICAgICBjb25zdCBoaXN0b2dyYW0gPSBbCiAgICAgICAgQXJyYXkoMjU2KS5maWxsKDApLCAvLyDlrZjlgqjok53oibLpgJrpgZPnm7Tmlrnlm74KICAgICAgICBBcnJheSgyNTYpLmZpbGwoMCksIC8vIOWtmOWCqOe7v+iJsumAmumBk+ebtOaWueWbvgogICAgICAgIEFycmF5KDI1NikuZmlsbCgwKSAgLy8g5a2Y5YKo57qi6Imy6YCa6YGT55u05pa55Zu+CiAgICAgIF07CgogICAgICAvLyDliIbliKvorqHnrpfkuInkuKrpgJrpgZPnmoTnm7Tmlrnlm74KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZURhdGEuZGF0YS5sZW5ndGg7IGkgKz0gNCkgewogICAgICAgIGNvbnN0IHIgPSBpbWFnZURhdGEuZGF0YVtpXTsKICAgICAgICBjb25zdCBnID0gaW1hZ2VEYXRhLmRhdGFbaSArIDFdOwogICAgICAgIGNvbnN0IGIgPSBpbWFnZURhdGEuZGF0YVtpICsgMl07CgogICAgICAgIC8vIOabtOaWsOavj+S4qumAmumBk+eahOebtOaWueWbvgogICAgICAgIGhpc3RvZ3JhbVswXVtiXSsrOwogICAgICAgIGhpc3RvZ3JhbVsxXVtnXSsrOwogICAgICAgIGhpc3RvZ3JhbVsyXVtyXSsrOwogICAgICB9CgogICAgICByZXR1cm4gaGlzdG9ncmFtOwogICAgfSwKCiAgICBhcHBseUhpc3RTdHJldGNoKE1pbiwgTWF4KSB7CiAgICAgIHRoaXMuY3VycmVudEhpc3RvZ3JhbU1pbiA9IE1pbjsKICAgICAgdGhpcy5jdXJyZW50SGlzdG9ncmFtTWF4ID0gTWF4OwogICAgICBpZiAodGhpcy5JbWFnZUFycmF5QnVmZmVyKSB7CiAgICAgICAgdGhpcy5wcm9jZXNzSW1hZ2UodGhpcy5JbWFnZUFycmF5QnVmZmVyLCBNaW4sIE1heCwgeyBjYWxjdWxhdGVIaXN0b2dyYW06IGZhbHNlIH0pOwogICAgICB9CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQ2hhbmdlRGlhbFBvc2l0aW9uJywgTWluLCBNYXgpOwogICAgfSwKCgogICAgY2FsY1doaXRlQmFsYW5jZUdhaW5zKCkgewogICAgICAvLyBjb25zdCBHYWlucyA9IHRoaXMuY2FsY3VsYXRlV2hpdGVCYWxhbmNlR2FpbnModGhpcy5oaXN0b2dyYW1EYXRhLCB0aGlzLkltYWdlT2Zmc2V0KTsKICAgICAgdGhpcy5jYWxjdWxhdGVHYWluID0gdHJ1ZTsKICAgICAgdGhpcy5wcm9jZXNzSW1hZ2UodGhpcy5JbWFnZUFycmF5QnVmZmVyLCB0aGlzLmN1cnJlbnRIaXN0b2dyYW1NaW4sIHRoaXMuY3VycmVudEhpc3RvZ3JhbU1heCwgeyBjYWxjdWxhdGVIaXN0b2dyYW06IGZhbHNlIH0pOwoKICAgICAgdGhpcy5JbWFnZUdhaW5SID0gR2FpbnMuR2FpblI7CiAgICAgIHRoaXMuSW1hZ2VHYWluQiA9IEdhaW5zLkdhaW5COwoKICAgICAgY29uc3QgR2FpblJJbmRleCA9IHRoaXMuTWFpbkNhbWVyYUNvbmZpZ0l0ZW1zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0ubGFiZWwgPT09ICdJbWFnZUdhaW5SJyk7CiAgICAgIGlmIChHYWluUkluZGV4ICE9PSAtMSkgeyAvLyDnoa7kv53mib7liLDkuoblr7nlupTnmoTphY3nva7pobkKICAgICAgICAvLyDmm7TmlrAgRXhwVGltZTEg6YWN572u6aG555qE5YC8CiAgICAgICAgdGhpcy5NYWluQ2FtZXJhQ29uZmlnSXRlbXNbR2FpblJJbmRleF0udmFsdWUgPSB0aGlzLkltYWdlR2FpblI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2VHYWluUiBjb25maWd1cmF0aW9uIGl0ZW0gbm90IGZvdW5kLicpOwogICAgICB9CgogICAgICBjb25zdCBHYWluQkluZGV4ID0gdGhpcy5NYWluQ2FtZXJhQ29uZmlnSXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5sYWJlbCA9PT0gJ0ltYWdlR2FpbkInKTsKICAgICAgaWYgKEdhaW5CSW5kZXggIT09IC0xKSB7IC8vIOehruS/neaJvuWIsOS6huWvueW6lOeahOmFjee9rumhuQogICAgICAgIC8vIOabtOaWsCBFeHBUaW1lMSDphY3nva7pobnnmoTlgLwKICAgICAgICB0aGlzLk1haW5DYW1lcmFDb25maWdJdGVtc1tHYWluQkluZGV4XS52YWx1ZSA9IHRoaXMuSW1hZ2VHYWluQjsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZUdhaW5CIGNvbmZpZ3VyYXRpb24gaXRlbSBub3QgZm91bmQuJyk7CiAgICAgIH0KCiAgICB9LAoKCiAgICBjYWxjdWxhdGVXaGl0ZUJhbGFuY2VHYWlucygpIHsKICAgICAgaWYgKCEodGhpcy5PcmlnaW5hbEltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbWFnZSBkYXRhJyk7CiAgICAgIH0KCiAgICAgIC8vIOWIm+W7uiBjdi5NYXQg5a+56LGhCiAgICAgIGNvbnN0IGltZzggPSBjdi5tYXRGcm9tSW1hZ2VEYXRhKHRoaXMuT3JpZ2luYWxJbWFnZSk7CgogICAgICAvLyDliIblibLpgJrpgZMKICAgICAgY29uc3QgY2hhbm5lbHMgPSBuZXcgY3YuTWF0VmVjdG9yKCk7CiAgICAgIGN2LnNwbGl0KGltZzgsIGNoYW5uZWxzKTsKCiAgICAgIC8vIOiOt+WPluWQhOmAmumBkwogICAgICBjb25zdCBiID0gY2hhbm5lbHMuZ2V0KDApOwogICAgICBjb25zdCBnID0gY2hhbm5lbHMuZ2V0KDEpOwogICAgICBjb25zdCByID0gY2hhbm5lbHMuZ2V0KDIpOwoKICAgICAgLy8g6K6h566X5Lit5L2N5pWwCiAgICAgIGNvbnN0IG1lZGlhbkIgPSBuZXcgY3YuTWF0KCk7CiAgICAgIGNvbnN0IG1lZGlhbkcgPSBuZXcgY3YuTWF0KCk7CiAgICAgIGNvbnN0IG1lZGlhblIgPSBuZXcgY3YuTWF0KCk7CiAgICAgIGN2Lm1lZGlhbkJsdXIoYiwgbWVkaWFuQiwgNSk7CiAgICAgIGN2Lm1lZGlhbkJsdXIoZywgbWVkaWFuRywgNSk7CiAgICAgIGN2Lm1lZGlhbkJsdXIociwgbWVkaWFuUiwgNSk7CgogICAgICAvLyDorqHnrpflubPlnYfkuq7luqYKICAgICAgY29uc3QgYXZnQiA9IGN2Lm1lYW4obWVkaWFuQilbMF07CiAgICAgIGNvbnN0IGF2Z0cgPSBjdi5tZWFuKG1lZGlhbkcpWzBdOwogICAgICBjb25zdCBhdmdSID0gY3YubWVhbihtZWRpYW5SKVswXTsKCiAgICAgIC8vIOiuoeeul+WinuebigogICAgICBjb25zdCBnYWluUiA9IE1hdGgubWluKE1hdGgubWF4KGF2Z0cgLyBhdmdSLCAwLjEpLCAzKTsKICAgICAgY29uc3QgZ2FpbkIgPSBNYXRoLm1pbihNYXRoLm1heChhdmdHIC8gYXZnQiwgMC4xKSwgMyk7CgogICAgICAvLyDph4rmlL7lhoXlrZgKICAgICAgYi5kZWxldGUoKTsKICAgICAgZy5kZWxldGUoKTsKICAgICAgci5kZWxldGUoKTsKICAgICAgbWVkaWFuQi5kZWxldGUoKTsKICAgICAgbWVkaWFuRy5kZWxldGUoKTsKICAgICAgbWVkaWFuUi5kZWxldGUoKTsKICAgICAgY2hhbm5lbHMuZGVsZXRlKCk7CiAgICAgIGltZzguZGVsZXRlKCk7CgogICAgICByZXR1cm4geyBHYWluUjogZ2FpblIsIEdhaW5COiBnYWluQiB9OwogICAgfSwKCiAgICBsb2FkT3BlbkN2KCkgewogICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICAgIGlmICh0eXBlb2YgY3YgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAvLyDlpoLmnpwgY3Yg5pyq5a6a5LmJ77yM5bCd6K+V5Yqg6L29IE9wZW5DVi5qcwogICAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7CiAgICAgICAgICBzY3JpcHQuc3JjID0gJy9vcGVuY3YuanMnOyAvLyDkvb/nlKggcHVibGljIOaWh+S7tuWkueS4reeahOi3r+W+hAogICAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTsKICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiB7CiAgICAgICAgICAgIHJlc29sdmUoKTsKICAgICAgICAgIH07CiAgICAgICAgICBzY3JpcHQub25lcnJvciA9IChlcnJvcikgPT4gewogICAgICAgICAgICByZWplY3QoZXJyb3IpOwogICAgICAgICAgfTsKICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8g5aaC5p6cIGN2IOW3suWumuS5ie+8jOebtOaOpeino+aekAogICAgICAgICAgcmVzb2x2ZSgpOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9LAoKCiAgICBvbkN2UmVhZHkoKSB7CgogICAgICAvLyBUZXN0IGlmIHNvbWUgb2Ygb3BlbmN2IG1ldGhvZCBjYW4gd29yay4KICAgICAgaWYgKGN2KSB7CiAgICAgICAgY29uc29sZS5sb2coIlFIWUNDRCB8IE9wZW5DVi5qcyBpcyByZWFkeS4iKTsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdPcGVuQ1YuanMgaXMgcmVhZHkuJywgJ2luZm8nKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLmxvZygiUUhZQ0NEIHwgRmFpbGVkIHRvIGxvYWQgT3BlbkNWLmpzIik7CiAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnRmFpbGVkIHRvIGxvYWQgT3BlbkNWLmpzLicsICdlcnJvcicpOwogICAgICB9CgogICAgICB0aGlzLmN2UmVhZHkgPSB0cnVlOwogICAgfSwKCgogICAgbG9hZEltYWdlVG9DYW52YXNNYWluQ2FtZXJhOiBmdW5jdGlvbiAoKSB7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluQ2FtZXJhLWNhbnZhcycpOwogICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsKICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4gewogICAgICAgIC8vIOiOt+WPluiuvuWkh+WDj+e0oOavlAogICAgICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxOwoKICAgICAgICAvLyDosIPmlbTnlLvluIPlsLrlr7jku6XpgILlupTpq5jmuIXmmL7npLoKICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aCAqIGRldmljZVBpeGVsUmF0aW87CiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodCAqIGRldmljZVBpeGVsUmF0aW87CiAgICAgICAgY3R4LnNjYWxlKGRldmljZVBpeGVsUmF0aW8sIGRldmljZVBpeGVsUmF0aW8pOyAvLyDnvKnmlL5jdHjku6XpgILlupTpq5jmuIXnlLvluIMKCiAgICAgICAgLy8g57uY5Yi25Zu+5YOPCiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7CiAgICAgIH07CiAgICAgIGltYWdlLnNyYyA9IEJhY2tncm91bmRJbWFnZTsKICAgIH0sCiAgICBsb2FkSW1hZ2VUb0NhbnZhc0d1aWRlckNhbWVyYTogZnVuY3Rpb24gKCkgewogICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3VpZGVyQ2FtZXJhLWNhbnZhcycpOwogICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsKICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4gewogICAgICAgIC8vIOiOt+WPluiuvuWkh+WDj+e0oOavlAogICAgICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxOwoKICAgICAgICAvLyDosIPmlbTnlLvluIPlsLrlr7jku6XpgILlupTpq5jmuIXmmL7npLoKICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aCAqIGRldmljZVBpeGVsUmF0aW87CiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodCAqIGRldmljZVBpeGVsUmF0aW87CiAgICAgICAgY3R4LnNjYWxlKGRldmljZVBpeGVsUmF0aW8sIGRldmljZVBpeGVsUmF0aW8pOyAvLyDnvKnmlL5jdHjku6XpgILlupTpq5jmuIXnlLvluIMKCiAgICAgICAgLy8g57uY5Yi25Zu+5YOPCiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7CiAgICAgIH07CiAgICAgIGltYWdlLnNyYyA9IEJhY2tncm91bmRJbWFnZTsKICAgIH0sCgoKICAgIHNob3dHdWlkZXJDYW1lcmFDYW52YXMoKSB7CiAgICAgIC8vIOWKqOaAgeabtOaWsHotaW5kZXgKICAgICAgdGhpcy5jYW52YXNaSW5kZXhTdGVsID0gLTEwOwogICAgICB0aGlzLmNhbnZhc1pJbmRleE1haW5DYW1lcmEgPSAtMTE7CiAgICAgIHRoaXMuY2FudmFzWkluZGV4R3VpZGVyQ2FtZXJhID0gMDsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzZXRQYXJzaW5nUHJvZ3Jlc3MnLCBmYWxzZSk7CgogICAgICAvLyB0aGlzLmNvbnZlcnRUb0dyYXlzY2FsZSgpOwogICAgfSwKCiAgICBzaG93U3RlbENhbnZhcygpIHsKICAgICAgaWYgKHRoaXMuaXNQb2xhckF4aXNNb2RlKSB7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzZXRQYXJzaW5nUHJvZ3Jlc3MnLCB0cnVlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3NldFBhcnNpbmdQcm9ncmVzcycsIGZhbHNlKTsKICAgICAgfQogICAgICB0aGlzLmNhbnZhc1pJbmRleFN0ZWwgPSAwOwogICAgICB0aGlzLmNhbnZhc1pJbmRleE1haW5DYW1lcmEgPSAtMTA7CiAgICAgIHRoaXMuY2FudmFzWkluZGV4R3VpZGVyQ2FtZXJhID0gLTExOwogICAgfSwKCiAgICBzaG93TWFpbkNhbWVyYUNhbnZhcygpIHsKICAgICAgdGhpcy5jYW52YXNaSW5kZXhTdGVsID0gLTEwOwogICAgICB0aGlzLmNhbnZhc1pJbmRleE1haW5DYW1lcmEgPSAwOwogICAgICB0aGlzLmNhbnZhc1pJbmRleEd1aWRlckNhbWVyYSA9IC0xMTsKCiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2V0UGFyc2luZ1Byb2dyZXNzJywgZmFsc2UpOwogICAgfSwKCgogICAgaGFuZGxlQnV0dG9uVGVzdENsaWNrKCkgewogICAgICAvLyB0aGlzLmNoYW5nZU9yZGVyKCk7CiAgICAgIGlmICh0aGlzLmN1cnJlbnRjYW52YXMgPT09ICdTdGVsJykgewogICAgICAgIHRoaXMuY3VycmVudGNhbnZhcyA9ICdNYWluQ2FtZXJhJzsKICAgICAgICB0aGlzLnNob3dNYWluQ2FtZXJhQ2FudmFzKCk7CiAgICAgIH0KICAgICAgZWxzZSBpZiAodGhpcy5jdXJyZW50Y2FudmFzID09PSAnTWFpbkNhbWVyYScpIHsKICAgICAgICB0aGlzLmN1cnJlbnRjYW52YXMgPSAnR3VpZGVyQ2FtZXJhJzsKICAgICAgICB0aGlzLnNob3dHdWlkZXJDYW1lcmFDYW52YXMoKTsKICAgICAgfQogICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRjYW52YXMgPT09ICdHdWlkZXJDYW1lcmEnKSB7CiAgICAgICAgdGhpcy5jdXJyZW50Y2FudmFzID0gJ1N0ZWwnOwogICAgICAgIHRoaXMuc2hvd1N0ZWxDYW52YXMoKTsKICAgICAgfQogICAgfSwKCiAgICBnZXRQbHVnaW5zTWVudUl0ZW1zOiBmdW5jdGlvbiAoKSB7CiAgICAgIGxldCByZXMgPSBbXQogICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy4kc3RlbGxhcml1bVdlYlBsdWdpbnMoKSkgewogICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMuJHN0ZWxsYXJpdW1XZWJQbHVnaW5zKClbaV0KICAgICAgICBpZiAocGx1Z2luLm1lbnVJdGVtcykgewogICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChwbHVnaW4ubWVudUl0ZW1zKQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcmVzCiAgICB9LAogICAgZ2V0UGx1Z2luc01lbnVDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7CiAgICAgIGxldCByZXMgPSBbXQogICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy4kc3RlbGxhcml1bVdlYlBsdWdpbnMoKSkgewogICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMuJHN0ZWxsYXJpdW1XZWJQbHVnaW5zKClbaV0KICAgICAgICBpZiAocGx1Z2luLm1lbnVDb21wb25lbnRzKSB7CiAgICAgICAgICByZXMgPSByZXMuY29uY2F0KHBsdWdpbi5tZW51Q29tcG9uZW50cykKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJlcwogICAgfSwKICAgIHRvZ2dsZVN0b3JlVmFsdWU6IGZ1bmN0aW9uIChzdG9yZVZhck5hbWUpIHsKICAgICAgdGhpcy5uYXYgPSBmYWxzZTsKICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCd0b2dnbGVCb29sJywgc3RvcmVWYXJOYW1lKQogICAgfSwKICAgIGdldFN0b3JlVmFsdWU6IGZ1bmN0aW9uIChzdG9yZVZhck5hbWUpIHsKICAgICAgcmV0dXJuIF8uZ2V0KHRoaXMuJHN0b3JlLnN0YXRlLCBzdG9yZVZhck5hbWUpCiAgICB9LAogICAgc2V0U3RhdGVGcm9tUXVlcnlBcmdzOiBmdW5jdGlvbiAoKSB7CiAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIG9ic2VydmluZyBwYW5lbCBtdXN0IGJlIGRpc3BsYXllZAogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3NldFZhbHVlJywgeyB2YXJOYW1lOiAnc2hvd1NpZGVQYW5lbCcsIG5ld1ZhbHVlOiB0aGlzLiRyb3V0ZS5wYXRoLnN0YXJ0c1dpdGgoJy9wLycpIH0pCgogICAgICAvLyBTZXQgdGhlIGNvcmUncyBzdGF0ZSBmcm9tIFVSTCBxdWVyeSBhcmd1bWVudHMgc3VjaAogICAgICAvLyBhcyBkYXRlLCBsb2NhdGlvbiwgdmlldyBkaXJlY3Rpb24gJiBmb3YKICAgICAgbGV0IHRoYXQgPSB0aGlzCgogICAgICBpZiAoIXRoaXMuaW5pdERvbmUpIHsKICAgICAgICB0aGlzLiRzdGVsLmNvcmUudGltZV9zcGVlZCA9IDEKICAgICAgICBsZXQgZCA9IG5ldyBEYXRlKCkKICAgICAgICBpZiAodGhpcy4kcm91dGUucXVlcnkuZGF0ZSkgewogICAgICAgICAgZCA9IG5ldyBNb21lbnQodGhpcy4kcm91dGUucXVlcnkuZGF0ZSkudG9EYXRlKCkKICAgICAgICAgIHRoaXMuJHN0ZWwuY29yZS5vYnNlcnZlci51dGMgPSBkLmdldE1KRCgpCiAgICAgICAgICB0aGlzLnN0YXJ0VGltZUlzU2V0ID0gdHJ1ZQogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMuJHJvdXRlLnF1ZXJ5LmxuZyAmJiB0aGlzLiRyb3V0ZS5xdWVyeS5sYXQpIHsKICAgICAgICAgIGNvbnN0IHBvcyA9IHsgbGF0OiBOdW1iZXIodGhpcy4kcm91dGUucXVlcnkubGF0KSwgbG5nOiBOdW1iZXIodGhpcy4kcm91dGUucXVlcnkubG5nKSwgYWx0OiB0aGlzLiRyb3V0ZS5xdWVyeS5lbGV2ID8gTnVtYmVyKHRoaXMuJHJvdXRlLnF1ZXJ5LmVsZXYpIDogMCwgYWNjdXJhY3k6IDEgfQogICAgICAgICAgc3doLmdlb0NvZGVQb3NpdGlvbihwb3MsIHRoYXQpLnRoZW4oKGxvYykgPT4gewogICAgICAgICAgICB0aGF0LiRzdG9yZS5jb21taXQoJ3NldEN1cnJlbnRMb2NhdGlvbicsIGxvYykKICAgICAgICAgIH0sIChlcnJvcikgPT4geyBjb25zb2xlLmxvZyhlcnJvcikgfSkKICAgICAgICB9CgogICAgICAgIHRoaXMuJHN0ZWwuY29yZS5vYnNlcnZlci55YXcgPSB0aGlzLiRyb3V0ZS5xdWVyeS5heiA/IE51bWJlcih0aGlzLiRyb3V0ZS5xdWVyeS5heikgKiBNYXRoLlBJIC8gMTgwIDogMAogICAgICAgIHRoaXMuJHN0ZWwuY29yZS5vYnNlcnZlci5waXRjaCA9IHRoaXMuJHJvdXRlLnF1ZXJ5LmFsdCA/IE51bWJlcih0aGlzLiRyb3V0ZS5xdWVyeS5hbHQpICogTWF0aC5QSSAvIDE4MCA6IDMwICogTWF0aC5QSSAvIDE4MAogICAgICAgIHRoaXMuJHN0ZWwuY29yZS5mb3YgPSB0aGlzLiRyb3V0ZS5xdWVyeS5mb3YgPyBOdW1iZXIodGhpcy4kcm91dGUucXVlcnkuZm92KSAqIE1hdGguUEkgLyAxODAgOiAxMjAgKiBNYXRoLlBJIC8gMTgwCgogICAgICAgIHRoaXMuaW5pdERvbmUgPSB0cnVlCiAgICAgIH0KCiAgICAgIGlmICh0aGlzLiRyb3V0ZS5wYXRoLnN0YXJ0c1dpdGgoJy9za3lzb3VyY2UvJykpIHsKICAgICAgICBjb25zdCBuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuJHJvdXRlLnBhdGguc3Vic3RyaW5nKDExKSkKICAgICAgICBjb25zb2xlLmxvZygnV2lsbCBzZWxlY3Qgb2JqZWN0OiAnICsgbmFtZSkKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdXaWxsIHNlbGVjdCBvYmplY3Q6ICcgKyBuYW1lLCAnaW5mbycpOwogICAgICAgIHJldHVybiBzd2gubG9va3VwU2t5U291cmNlQnlOYW1lKG5hbWUpLnRoZW4oc3MgPT4gewogICAgICAgICAgaWYgKCFzcykgewogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KICAgICAgICAgIGxldCBvYmogPSBzd2guc2t5U291cmNlMlN3ZU9iaihzcykKICAgICAgICAgIGlmICghb2JqKSB7CiAgICAgICAgICAgIG9iaiA9IHRoaXMuJHN0ZWwuY3JlYXRlT2JqKHNzLm1vZGVsLCBzcykKICAgICAgICAgICAgdGhpcy4kc2VsZWN0aW9uTGF5ZXIuYWRkKG9iaikKICAgICAgICAgIH0KICAgICAgICAgIGlmICghb2JqKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2FybmluZygiQ2FuJ3QgZmluZCBvYmplY3QgaW4gU1dFOiAiICsgc3MubmFtZXNbMF0pCiAgICAgICAgICB9CiAgICAgICAgICBzd2guc2V0U3dlT2JqQXNTZWxlY3Rpb24ob2JqKQogICAgICAgIH0sIGVyciA9PiB7CiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpCiAgICAgICAgICBjb25zb2xlLmxvZygiQ291bGRuJ3QgZmluZCBza3lzb3VyY2UgZm9yIG5hbWU6ICIgKyBuYW1lKQogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygiQ291bGRuJ3QgZmluZCBza3lzb3VyY2UgZm9yIG5hbWU6ICIgKyBuYW1lLCAnZXJyb3InKTsKICAgICAgICB9KQogICAgICB9CiAgICB9LAoKICAgIGxvb2thdGNpcmNsZSgpIHsKICAgICAgLy8gZ2xTdGVsLmNvcmUuc2VsZWN0aW9uID0gZ2xUZXN0Q2lyY2xlOwogICAgICBnbFN0ZWwucG9pbnRBbmRMb2NrKGdsVGVzdENpcmNsZSk7CiAgICB9LAoKICAgIHNldEdsb2FiYWxTdGVsOiBmdW5jdGlvbiAoc3RlbCkgewogICAgICByZXR1cm4gc3RlbDsKICAgIH0sCgogICAgc2V0R2xvYmFsTGF5ZXI6IGZ1bmN0aW9uIChzdGVsKSB7CiAgICAgIHJldHVybiBzdGVsLmNyZWF0ZUxheWVyKHsgaWQ6ICd0ZXN0TGF5ZXJTdGFycycsIHo6IDcsIHZpc2libGU6IHRydWUgfSk7CiAgICB9LAoKICAgIC8vIOWdkOagh+mqjOivgeaWueazlQogICAgaXNWYWxpZENvb3JkaW5hdGU6IGZ1bmN0aW9uIChjb29yZCkgewogICAgICAvLyDlpoLmnpzmmK/lrZfnrKbkuLLvvIzlsJ3or5XovazmjaLkuLrmlbDlrZcKICAgICAgaWYgKHR5cGVvZiBjb29yZCA9PT0gJ3N0cmluZycpIHsKICAgICAgICBjb29yZCA9IHBhcnNlRmxvYXQoY29vcmQpOwogICAgICB9CgogICAgICByZXR1cm4gdHlwZW9mIGNvb3JkID09PSAnbnVtYmVyJyAmJgogICAgICAgICFpc05hTihjb29yZCkgJiYKICAgICAgICBpc0Zpbml0ZShjb29yZCkgJiYKICAgICAgICBjb29yZCA+PSAtMzYwICYmCiAgICAgICAgY29vcmQgPD0gMzYwOwogICAgfSwKCiAgICB2ZWMzX2Zyb21fc3BoZTogZnVuY3Rpb24gKHJhX2RlZ3JlZSwgZGVjX2RlZ3JlZSwgb3V0KSB7CiAgICAgIC8vIOehruS/neWdkOagh+aYr+aVsOWtl+exu+WeiwogICAgICBsZXQgcmEgPSByYV9kZWdyZWU7CiAgICAgIGxldCBkZWMgPSBkZWNfZGVncmVlOwoKICAgICAgaWYgKHR5cGVvZiByYSA9PT0gJ3N0cmluZycpIHsKICAgICAgICByYSA9IHBhcnNlRmxvYXQocmEpOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgZGVjID09PSAnc3RyaW5nJykgewogICAgICAgIGRlYyA9IHBhcnNlRmxvYXQoZGVjKTsKICAgICAgfQoKICAgICAgLy8g5re75Yqg5Z2Q5qCH6aqM6K+BCiAgICAgIGlmICghdGhpcy5pc1ZhbGlkQ29vcmRpbmF0ZShyYSkgfHwgIXRoaXMuaXNWYWxpZENvb3JkaW5hdGUoZGVjKSkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+aXoOaViOeahOWdkOagh+i+k+WFpTonLCB7IHJhX2RlZ3JlZSwgZGVjX2RlZ3JlZSwgY29udmVydGVkOiB7IHJhLCBkZWMgfSB9KTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHRyeSB7CiAgICAgICAgY29uc3QgY3AgPSBNYXRoLmNvcyhkZWMgKiBNYXRoLlBJIC8gMTgwKTsKICAgICAgICBvdXRbMF0gPSBNYXRoLmNvcyhyYSAqIE1hdGguUEkgLyAxODApICogY3A7CiAgICAgICAgb3V0WzFdID0gTWF0aC5zaW4ocmEgKiBNYXRoLlBJIC8gMTgwKSAqIGNwOwogICAgICAgIG91dFsyXSA9IE1hdGguc2luKGRlYyAqIE1hdGguUEkgLyAxODApOwogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+WdkOagh+i9rOaNouWHuumUmTonLCBlcnJvciwgeyByYV9kZWdyZWUsIGRlY19kZWdyZWUsIGNvbnZlcnRlZDogeyByYSwgZGVjIH0gfSk7CiAgICAgIH0KICAgIH0sCgogICAgdGVzdEFkZENpcmNsZTogZnVuY3Rpb24gKHN0ZWwsIGxheWVyKSB7CiAgICAgIGNvbnNvbGUubG9nKCJBZGQgYSBjaXJjbGUgc3RhciBuZWFyIHBvbGFyaXMiKTsKCiAgICAgIC8vIOS4uuS4tOaXtuWvueixoeWIm+W7uuW4puacieWQjeensOeahOmFjee9rgogICAgICBjb25zdCBjaXJjbGVDb25maWcgPSB7CiAgICAgICAgaWQ6ICd0ZXN0X2NpcmNsZV8nICsgRGF0ZS5ub3coKSwKICAgICAgICBtb2RlbF9kYXRhOiB7fSwKICAgICAgICBuYW1lczogWydUZXN0IENpcmNsZSddLCAgLy8g5re75Yqg5ZCN56ewCiAgICAgICAgdHlwZXM6IFsnVGVtcG9yYXJ5J10sCiAgICAgICAgbW9kZWw6ICd0ZW1wb3JhcnknCiAgICAgIH07CgogICAgICBsZXQgY2lyY2xlID0gc3RlbC5jcmVhdGVPYmooJ2NpcmNsZScsIGNpcmNsZUNvbmZpZyk7CgogICAgICBjaXJjbGUudXBkYXRlKCk7CiAgICAgIGxheWVyLmFkZChjaXJjbGUpOwoKICAgICAgLy8g546w5Zyo5Y+v5Lul5a6J5YWo5Zyw6YCJ5oup5a+56LGh77yM5Zug5Li65a6D5pyJ5ZCN56ewCiAgICAgIHN0ZWwuY29yZS5zZWxlY3Rpb24gPSBjaXJjbGU7CiAgICAgIHN0ZWwucG9pbnRBbmRMb2NrKGNpcmNsZSk7CgogICAgICAvLyBDaXJjbGUgUHJvcGVydHkKICAgICAgbGV0IG1tID0gY2lyY2xlLnBvczsKICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZSgyLjUyOTcxLCA4OS4yNjQxLCBtbSk7CiAgICAgIGNpcmNsZS5wb3MgPSBtbTsKICAgICAgY29uc29sZS5sb2coImNpcmNsZSBwb3M6IiArIG1tKTsKICAgICAgY2lyY2xlLmxhYmVsID0gIiI7CiAgICAgIGNpcmNsZS5mcmFtZSA9IDE7CiAgICAgIGNpcmNsZS5zaXplID0gWzAuMDUsIDAuMDVdOwogICAgICBjaXJjbGUuY29sb3IgPSBbMCwgMSwgMCwgMC4yNV07CiAgICAgIGNpcmNsZS5ib3JkZXJfY29sb3IgPSBbMCwgMSwgMCwgMV07CgogICAgICByZXR1cm4gY2lyY2xlOwogICAgfSwKCiAgICBVcGRhdGVDaXJjbGVQb3MoUmFfZGVncmVlLCBEZWNfZGVncmVlKSB7CiAgICAgIC8vIOa3u+WKoOWuieWFqOajgOafpQogICAgICBpZiAoIWdsVGVzdENpcmNsZSB8fCAhZ2xUZXN0Q2lyY2xlLnBvcykgewogICAgICAgIGNvbnNvbGUud2FybignZ2xUZXN0Q2lyY2xlIOacquWIneWni+WMlu+8jOi3s+i/h+S9jee9ruabtOaWsCcpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICAKICAgICAgbGV0IG1tID0gZ2xUZXN0Q2lyY2xlLnBvczsKICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZShSYV9kZWdyZWUsIERlY19kZWdyZWUsIG1tKTsKICAgICAgZ2xUZXN0Q2lyY2xlLnBvcyA9IG1tOwogICAgICAvLyBjb25zb2xlLmxvZygi6LWk6YGT5Luq5L2N572u5pu05paw5Li6OiIrUmFfZGVncmVlKyIrIitEZWNfZGVncmVlKTsKICAgIH0sCgogICAgVXBkYXRlVGVsZXNjb3BlU3RhdHVzKHN0YXR1cykgewogICAgICB0aGlzLiRidXMuJGVtaXQoJ01vdW50U3RhdHVzJywgc3RhdHVzKTsKICAgICAgCiAgICAgIC8vIOa3u+WKoOWuieWFqOajgOafpQogICAgICBpZiAoIWdsVGVzdENpcmNsZSkgewogICAgICAgIGNvbnNvbGUud2FybignZ2xUZXN0Q2lyY2xlIOacquWIneWni+WMlu+8jOi3s+i/h+eKtuaAgeabtOaWsCcpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICAKICAgICAgaWYgKHN0YXR1cyA9PT0gJ01vdmluZycpIHsKICAgICAgICBnbFRlc3RDaXJjbGUuY29sb3IgPSBbMSwgMCwgMCwgMC4yNV07CiAgICAgICAgZ2xUZXN0Q2lyY2xlLmJvcmRlcl9jb2xvciA9IFsxLCAwLCAwLCAxXTsKICAgICAgfSBlbHNlIHsKICAgICAgICBnbFRlc3RDaXJjbGUuY29sb3IgPSBbMCwgMSwgMCwgMC4yNV07CiAgICAgICAgZ2xUZXN0Q2lyY2xlLmJvcmRlcl9jb2xvciA9IFswLCAxLCAwLCAxXTsKICAgICAgfQogICAgfSwKCiAgICBVcGRhdGVNYWluQ2FtZXJhU3RhdHVzKHN0YXR1cykgewogICAgICB0aGlzLiRidXMuJGVtaXQoJ01haW5DYW1lcmFTdGF0dXMnLCBzdGF0dXMpOwogICAgfSwKCiAgICAvLyDnu5jliLbop4blnLrlpJrovrnlvaLvvIjln7rkuo7kupTkuKpSQS9ERUPlnZDmoIfnmoTpl63njq/vvIkKICAgIEFkZEZpZWxkT2ZWaWV3UG9seWdvbjogZnVuY3Rpb24gKHN0ZWwsIGxheWVyLCBjb29yZGluYXRlcywgY29sb3IsIG5hbWUpIHsKICAgICAgY29uc29sZS5sb2coYOW8gOWni+WIm+W7uuinhuWcuuWkmui+ueW9ojogJHtuYW1lfWAsIHsgY29vcmRpbmF0ZXMsIGNvbG9yIH0pOwoKICAgICAgdHJ5IHsKICAgICAgICAvLyDpqozor4HovpPlhaXlj4LmlbAKICAgICAgICBpZiAoIWNvb3JkaW5hdGVzIHx8ICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzKSkgewogICAgICAgICAgY29uc29sZS5lcnJvcign6KeG5Zy65Z2Q5qCH5b+F6aG75piv5pWw57uEJyk7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CgogICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggIT09IDUpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOinhuWcuuWdkOagh+W/hemhu+aYrzXkuKrngrnvvIzlvZPliY3mnIkke2Nvb3JkaW5hdGVzLmxlbmd0aH3kuKrngrlgKTsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgLy8g6aqM6K+B5q+P5Liq5Z2Q5qCH54K5CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgY29uc3QgY29vcmQgPSBjb29yZGluYXRlc1tpXTsKICAgICAgICAgIGlmICghY29vcmQgfHwgdHlwZW9mIGNvb3JkLnJhID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY29vcmQuZGVjID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGDlnZDmoIfngrkke2l95qC85byP6ZSZ6K+v77yM6ZyA6KaB5YyF5ZCrcmHlkoxkZWPlsZ7mgKc6YCwgY29vcmQpOwogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyDpqozor4HlnZDmoIflgLwKICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkQ29vcmRpbmF0ZShjb29yZC5yYSkgfHwgIXRoaXMuaXNWYWxpZENvb3JkaW5hdGUoY29vcmQuZGVjKSkgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGDlnZDmoIfngrkke2l955qE5YC85peg5pWIOmAsIGNvb3JkKTsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyDorr7nva7pu5jorqTpopzoibIKICAgICAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSB7CiAgICAgICAgICBzdHJva2U6ICIjRkZGRkZGIiwKICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsCiAgICAgICAgICBmaWxsOiAiIzFFOTBGRiIsCiAgICAgICAgICBmaWxsT3BhY2l0eTogMC4yNQogICAgICAgIH07CgogICAgICAgIGNvbnN0IGZpbmFsQ29sb3IgPSB7IC4uLmRlZmF1bHRDb2xvciwgLi4uY29sb3IgfTsKICAgICAgICBjb25zb2xlLmxvZygn5pyA57uI6aKc6Imy6YWN572uOicsIGZpbmFsQ29sb3IpOwoKICAgICAgICAvLyDliJvlu7rlpJrovrnlvaLlr7nosaEKICAgICAgICBjb25zdCBwb2x5Z29uQ29uZmlnID0gewogICAgICAgICAgaWQ6ICdmaWVsZF9vZl92aWV3XycgKyBEYXRlLm5vdygpLAogICAgICAgICAgbW9kZWxfZGF0YToge30sCiAgICAgICAgICBuYW1lczogW25hbWUgfHwgJ0ZpZWxkIG9mIFZpZXcnXSwKICAgICAgICAgIHR5cGVzOiBbJ0ZpZWxkT2ZWaWV3J10sCiAgICAgICAgICBtb2RlbDogJ2ZpZWxkX29mX3ZpZXcnCiAgICAgICAgfTsKCiAgICAgICAgY29uc29sZS5sb2coJ+WIm+W7ukdlb0pTT07lpJrovrnlvaLlr7nosaEnKTsKICAgICAgICBsZXQgcG9seWdvbiA9IHN0ZWwuY3JlYXRlT2JqKCdnZW9qc29uJywgewogICAgICAgICAgZGF0YTogewogICAgICAgICAgICAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiIsCiAgICAgICAgICAgICJmZWF0dXJlcyI6IFsKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAidHlwZSI6ICJGZWF0dXJlIiwKICAgICAgICAgICAgICAgICJwcm9wZXJ0aWVzIjogewogICAgICAgICAgICAgICAgICAic3Ryb2tlIjogZmluYWxDb2xvci5zdHJva2UsCiAgICAgICAgICAgICAgICAgICJzdHJva2Utb3BhY2l0eSI6IGZpbmFsQ29sb3Iuc3Ryb2tlT3BhY2l0eSwKICAgICAgICAgICAgICAgICAgImZpbGwiOiBmaW5hbENvbG9yLmZpbGwsCiAgICAgICAgICAgICAgICAgICJmaWxsLW9wYWNpdHkiOiBmaW5hbENvbG9yLmZpbGxPcGFjaXR5LAogICAgICAgICAgICAgICAgICAibmFtZSI6IG5hbWUgfHwgJ0ZpZWxkIG9mIFZpZXcnCiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgImdlb21ldHJ5IjogewogICAgICAgICAgICAgICAgICAidHlwZSI6ICJQb2x5Z29uIiwKICAgICAgICAgICAgICAgICAgImNvb3JkaW5hdGVzIjogWwogICAgICAgICAgICAgICAgICAgIFsKICAgICAgICAgICAgICAgICAgICAgIC8vIOS6lOS4quWdkOagh+eCue+8jOW9ouaIkOmXreeOrwogICAgICAgICAgICAgICAgICAgICAgW2Nvb3JkaW5hdGVzWzBdLnJhLCBjb29yZGluYXRlc1swXS5kZWNdLAogICAgICAgICAgICAgICAgICAgICAgW2Nvb3JkaW5hdGVzWzFdLnJhLCBjb29yZGluYXRlc1sxXS5kZWNdLAogICAgICAgICAgICAgICAgICAgICAgW2Nvb3JkaW5hdGVzWzJdLnJhLCBjb29yZGluYXRlc1syXS5kZWNdLAogICAgICAgICAgICAgICAgICAgICAgW2Nvb3JkaW5hdGVzWzNdLnJhLCBjb29yZGluYXRlc1szXS5kZWNdLAogICAgICAgICAgICAgICAgICAgICAgW2Nvb3JkaW5hdGVzWzBdLnJhLCBjb29yZGluYXRlc1swXS5kZWNdICAvLyDpl63lkIjlpJrovrnlvaIKICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIF0KICAgICAgICAgIH0KICAgICAgICB9KTsKCiAgICAgICAgaWYgKCFwb2x5Z29uKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCdHZW9KU09O5aSa6L655b2i5a+56LGh5Yib5bu65aSx6LSlJyk7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CgogICAgICAgIGNvbnNvbGUubG9nKCflpJrovrnlvaLlr7nosaHliJvlu7rmiJDlip/vvIzlvIDlp4vmm7TmlrDlkozmt7vliqDliLDlm77lsYInKTsKCiAgICAgICAgLy8g6K6+572u5a+56LGh5bGe5oCnCiAgICAgICAgcG9seWdvbi51cGRhdGUoKTsKICAgICAgICBsYXllci5hZGQocG9seWdvbik7CgogICAgICAgIGNvbnNvbGUubG9nKCflpJrovrnlvaLlt7Lmt7vliqDliLDlm77lsYInKTsKCiAgICAgICAgLy8gLy8g5re75Yqg5qCH562+77yI5Y+v6YCJ77yJCiAgICAgICAgLy8gaWYgKG5hbWUpIHsKICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCfmt7vliqDlpJrovrnlvaLmoIfnrb4nKTsKICAgICAgICAvLyAgIC8vIOiuoeeul+inhuWcuuS4reW/g+eCuQogICAgICAgIC8vICAgY29uc3QgY2VudGVyUmEgPSBjb29yZGluYXRlcy5yZWR1Y2UoKHN1bSwgY29vcmQpID0+IHN1bSArIGNvb3JkLnJhLCAwKSAvIGNvb3JkaW5hdGVzLmxlbmd0aDsKICAgICAgICAvLyAgIGNvbnN0IGNlbnRlckRlYyA9IGNvb3JkaW5hdGVzLnJlZHVjZSgoc3VtLCBjb29yZCkgPT4gc3VtICsgY29vcmQuZGVjLCAwKSAvIGNvb3JkaW5hdGVzLmxlbmd0aDsKCiAgICAgICAgLy8gICBsZXQgbGFiZWxDaXJjbGUgPSB0aGlzLkFkZE1hcmtDaXJjbGUoc3RlbCwgbGF5ZXIsIDQsIG5hbWUpOwogICAgICAgIC8vICAgaWYgKGxhYmVsQ2lyY2xlKSB7CiAgICAgICAgLy8gICAgIGxldCBsYWJlbE1tID0gbGFiZWxDaXJjbGUucG9zOwogICAgICAgIC8vICAgICB0aGlzLnZlYzNfZnJvbV9zcGhlKGNlbnRlclJhLCBjZW50ZXJEZWMgKyAwLjAyLCBsYWJlbE1tKTsgLy8g5Zyo6KeG5Zy65LiK5pa55pi+56S65ZCN56ewCiAgICAgICAgLy8gICAgIGxhYmVsQ2lyY2xlLnBvcyA9IGxhYmVsTW07CiAgICAgICAgLy8gICAgIGxhYmVsQ2lyY2xlLmNvbG9yID0gWzEsIDEsIDEsIDAuOF07ICAvLyDnmb3oibLvvIzljYrpgI/mmI4KICAgICAgICAvLyAgICAgbGFiZWxDaXJjbGUuYm9yZGVyX2NvbG9yID0gWzAsIDAsIDAsIDAuNV07ICAvLyDpu5HoibLovrnmoYbvvIzljYrpgI/mmI4KICAgICAgICAvLyAgICAgbGFiZWxDaXJjbGUuc2l6ZSA9IFswLjAxLCAwLjAxXTsgIC8vIOW+iOWwj+eahOWchuWciOS9nOS4uuWQjeensOagh+etvgoKICAgICAgICAvLyAgICAgLy8g5bCG5qCH562+5LiO5aSa6L655b2i5YWz6IGUCiAgICAgICAgLy8gICAgIHBvbHlnb24ubGFiZWxDaXJjbGUgPSBsYWJlbENpcmNsZTsKICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ+agh+etvuW3sua3u+WKoOWIsOWkmui+ueW9oicpOwogICAgICAgIC8vICAgfSBlbHNlIHsKICAgICAgICAvLyAgICAgY29uc29sZS53YXJuKCfmoIfnrb7liJvlu7rlpLHotKUnKTsKICAgICAgICAvLyAgIH0KICAgICAgICAvLyB9CgogICAgICAgIGNvbnNvbGUubG9nKGDop4blnLrlpJrovrnlvaLliJvlu7rlrozmiJA6ICR7bmFtZSB8fCAnRmllbGQgb2YgVmlldyd9YCwgewogICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzLAogICAgICAgICAgY29sb3I6IGZpbmFsQ29sb3IsCiAgICAgICAgICBwb2x5Z29uOiBwb2x5Z29uCiAgICAgICAgfSk7CgogICAgICAgIHJldHVybiBwb2x5Z29uOwoKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCfliJvlu7rop4blnLrlpJrovrnlvaLml7blh7rplJk6JywgZXJyb3IpOwogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+mUmeivr+WghuagiDonLCBlcnJvci5zdGFjayk7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KICAgIH0sCgogICAgLy8g5Yig6Zmk5oyH5a6a55qE6KeG5Zy65aSa6L655b2iCiAgICBSZW1vdmVGaWVsZE9mVmlld1BvbHlnb246IGZ1bmN0aW9uIChwb2x5Z29uKSB7CiAgICAgIHRyeSB7CiAgICAgICAgaWYgKCFwb2x5Z29uKSB7CiAgICAgICAgICBjb25zb2xlLndhcm4oJ+imgeWIoOmZpOeahOWkmui+ueW9ouWvueixoeS4uuepuicpOwogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KCiAgICAgICAgLy8g5Yig6Zmk5YWz6IGU55qE5qCH562+CiAgICAgICAgaWYgKHBvbHlnb24ubGFiZWxDaXJjbGUpIHsKICAgICAgICAgIGdsTGF5ZXIucmVtb3ZlKHBvbHlnb24ubGFiZWxDaXJjbGUpOwogICAgICAgIH0KCiAgICAgICAgLy8g5Yig6Zmk5aSa6L655b2iCiAgICAgICAgZ2xMYXllci5yZW1vdmUocG9seWdvbik7CgogICAgICAgIGNvbnNvbGUubG9nKCfop4blnLrlpJrovrnlvaLlt7LliKDpmaQ6JywgcG9seWdvbik7CiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+WIoOmZpOinhuWcuuWkmui+ueW9ouaXtuWHuumUmTonLCBlcnJvcik7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICB9LAoKICAgIC8vIOWIoOmZpOaJgOacieinhuWcuuWkmui+ueW9ogogICAgUmVtb3ZlQWxsRmllbGRPZlZpZXdQb2x5Z29uczogZnVuY3Rpb24gKCkgewogICAgICB0cnkgewogICAgICAgIC8vIOWmguaenOacieWkmui+ueW9ouaVsOe7hO+8jOmBjeWOhuWIoOmZpAogICAgICAgIGlmICh0aGlzLmZpZWxkT2ZWaWV3UG9seWdvbnMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLmZpZWxkT2ZWaWV3UG9seWdvbnMpKSB7CiAgICAgICAgICB0aGlzLmZpZWxkT2ZWaWV3UG9seWdvbnMuZm9yRWFjaChwb2x5Z29uID0+IHsKICAgICAgICAgICAgdGhpcy5SZW1vdmVGaWVsZE9mVmlld1BvbHlnb24ocG9seWdvbik7CiAgICAgICAgICB9KTsKICAgICAgICAgIHRoaXMuZmllbGRPZlZpZXdQb2x5Z29ucyA9IFtdOwogICAgICAgIH0KCiAgICAgICAgY29uc29sZS5sb2coJ+aJgOacieinhuWcuuWkmui+ueW9ouW3suWIoOmZpCcpOwogICAgICAgIHJldHVybiB0cnVlOwoKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCfliKDpmaTmiYDmnInop4blnLrlpJrovrnlvaLml7blh7rplJk6JywgZXJyb3IpOwogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfSwKCiAgICAvLyDmm7TmlrDop4blnLrlpJrovrnlvaLnmoTkvY3nva4KICAgIFVwZGF0ZUZpZWxkT2ZWaWV3UG9seWdvblBvc2l0aW9uOiBmdW5jdGlvbiAocG9seWdvbiwgbmV3Q29vcmRpbmF0ZXMpIHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAoIXBvbHlnb24gfHwgIW5ld0Nvb3JkaW5hdGVzIHx8ICFBcnJheS5pc0FycmF5KG5ld0Nvb3JkaW5hdGVzKSB8fCBuZXdDb29yZGluYXRlcy5sZW5ndGggIT09IDUpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+abtOaWsOinhuWcuuWkmui+ueW9ouS9jee9ruaXtuWPguaVsOaXoOaViCcpOwogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KCiAgICAgICAgLy8g6aqM6K+B5paw5Z2Q5qCHCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDb29yZGluYXRlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgY29uc3QgY29vcmQgPSBuZXdDb29yZGluYXRlc1tpXTsKICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkQ29vcmRpbmF0ZShjb29yZC5yYSkgfHwgIXRoaXMuaXNWYWxpZENvb3JkaW5hdGUoY29vcmQuZGVjKSkgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGDmlrDlnZDmoIfngrkke2l955qE5YC85peg5pWIOmAsIGNvb3JkKTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8g5pu05paw5aSa6L655b2i5pWw5o2uCiAgICAgICAgcG9seWdvbi5kYXRhLmZlYXR1cmVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdID0gWwogICAgICAgICAgW25ld0Nvb3JkaW5hdGVzWzBdLnJhLCBuZXdDb29yZGluYXRlc1swXS5kZWNdLAogICAgICAgICAgW25ld0Nvb3JkaW5hdGVzWzFdLnJhLCBuZXdDb29yZGluYXRlc1sxXS5kZWNdLAogICAgICAgICAgW25ld0Nvb3JkaW5hdGVzWzJdLnJhLCBuZXdDb29yZGluYXRlc1syXS5kZWNdLAogICAgICAgICAgW25ld0Nvb3JkaW5hdGVzWzNdLnJhLCBuZXdDb29yZGluYXRlc1szXS5kZWNdLAogICAgICAgICAgW25ld0Nvb3JkaW5hdGVzWzRdLnJhLCBuZXdDb29yZGluYXRlc1s0XS5kZWNdLAogICAgICAgICAgW25ld0Nvb3JkaW5hdGVzWzBdLnJhLCBuZXdDb29yZGluYXRlc1swXS5kZWNdICAvLyDpl63lkIgKICAgICAgICBdOwoKICAgICAgICBwb2x5Z29uLnVwZGF0ZSgpOwoKICAgICAgICAvLyDmm7TmlrDmoIfnrb7kvY3nva7vvIjlpoLmnpzlrZjlnKjvvIkKICAgICAgICBpZiAocG9seWdvbi5sYWJlbENpcmNsZSkgewogICAgICAgICAgY29uc3QgY2VudGVyUmEgPSBuZXdDb29yZGluYXRlcy5yZWR1Y2UoKHN1bSwgY29vcmQpID0+IHN1bSArIGNvb3JkLnJhLCAwKSAvIG5ld0Nvb3JkaW5hdGVzLmxlbmd0aDsKICAgICAgICAgIGNvbnN0IGNlbnRlckRlYyA9IG5ld0Nvb3JkaW5hdGVzLnJlZHVjZSgoc3VtLCBjb29yZCkgPT4gc3VtICsgY29vcmQuZGVjLCAwKSAvIG5ld0Nvb3JkaW5hdGVzLmxlbmd0aDsKCiAgICAgICAgICBsZXQgbGFiZWxNbSA9IHBvbHlnb24ubGFiZWxDaXJjbGUucG9zOwogICAgICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZShjZW50ZXJSYSwgY2VudGVyRGVjICsgMC4wMiwgbGFiZWxNbSk7CiAgICAgICAgICBwb2x5Z29uLmxhYmVsQ2lyY2xlLnBvcyA9IGxhYmVsTW07CiAgICAgICAgfQoKICAgICAgICBjb25zb2xlLmxvZygn6KeG5Zy65aSa6L655b2i5L2N572u5bey5pu05pawOicsIG5ld0Nvb3JkaW5hdGVzKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgY29uc29sZS5lcnJvcign5pu05paw6KeG5Zy65aSa6L655b2i5L2N572u5pe25Ye66ZSZOicsIGVycm9yKTsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0sCgogICAgVXBkYXRlTWFpbkNhbWVyYVRlbXBlcmF0dXJlKHZhbHVlKSB7CiAgICAgIC8vIGNvbnNvbGUubG9nKCdNYWluIENhbWVyYSBUZW1wZXJhdHVyZTonLCB2YWx1ZSArICfCsCcpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ01haW5DYW1lcmFUZW1wZXJhdHVyZScsIHZhbHVlKTsKICAgIH0sCgogICAgc2V0UG9sYXJQb2ludEFsdGl0dWRlKEFsdGl0dWRlKSB7CiAgICAgIHRoaXMuUG9sYXJQb2ludF9BbHRpdHVkZSA9IEFsdGl0dWRlOwogICAgICBjb25zb2xlLmxvZygnUG9sYXIgUG9pbnQgQWx0aXR1ZGU6JywgdGhpcy5Qb2xhclBvaW50X0FsdGl0dWRlKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnUG9sYXIgUG9pbnQgQWx0aXR1ZGU6JyArIHRoaXMuUG9sYXJQb2ludF9BbHRpdHVkZSwgJ2luZm8nKTsKICAgIH0sCgogICAgQWRkTWFya0NpcmNsZTogZnVuY3Rpb24gKHN0ZWwsIGxheWVyLCBmcmFtZSwgbGFiZWwpIHsKICAgICAgY29uc29sZS5sb2coYOW8gOWni+WIm+W7uuagh+iusOWchuWciDogJHtsYWJlbH1gKTsKCiAgICAgIHRyeSB7CiAgICAgICAgLy8g5Li65Li05pe25a+56LGh5Yib5bu65bim5pyJ5ZCN56ew55qE6YWN572uCiAgICAgICAgY29uc3QgY2lyY2xlQ29uZmlnID0gewogICAgICAgICAgaWQ6ICd0ZW1wX2NpcmNsZV8nICsgRGF0ZS5ub3coKSwKICAgICAgICAgIG1vZGVsX2RhdGE6IHt9LAogICAgICAgICAgbmFtZXM6IFtsYWJlbCB8fCAnVGVtcG9yYXJ5IE1hcmtlciddLCAgLy8g5re75Yqg5ZCN56ewCiAgICAgICAgICB0eXBlczogWydUZW1wb3JhcnknXSwKICAgICAgICAgIG1vZGVsOiAndGVtcG9yYXJ5JwogICAgICAgIH07CgogICAgICAgIGNvbnNvbGUubG9nKCfliJvlu7rlnIblvaLlr7nosaEnKTsKICAgICAgICBsZXQgY2lyY2xlID0gc3RlbC5jcmVhdGVPYmooJ2NpcmNsZScsIGNpcmNsZUNvbmZpZyk7CgogICAgICAgIGlmICghY2lyY2xlKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCflnIblvaLlr7nosaHliJvlu7rlpLHotKUnKTsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgY29uc29sZS5sb2coJ+WchuW9ouWvueixoeWIm+W7uuaIkOWKn++8jOW8gOWni+iuvue9ruWxnuaApycpOwogICAgICAgIGNpcmNsZS51cGRhdGUoKTsKICAgICAgICBsYXllci5hZGQoY2lyY2xlKTsKCiAgICAgICAgLy8g6K6+572u6buY6K6k5L2N572u77yI5YyX5p6B5pif6ZmE6L+R77yJCiAgICAgICAgbGV0IG1tID0gY2lyY2xlLnBvczsKICAgICAgICB0aGlzLnZlYzNfZnJvbV9zcGhlKDIuNTI5NzEsIDg5LjI2NDEsIG1tKTsKICAgICAgICBjaXJjbGUucG9zID0gbW07CgogICAgICAgIC8vIOiuvue9ruWchuW9ouWxnuaApwogICAgICAgIGNpcmNsZS5sYWJlbCA9IGxhYmVsOwogICAgICAgIGNpcmNsZS5mcmFtZSA9IGZyYW1lOwogICAgICAgIGNpcmNsZS5zaXplID0gWzAuMDQsIDAuMDRdOwogICAgICAgIGNpcmNsZS5jb2xvciA9IFsxLCAxLCAxLCAwLjVdOwogICAgICAgIGNpcmNsZS5ib3JkZXJfY29sb3IgPSBbMSwgMSwgMSwgMV07CgogICAgICAgIGNvbnNvbGUubG9nKGDmoIforrDlnIblnIjliJvlu7rlrozmiJA6ICR7bGFiZWx9YCwgewogICAgICAgICAgcG9zOiBtbSwKICAgICAgICAgIHNpemU6IGNpcmNsZS5zaXplLAogICAgICAgICAgY29sb3I6IGNpcmNsZS5jb2xvciwKICAgICAgICAgIGJvcmRlcl9jb2xvcjogY2lyY2xlLmJvcmRlcl9jb2xvcgogICAgICAgIH0pOwoKICAgICAgICByZXR1cm4gY2lyY2xlOwogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+WIm+W7uuagh+iusOWchuWciOaXtuWHuumUmTonLCBlcnJvcik7CiAgICAgICAgY29uc29sZS5lcnJvcign6ZSZ6K+v5aCG5qCIOicsIGVycm9yLnN0YWNrKTsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgfSwKCiAgICBBZGRNYXJrUmVjdGFuZ2xlOiBmdW5jdGlvbiAoc3RlbCwgbGF5ZXIsIFJhRGVjKSB7CiAgICAgIGxldCBsaW5lID0gc3RlbC5jcmVhdGVPYmooJ2dlb2pzb24nLCB7CiAgICAgICAgZGF0YTogewogICAgICAgICAgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24iLAogICAgICAgICAgImZlYXR1cmVzIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgInR5cGUiOiAiRmVhdHVyZSIsCiAgICAgICAgICAgICAgInByb3BlcnRpZXMiOiB7CiAgICAgICAgICAgICAgICAic3Ryb2tlIjogIiNGRkZGRkYiLAogICAgICAgICAgICAgICAgInN0cm9rZS1vcGFjaXR5IjogMSwKICAgICAgICAgICAgICAgICJmaWxsIjogIiMxRTkwRkYiLAogICAgICAgICAgICAgICAgImZpbGwtb3BhY2l0eSI6IDAuMjUKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICJnZW9tZXRyeSI6IHsKICAgICAgICAgICAgICAgICJ0eXBlIjogIlBvbHlnb24iLAogICAgICAgICAgICAgICAgImNvb3JkaW5hdGVzIjogWwogICAgICAgICAgICAgICAgICBbCiAgICAgICAgICAgICAgICAgICAgLy8gWzEzOS43NiwgMzUuNTJdLCBbMTM5LjMyLCAzMy40MV0sIFsxNDAuOTIsIDMzLjA4XSwgWzE0MS4zNSwgMzUuMTldLCBbMTM5Ljc2LCAzNS41Ml0KICAgICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChSYURlY1swXS5SYSksIHBhcnNlRmxvYXQoUmFEZWNbMF0uRGVjKV0sIFtwYXJzZUZsb2F0KFJhRGVjWzFdLlJhKSwgcGFyc2VGbG9hdChSYURlY1sxXS5EZWMpXSwKICAgICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChSYURlY1syXS5SYSksIHBhcnNlRmxvYXQoUmFEZWNbMl0uRGVjKV0sIFtwYXJzZUZsb2F0KFJhRGVjWzNdLlJhKSwgcGFyc2VGbG9hdChSYURlY1szXS5EZWMpXSwKICAgICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChSYURlY1swXS5SYSksIHBhcnNlRmxvYXQoUmFEZWNbMF0uRGVjKV0KICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIH0pOwoKICAgICAgbGluZS51cGRhdGUoKTsKICAgICAgbGF5ZXIuYWRkKGxpbmUpOwogICAgICByZXR1cm4gbGluZTsKICAgIH0sCgoKCiAgICAvLyDovoXliqnmlrnms5XvvJrlsIbljYHlha3ov5vliLbpopzoibLovazmjaLkuLpSR0IKICAgIGhleFRvUmdiOiBmdW5jdGlvbiAoaGV4KSB7CiAgICAgIC8vIOenu+mZpCPlj7cKICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoJyMnLCAnJyk7CgogICAgICAvLyDop6PmnpBSR0LlgLwKICAgICAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zdWJzdHIoMCwgMiksIDE2KTsKICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHIoMiwgMiksIDE2KTsKICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHIoNCwgMiksIDE2KTsKCiAgICAgIHJldHVybiB7IHIsIGcsIGIgfTsKICAgIH0sCgogICAgLy8g5pu05paw6KeG5Zy65pa55rOVCiAgICB1cGRhdGVGaWVsZE9mVmlldzogZnVuY3Rpb24gKGZpZWxkKSB7CiAgICAgIGlmICghZmllbGQgfHwgIWZpZWxkLmZpZWxkSW5mbykgcmV0dXJuOwoKICAgICAgY29uc3QgaW5mbyA9IGZpZWxkLmZpZWxkSW5mbzsKCiAgICAgIC8vIOiuoeeul+inhuWcuueahOWbm+S4quinkueCuQogICAgICBjb25zdCBjb3JuZXJzID0gWwogICAgICAgIHsgUmE6IGluZm8ubWF4UmEsIERlYzogaW5mby5tYXhEZWMgfSwKICAgICAgICB7IFJhOiBpbmZvLm1pblJhLCBEZWM6IGluZm8ubWF4RGVjIH0sCiAgICAgICAgeyBSYTogaW5mby5taW5SYSwgRGVjOiBpbmZvLm1pbkRlYyB9LAogICAgICAgIHsgUmE6IGluZm8ubWF4UmEsIERlYzogaW5mby5taW5EZWMgfSwKICAgICAgICB7IFJhOiBpbmZvLm1heFJhLCBEZWM6IGluZm8ubWF4RGVjIH0gIC8vIOmXreWQiOWkmui+ueW9ogogICAgICBdOwoKICAgICAgLy8g5pu05pawR2VvSlNPTuaVsOaNrgogICAgICBmaWVsZC5kYXRhID0gewogICAgICAgICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIiwKICAgICAgICAiZmVhdHVyZXMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJ0eXBlIjogIkZlYXR1cmUiLAogICAgICAgICAgICAicHJvcGVydGllcyI6IHsKICAgICAgICAgICAgICAic3Ryb2tlIjogaW5mby5jb2xvciwKICAgICAgICAgICAgICAic3Ryb2tlT3BhY2l0eSI6IDAuOCwKICAgICAgICAgICAgICAiZmlsbCI6IGluZm8uY29sb3IsCiAgICAgICAgICAgICAgImZpbGxPcGFjaXR5IjogMC4yCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgICJnZW9tZXRyeSI6IHsKICAgICAgICAgICAgICAidHlwZSI6ICJQb2x5Z29uIiwKICAgICAgICAgICAgICAiY29vcmRpbmF0ZXMiOgogICAgICAgICAgICAgICAgWwogICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChjb3JuZXJzWzBdLlJhKSwgcGFyc2VGbG9hdChjb3JuZXJzWzBdLkRlYyldLAogICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChjb3JuZXJzWzFdLlJhKSwgcGFyc2VGbG9hdChjb3JuZXJzWzFdLkRlYyldLAogICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChjb3JuZXJzWzJdLlJhKSwgcGFyc2VGbG9hdChjb3JuZXJzWzJdLkRlYyldLAogICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChjb3JuZXJzWzNdLlJhKSwgcGFyc2VGbG9hdChjb3JuZXJzWzNdLkRlYyldLAogICAgICAgICAgICAgICAgICBbcGFyc2VGbG9hdChjb3JuZXJzWzRdLlJhKSwgcGFyc2VGbG9hdChjb3JuZXJzWzRdLkRlYyldCiAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICBdCiAgICAgIH07CgogICAgICBmaWVsZC51cGRhdGUoKTsKICAgIH0sCgogICAgLy8g5ZCv5Yqo6KeG5Zy65pu05paw5a6a5pe25ZmoCiAgICBzdGFydEZpZWxkVXBkYXRlVGltZXI6IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuZmllbGRVcGRhdGVUaW1lcikgewogICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5maWVsZFVwZGF0ZVRpbWVyKTsKICAgICAgfQoKICAgICAgdGhpcy5maWVsZFVwZGF0ZVRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gewogICAgICAgIC8vIOabtOaWsOagoeWHhueCueinhuWcugogICAgICAgIGlmICh0aGlzLmNhbGlicmF0aW9uQ2lyY2xlcykgewogICAgICAgICAgdGhpcy5jYWxpYnJhdGlvbkNpcmNsZXMuZm9yRWFjaChmaWVsZCA9PiB7CiAgICAgICAgICAgIGlmIChmaWVsZC5maWVsZEluZm8pIHsKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkT2ZWaWV3KGZpZWxkKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgfQoKICAgICAgICAvLyDmm7TmlrDosIPmlbTngrnop4blnLoKICAgICAgICBpZiAodGhpcy5hZGp1c3RtZW50Q2lyY2xlcykgewogICAgICAgICAgdGhpcy5hZGp1c3RtZW50Q2lyY2xlcy5mb3JFYWNoKGZpZWxkID0+IHsKICAgICAgICAgICAgaWYgKGZpZWxkLmZpZWxkSW5mbykgewogICAgICAgICAgICAgIHRoaXMudXBkYXRlRmllbGRPZlZpZXcoZmllbGQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0sIDMwMDApOyAvLyDmr48z56eS5pu05paw5LiA5qyhCiAgICB9LAoKICAgIC8vIOWBnOatouinhuWcuuabtOaWsOWumuaXtuWZqAogICAgc3RvcEZpZWxkVXBkYXRlVGltZXI6IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuZmllbGRVcGRhdGVUaW1lcikgewogICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5maWVsZFVwZGF0ZVRpbWVyKTsKICAgICAgICB0aGlzLmZpZWxkVXBkYXRlVGltZXIgPSBudWxsOwogICAgICB9CiAgICB9LAoKICAgIGdldENpZWNsZUF6QWx0KENpcmNsZSkgewogICAgICBsZXQgb2JzID0gdGhpcy4kc3RlbC5jb3JlLm9ic2VydmVyOwogICAgICBsZXQgY2lycyA9IHRoaXMuJHN0ZWwuY29udmVydEZyYW1lKG9icywgJ0lDUkYnLCAnQ0lSUycsIENpcmNsZS5nZXRJbmZvKCdyYWRlYycpKTsKICAgICAgbGV0IG9ic2VydmVkID0gdGhpcy4kc3RlbC5jb252ZXJ0RnJhbWUob2JzLCAnQ0lSUycsICdPQlNFUlZFRCcsIGNpcnMpOwogICAgICAvLyBjb25zdCBhemFsdCA9IHRoaXMuJHN0ZWwuYzJzKHRoaXMuJHN0ZWwuY29udmVydEZyYW1lKHRoaXMuJHN0ZWwuY29yZS5vYnNlcnZlciwgJ0lDUkYnLCAnT0JTRVJWRUQnLCBvYmouZ2V0SW5mbygncmFkZWMnKSkpCiAgICAgIGxldCBhemFsdCA9IHRoaXMuJHN0ZWwuYzJzKG9ic2VydmVkKTsKICAgICAgbGV0IGF6ID0gdGhpcy4kc3RlbC5hbnAoYXphbHRbMF0pOwogICAgICBsZXQgYWx0ID0gdGhpcy4kc3RlbC5hbnAoYXphbHRbMV0pOwoKICAgICAgY29uc3QgYXpfcmFmID0gdGhpcy4kc3RlbC5hMmFmKGF6LCAxKTsKICAgICAgY29uc3QgQXpfZGVncmVlID0gKGF6X3JhZi5kZWdyZWVzIDwgMCA/IGF6X3JhZi5kZWdyZWVzICsgMTgwIDogYXpfcmFmLmRlZ3JlZXMpICsgYXpfcmFmLmFyY21pbnV0ZXMgLyA2MCArIGF6X3JhZi5hcmNzZWNvbmRzIC8gMzYwMDsKCiAgICAgIGNvbnN0IGFsdF9yYWYgPSB0aGlzLiRzdGVsLmEyYWYoYWx0LCAxKTsKICAgICAgY29uc3QgQWx0X2RlZ3JlZSA9IGFsdF9yYWYuZGVncmVlcyArIGFsdF9yYWYuYXJjbWludXRlcyAvIDYwICsgYWx0X3JhZi5hcmNzZWNvbmRzIC8gMzYwMDsKCiAgICAgIGNvbnNvbGUubG9nKCdBekFsdDonLCBBel9kZWdyZWUsIEFsdF9kZWdyZWUpOwoKICAgICAgcmV0dXJuIHsgQXpfZGVncmVlLCBBbHRfZGVncmVlIH07CiAgICB9LAoKICAgIFNvbHZlUmVzdWx0TWFyayhSYURlZ3JlZSwgRGVjRGVncmVlLCBBemltdXRoLCBBbHRpdHVkZSkgewogICAgICBsZXQgTWFya0NpcmNsZV9SYURlYyA9IHRoaXMuQWRkTWFya0NpcmNsZSh0aGlzLiRzdGVsLCBnbExheWVyLCAxLCAiUmFEZWMiKTsKICAgICAgbGV0IG1tID0gTWFya0NpcmNsZV9SYURlYy5wb3M7CiAgICAgIHRoaXMudmVjM19mcm9tX3NwaGUoUmFEZWdyZWUsIERlY0RlZ3JlZSwgbW0pOwogICAgICBNYXJrQ2lyY2xlX1JhRGVjLnBvcyA9IG1tOwogICAgICBjb25zb2xlLmxvZygiUmFEZWMgY2lyY2xlIGNvb3JkaW5hdGVzOiIgKyBtbSk7CgogICAgICBjb25zdCBBekFsdCA9IHRoaXMuZ2V0Q2llY2xlQXpBbHQoTWFya0NpcmNsZV9SYURlYyk7CiAgICAgIGdsTGF5ZXIucmVtb3ZlKE1hcmtDaXJjbGVfUmFEZWMpOwoKICAgICAgdGhpcy5NYXJrQ2lyY2xlTnVtKys7CiAgICAgIGxldCBMYWJlbCA9ICJBekFsdF9WdWVfIiArIHRoaXMuTWFya0NpcmNsZU51bTsKCiAgICAgIGxldCBNYXJrQ2lyY2xlX0FsdEF6ID0gdGhpcy5BZGRNYXJrQ2lyY2xlKHRoaXMuJHN0ZWwsIGdsTGF5ZXIsIDQsIExhYmVsKTsKICAgICAgbW0gPSBNYXJrQ2lyY2xlX0FsdEF6LnBvczsKICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZShBekFsdC5Bel9kZWdyZWUsIEF6QWx0LkFsdF9kZWdyZWUsIG1tKTsKICAgICAgTWFya0NpcmNsZV9BbHRBei5wb3MgPSBtbTsKICAgICAgY29uc29sZS5sb2coIkF6QWx0X1Z1ZSBjaXJjbGUgY29vcmRpbmF0ZXM6IiArIG1tKTsKCiAgICAgIGNvbnNvbGUubG9nKCJBekFsdF9WdWUgY2lyY2xlIHg6IiArIG1tWzBdKTsKICAgICAgY29uc29sZS5sb2coIkF6QWx0X1Z1ZSBjaXJjbGUgeToiICsgbW1bMV0pOwogICAgICBjb25zb2xlLmxvZygiQXpBbHRfVnVlIGNpcmNsZSB6OiIgKyBtbVsyXSk7CgogICAgICB0aGlzLkxhc3RQb2ludF9BekFsdCA9IHRoaXMuZ2V0Q2llY2xlQXpBbHQoTWFya0NpcmNsZV9BbHRBeik7CgogICAgICB0aGlzLkNhbGN1bGF0aW9uUG9sYXJQb2ludChtbSk7CgogICAgICAvLyDlsIbliJvlu7rnmoTlnIblrZjlgqjliLDmlbDnu4TkuK0KICAgICAgLy8gdGhpcy5DaXJjbGVzLnB1c2goTWFya0NpcmNsZV9SYURlYyk7CiAgICAgIHRoaXMuQ2lyY2xlcy5wdXNoKE1hcmtDaXJjbGVfQWx0QXopOwoKICAgIH0sCgogICAgUmVtb3ZlQWxsQ2lyY2xlcygpIHsKICAgICAgdGhpcy5DaXJjbGVzLmZvckVhY2goY2lyY2xlID0+IHsKICAgICAgICBnbExheWVyLnJlbW92ZShjaXJjbGUpOwogICAgICB9KTsKICAgICAgdGhpcy5DaXJjbGVzID0gW107CiAgICB9LAoKICAgIFNvbHZlUmVzdWx0TWFya19SZWFsVGltZShSYURlZ3JlZSwgRGVjRGVncmVlLCBBemltdXRoLCBBbHRpdHVkZSkgewogICAgICB0aGlzLkxhc3RDaXJjbGVfUmFEZWMgPSB0aGlzLkFkZE1hcmtDaXJjbGUodGhpcy4kc3RlbCwgZ2xMYXllciwgMSwgIlJhRGVjIik7CiAgICAgIGxldCBtbSA9IHRoaXMuTGFzdENpcmNsZV9SYURlYy5wb3M7CiAgICAgIHRoaXMudmVjM19mcm9tX3NwaGUoUmFEZWdyZWUsIERlY0RlZ3JlZSwgbW0pOwogICAgICB0aGlzLkxhc3RDaXJjbGVfUmFEZWMucG9zID0gbW07CiAgICAgIGNvbnNvbGUubG9nKCJSYURlYyBjaXJjbGUgY29vcmRpbmF0ZXM6IiArIG1tKTsKCiAgICAgIGNvbnN0IEF6QWx0ID0gdGhpcy5nZXRDaWVjbGVBekFsdCh0aGlzLkxhc3RDaXJjbGVfUmFEZWMpOwogICAgICBnbExheWVyLnJlbW92ZSh0aGlzLkxhc3RDaXJjbGVfUmFEZWMpOwoKICAgICAgaWYgKHRoaXMuTGFzdENpcmNsZV9BekFsdCAhPT0gbnVsbCAmJiB0aGlzLkxhc3RDaXJjbGVfQXpBbHQgIT09IHVuZGVmaW5lZCkgewogICAgICAgIGdsTGF5ZXIucmVtb3ZlKHRoaXMuTGFzdENpcmNsZV9BekFsdCk7CiAgICAgIH0KICAgICAgdGhpcy5MYXN0Q2lyY2xlX0F6QWx0ID0gdGhpcy5BZGRNYXJrQ2lyY2xlKHRoaXMuJHN0ZWwsIGdsTGF5ZXIsIDQsICdDdXJyZW50Jyk7CiAgICAgIG1tID0gdGhpcy5MYXN0Q2lyY2xlX0F6QWx0LnBvczsKICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZShBekFsdC5Bel9kZWdyZWUsIEF6QWx0LkFsdF9kZWdyZWUsIG1tKTsKICAgICAgdGhpcy5MYXN0Q2lyY2xlX0F6QWx0LnBvcyA9IG1tOwogICAgICB0aGlzLkxhc3RDaXJjbGVfQXpBbHQuY29sb3IgPSBbMCwgMSwgMSwgMC4yNV07CiAgICAgIGNvbnNvbGUubG9nKCJBekFsdF9WdWUgY2lyY2xlIGNvb3JkaW5hdGVzOiIgKyBtbSk7CgogICAgICBjb25zb2xlLmxvZygiQXpBbHRfVnVlIGNpcmNsZSB4OiIgKyBtbVswXSk7CiAgICAgIGNvbnNvbGUubG9nKCJBekFsdF9WdWUgY2lyY2xlIHk6IiArIG1tWzFdKTsKICAgICAgY29uc29sZS5sb2coIkF6QWx0X1Z1ZSBjaXJjbGUgejoiICsgbW1bMl0pOwoKICAgICAgdGhpcy5DdXJyZW50X0F6QWx0ID0gdGhpcy5nZXRDaWVjbGVBekFsdCh0aGlzLkxhc3RDaXJjbGVfQXpBbHQpOwogICAgICBjb25zb2xlLmxvZygiQ3VycmVudCBBekFsdDoiLCB0aGlzLkN1cnJlbnRfQXpBbHQuQXpfZGVncmVlLCB0aGlzLkN1cnJlbnRfQXpBbHQuQWx0X2RlZ3JlZSk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2hvd0N1cnJlbnRBekFsdFRleHQnLCB0aGlzLkN1cnJlbnRfQXpBbHQuQXpfZGVncmVlLCB0aGlzLkN1cnJlbnRfQXpBbHQuQWx0X2RlZ3JlZSk7CiAgICB9LAoKCiAgICBDYWxjdWxhdGlvblBvbGFyUG9pbnQoY29vcmRpbmF0ZSkgewogICAgICB0aGlzLkNhcnRlc2lhbkxpc3QucHVzaChjb29yZGluYXRlKTsKCiAgICAgIGlmICh0aGlzLkNhcnRlc2lhbkxpc3QubGVuZ3RoIDwgMykgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdIaWRlU2luZ2xlU29sdmVCdG4nKTsKCiAgICAgIC8vIOiOt+WPluS4ieS4queCueeahOWdkOaghwogICAgICBjb25zdCBwMSA9IHRoaXMuQ2FydGVzaWFuTGlzdFswXTsKICAgICAgY29uc3QgcDIgPSB0aGlzLkNhcnRlc2lhbkxpc3RbMV07CiAgICAgIGNvbnN0IHAzID0gdGhpcy5DYXJ0ZXNpYW5MaXN0WzJdOwoKICAgICAgLy8g6K6h566X5Lik5Liq5ZCR6YePCiAgICAgIGNvbnN0IHYxID0gWwogICAgICAgIHAyWzBdIC0gcDFbMF0sCiAgICAgICAgcDJbMV0gLSBwMVsxXSwKICAgICAgICBwMlsyXSAtIHAxWzJdCiAgICAgIF07CgogICAgICBjb25zdCB2MiA9IFsKICAgICAgICBwM1swXSAtIHAxWzBdLAogICAgICAgIHAzWzFdIC0gcDFbMV0sCiAgICAgICAgcDNbMl0gLSBwMVsyXQogICAgICBdOwoKICAgICAgLy8g6K6h566X5rOV5ZCR6YePCiAgICAgIGNvbnN0IG5vcm1hbCA9IFsKICAgICAgICB2MVsxXSAqIHYyWzJdIC0gdjFbMl0gKiB2MlsxXSwKICAgICAgICB2MVsyXSAqIHYyWzBdIC0gdjFbMF0gKiB2MlsyXSwKICAgICAgICB2MVswXSAqIHYyWzFdIC0gdjFbMV0gKiB2MlswXQogICAgICBdOwoKICAgICAgLy8g6K6h566X5rOV5ZCR6YeP55qE6ZW/5bqmCiAgICAgIGNvbnN0IG5vcm1hbExlbmd0aCA9IE1hdGguc3FydChub3JtYWxbMF0gKiogMiArIG5vcm1hbFsxXSAqKiAyICsgbm9ybWFsWzJdICoqIDIpOwoKICAgICAgLy8g5b2S5LiA5YyW5rOV5ZCR6YePCiAgICAgIGNvbnN0IHVuaXROb3JtYWwgPSBbCiAgICAgICAgbm9ybWFsWzBdIC8gbm9ybWFsTGVuZ3RoLAogICAgICAgIG5vcm1hbFsxXSAvIG5vcm1hbExlbmd0aCwKICAgICAgICBub3JtYWxbMl0gLyBub3JtYWxMZW5ndGgKICAgICAgXTsKCiAgICAgIC8vIOWBh+iuvueQg+eahOWNiuW+hOS4unLvvIzlnIblv4PkuLooMCwgMCwgMCkKICAgICAgY29uc3QgciA9IDE7IC8vIOagueaNruS9oOeahOWunumZheaDheWGteiwg+aVtAoKICAgICAgLy8g6K6h566X5LiO55CD6Z2i55qE5Lqk54K5CiAgICAgIGNvbnN0IGludGVyc2VjdGlvbjEgPSBbCiAgICAgICAgdW5pdE5vcm1hbFswXSAqIHIsCiAgICAgICAgdW5pdE5vcm1hbFsxXSAqIHIsCiAgICAgICAgdW5pdE5vcm1hbFsyXSAqIHIKICAgICAgXTsKCiAgICAgIGNvbnN0IGludGVyc2VjdGlvbjIgPSBbCiAgICAgICAgLXVuaXROb3JtYWxbMF0gKiByLAogICAgICAgIC11bml0Tm9ybWFsWzFdICogciwKICAgICAgICAtdW5pdE5vcm1hbFsyXSAqIHIKICAgICAgXTsKCiAgICAgIGNvbnNvbGUubG9nKCdJbnRlcnNlY3Rpb24gUG9pbnRzOicsIGludGVyc2VjdGlvbjEsIGludGVyc2VjdGlvbjIpOwoKICAgICAgLy8g6YCJ5oup56a7KDAsMCwxKeabtOi/keeahOS6pOeCuQogICAgICBjb25zdCBjbG9zZXJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24xWzJdID4gMCA/IGludGVyc2VjdGlvbjEgOiBpbnRlcnNlY3Rpb24yOwoKICAgICAgbGV0IE1hcmtDaXJjbGVfRmFrZVBvbGFyUG9pbnQgPSB0aGlzLkFkZE1hcmtDaXJjbGUodGhpcy4kc3RlbCwgZ2xMYXllciwgNCwgIkZha2VQb2xhclBvaW50Iik7CiAgICAgIGxldCBtbSA9IE1hcmtDaXJjbGVfRmFrZVBvbGFyUG9pbnQucG9zOwogICAgICBtbVswXSA9IGNsb3NlckludGVyc2VjdGlvblswXTsKICAgICAgbW1bMV0gPSBjbG9zZXJJbnRlcnNlY3Rpb25bMV07CiAgICAgIG1tWzJdID0gY2xvc2VySW50ZXJzZWN0aW9uWzJdOwogICAgICBNYXJrQ2lyY2xlX0Zha2VQb2xhclBvaW50LnBvcyA9IG1tOwogICAgICBjb25zb2xlLmxvZygiRmFrZVBvbGFyUG9pbnQgY2lyY2xlIGNvb3JkaW5hdGVzOiIgKyBtbSk7CgogICAgICBjb25zdCBBekFsdF9GYWtlUG9sYXJQb2ludCA9IHRoaXMuZ2V0Q2llY2xlQXpBbHQoTWFya0NpcmNsZV9GYWtlUG9sYXJQb2ludCk7CgogICAgICBjb25zb2xlLmxvZygiRmFrZSBQb2xhciBQb2ludCBBekFsdDoiLCBBekFsdF9GYWtlUG9sYXJQb2ludC5Bel9kZWdyZWUsICcsJywgQXpBbHRfRmFrZVBvbGFyUG9pbnQuQWx0X2RlZ3JlZSk7CgogICAgICB0aGlzLkNpcmNsZXMucHVzaChNYXJrQ2lyY2xlX0Zha2VQb2xhclBvaW50KTsKCiAgICAgIGxldCBBekFsdF9Qb2xhclBvaW50ID0gewogICAgICAgIEF6X2RlZ3JlZTogMCwKICAgICAgICBBbHRfZGVncmVlOiB0aGlzLlBvbGFyUG9pbnRfQWx0aXR1ZGUKICAgICAgfTsKCiAgICAgIC8vIGNvbnNvbGUubG9nKCJSZWFsIFBvbGFyIFBvaW50IEF6QWx0OiIsIEF6QWx0X1BvbGFyUG9pbnQuQXpfZGVncmVlLCAnLCcsIEF6QWx0X1BvbGFyUG9pbnQuQWx0X2RlZ3JlZSk7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1JlYWwgUG9sYXIgUG9pbnQgQXpBbHQ6JyArIEF6QWx0X1BvbGFyUG9pbnQuQXpfZGVncmVlICsgJywnICsgQXpBbHRfUG9sYXJQb2ludC5BbHRfZGVncmVlLCAnaW5mbycpOwogICAgICAvLyBjb25zb2xlLmxvZygiTGFzdCBQb2ludCBBekFsdDoiLCB0aGlzLkxhc3RQb2ludF9BekFsdC5Bel9kZWdyZWUsIHRoaXMuTGFzdFBvaW50X0F6QWx0LkFsdF9kZWdyZWUpOwogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCdMYXN0IFBvaW50IEF6QWx0OicgKyB0aGlzLkxhc3RQb2ludF9BekFsdC5Bel9kZWdyZWUgKyAnLCcgKyB0aGlzLkxhc3RQb2ludF9BekFsdC5BbHRfZGVncmVlLCAnaW5mbycpOwoKICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCgogICAgICAvLyAvLyDlsIbnkIPlnZDmoIfovazmjaLkuLrnrJvljaHlsJTlnZDmoIcKICAgICAgLy8gbGV0IGZha2VQb2xhclBvaW50ID0gdGhpcy5zcGhlcmljYWxUb0NhcnRlc2lhbihBekFsdF9GYWtlUG9sYXJQb2ludC5Bel9kZWdyZWUsIEF6QWx0X0Zha2VQb2xhclBvaW50LkFsdF9kZWdyZWUpOwogICAgICAvLyBsZXQgcG9sYXJQb2ludCA9IHRoaXMuc3BoZXJpY2FsVG9DYXJ0ZXNpYW4oQXpBbHRfUG9sYXJQb2ludC5Bel9kZWdyZWUsIEF6QWx0X1BvbGFyUG9pbnQuQWx0X2RlZ3JlZSk7CiAgICAgIC8vIGxldCBsYXN0UG9pbnQgPSB0aGlzLnNwaGVyaWNhbFRvQ2FydGVzaWFuKHRoaXMuTGFzdFBvaW50X0F6QWx0LkF6X2RlZ3JlZSwgdGhpcy5MYXN0UG9pbnRfQXpBbHQuQWx0X2RlZ3JlZSk7CgogICAgICAvLyAvLyDorqHnrpfml4vovazlm5vlhYPmlbAKICAgICAgLy8gbGV0IHF1YXRlcm5pb24gPSB0aGlzLmNvbXB1dGVRdWF0ZXJuaW9uKGZha2VQb2xhclBvaW50LCBwb2xhclBvaW50KTsKCiAgICAgIC8vIC8vIOW6lOeUqOaXi+i9rAogICAgICAvLyBsZXQgZm91cnRoUG9pbnQgPSB0aGlzLmFwcGx5UXVhdGVybmlvbihsYXN0UG9pbnQsIHF1YXRlcm5pb24pOwoKICAgICAgLy8gLy8g5bCG57uT5p6c6L2s5o2i5Zue55CD5Z2Q5qCHCiAgICAgIC8vIGxldCBmb3VydGhQb2ludEF6QWx0ID0gdGhpcy5jYXJ0ZXNpYW5Ub1NwaGVyaWNhbChmb3VydGhQb2ludCk7CiAgICAgIC8vIGNvbnNvbGUubG9nKCJGb3VydGggUG9pbnQgQXpBbHQ6IiwgZm91cnRoUG9pbnRBekFsdC5Bel9kZWdyZWUsICcsJywgZm91cnRoUG9pbnRBekFsdC5BbHRfZGVncmVlKTsKCiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwoKICAgICAgLy8g6K6h566X6KeS5bqm5beu5YC877yM6ICD6JmR6KeS5bqm55qE5b6q546v5oCn6LSoCiAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUFuZ2xlRGlmZmVyZW5jZShhbmdsZTEsIGFuZ2xlMikgewogICAgICAgIGxldCBkaWZmZXJlbmNlID0gYW5nbGUyIC0gYW5nbGUxOwogICAgICAgIHdoaWxlIChkaWZmZXJlbmNlID4gMTgwKSBkaWZmZXJlbmNlIC09IDM2MDsKICAgICAgICB3aGlsZSAoZGlmZmVyZW5jZSA8IC0xODApIGRpZmZlcmVuY2UgKz0gMzYwOwogICAgICAgIHJldHVybiBkaWZmZXJlbmNlOwogICAgICB9CgogICAgICBsZXQgYXppbXV0aERpZmZlcmVuY2UgPSBjYWxjdWxhdGVBbmdsZURpZmZlcmVuY2UoQXpBbHRfRmFrZVBvbGFyUG9pbnQuQXpfZGVncmVlLCBBekFsdF9Qb2xhclBvaW50LkF6X2RlZ3JlZSk7CiAgICAgIGxldCBhbHRpdHVkZURpZmZlcmVuY2UgPSBBekFsdF9Qb2xhclBvaW50LkFsdF9kZWdyZWUgLSBBekFsdF9GYWtlUG9sYXJQb2ludC5BbHRfZGVncmVlOwoKICAgICAgLy8g5bqU55So5beu5YC85YiwTGFzdFBvaW50CiAgICAgIGxldCBmb3VydGhQb2ludEF6QWx0ID0gewogICAgICAgIEF6X2RlZ3JlZTogdGhpcy5MYXN0UG9pbnRfQXpBbHQuQXpfZGVncmVlICsgYXppbXV0aERpZmZlcmVuY2UsCiAgICAgICAgQWx0X2RlZ3JlZTogdGhpcy5MYXN0UG9pbnRfQXpBbHQuQWx0X2RlZ3JlZSArIGFsdGl0dWRlRGlmZmVyZW5jZQogICAgICB9OwoKICAgICAgLy8g56Gu5L+d5pa55L2N6KeS5ZyoMOWIsDM2MOW6puS5i+mXtAogICAgICBmb3VydGhQb2ludEF6QWx0LkF6X2RlZ3JlZSA9IChmb3VydGhQb2ludEF6QWx0LkF6X2RlZ3JlZSArIDM2MCkgJSAzNjA7CgogICAgICAvLyDnoa7kv53pq5jluqbop5LlnKgtOTDliLA5MOW6puS5i+mXtAogICAgICBmb3VydGhQb2ludEF6QWx0LkFsdF9kZWdyZWUgPSBNYXRoLm1heChNYXRoLm1pbihmb3VydGhQb2ludEF6QWx0LkFsdF9kZWdyZWUsIDkwKSwgLTkwKTsKCiAgICAgIGNvbnNvbGUubG9nKCJGb3VydGggUG9pbnQgQXpBbHQ6IiwgZm91cnRoUG9pbnRBekFsdC5Bel9kZWdyZWUsICcsJywgZm91cnRoUG9pbnRBekFsdC5BbHRfZGVncmVlKTsKCiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnU2hvd0F6QWx0VGV4dCcsIGF6aW11dGhEaWZmZXJlbmNlLCBhbHRpdHVkZURpZmZlcmVuY2UsIGZvdXJ0aFBvaW50QXpBbHQuQXpfZGVncmVlLCBmb3VydGhQb2ludEF6QWx0LkFsdF9kZWdyZWUpOwoKICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCgogICAgICAvLyDlsIbop5LluqbovazmjaLkuLrlvKfluqYKICAgICAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7CiAgICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwOwogICAgICB9CgogICAgICAvLyDlsIbnkIPlnZDmoIfovazmjaLkuLrnrJvljaHlsJTlnZDmoIcKICAgICAgZnVuY3Rpb24gc3BoZXJpY2FsVG9DYXJ0ZXNpYW4oYXppbXV0aCwgYWx0aXR1ZGUpIHsKICAgICAgICBsZXQgYXogPSBkZWdyZWVzVG9SYWRpYW5zKGF6aW11dGgpOwogICAgICAgIGxldCBhbHQgPSBkZWdyZWVzVG9SYWRpYW5zKGFsdGl0dWRlKTsKICAgICAgICBsZXQgeCA9IE1hdGguY29zKGFsdCkgKiBNYXRoLmNvcyhheik7CiAgICAgICAgbGV0IHkgPSBNYXRoLmNvcyhhbHQpICogTWF0aC5zaW4oYXopOwogICAgICAgIGxldCB6ID0gTWF0aC5zaW4oYWx0KTsKICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB6OiB6IH07CiAgICAgIH0KCiAgICAgIC8vIOWwhuesrOWbm+S4queCuei9rOaNouS4uuesm+WNoeWwlOWdkOaghwogICAgICBsZXQgZm91cnRoUG9pbnRDYXJ0ZXNpYW4gPSBzcGhlcmljYWxUb0NhcnRlc2lhbihmb3VydGhQb2ludEF6QWx0LkF6X2RlZ3JlZSwgZm91cnRoUG9pbnRBekFsdC5BbHRfZGVncmVlKTsKICAgICAgY29uc29sZS5sb2coIkZvdXJ0aCBQb2ludCBDYXJ0ZXNpYW46IiwgZm91cnRoUG9pbnRDYXJ0ZXNpYW4ueCwgJywnLCBmb3VydGhQb2ludENhcnRlc2lhbi55LCAnLCcsIGZvdXJ0aFBvaW50Q2FydGVzaWFuLnopOwoKICAgICAgbGV0IE1hcmtDaXJjbGVfZm91cnRoUG9pbnQgPSB0aGlzLkFkZE1hcmtDaXJjbGUodGhpcy4kc3RlbCwgZ2xMYXllciwgNCwgIlRhcmdldCBQb2ludCIpOwogICAgICBtbSA9IE1hcmtDaXJjbGVfZm91cnRoUG9pbnQucG9zOwogICAgICBtbVswXSA9IGZvdXJ0aFBvaW50Q2FydGVzaWFuLng7CiAgICAgIG1tWzFdID0gZm91cnRoUG9pbnRDYXJ0ZXNpYW4ueTsKICAgICAgbW1bMl0gPSBmb3VydGhQb2ludENhcnRlc2lhbi56OwogICAgICBNYXJrQ2lyY2xlX2ZvdXJ0aFBvaW50LnBvcyA9IG1tOwogICAgICBNYXJrQ2lyY2xlX2ZvdXJ0aFBvaW50LmNvbG9yID0gWzEsIDAsIDAsIDAuMjVdOwoKICAgICAgdGhpcy5DaXJjbGVzLnB1c2goTWFya0NpcmNsZV9mb3VydGhQb2ludCk7CgogICAgICAvLyDmuIXnqbrliJfooajvvIzlh4blpIfkuIvmrKHorqHnrpcKICAgICAgdGhpcy5DYXJ0ZXNpYW5MaXN0ID0gW107CiAgICAgIHRoaXMuTWFya0NpcmNsZU51bSA9IDA7CiAgICB9LAoKICAgIC8vIOWwhuinkuW6pui9rOaNouS4uuW8p+W6pgogICAgZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7CiAgICAgIHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDsKICAgIH0sCgogICAgLy8g5bCG55CD5Z2Q5qCH6L2s5o2i5Li656yb5Y2h5bCU5Z2Q5qCHCiAgICBzcGhlcmljYWxUb0NhcnRlc2lhbihhemltdXRoLCBhbHRpdHVkZSkgewogICAgICBsZXQgYXogPSB0aGlzLmRlZ3JlZXNUb1JhZGlhbnMoYXppbXV0aCk7CiAgICAgIGxldCBhbHQgPSB0aGlzLmRlZ3JlZXNUb1JhZGlhbnMoYWx0aXR1ZGUpOwogICAgICBsZXQgeCA9IE1hdGguY29zKGFsdCkgKiBNYXRoLmNvcyhheik7CiAgICAgIGxldCB5ID0gTWF0aC5jb3MoYWx0KSAqIE1hdGguc2luKGF6KTsKICAgICAgbGV0IHogPSBNYXRoLnNpbihhbHQpOwogICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB6OiB6IH07CiAgICB9LAoKICAgIC8vIOiuoeeul+aXi+i9rOWbm+WFg+aVsAogICAgY29tcHV0ZVF1YXRlcm5pb24oZnJvbSwgdG8pIHsKICAgICAgbGV0IHcgPSBmcm9tLnggKiB0by54ICsgZnJvbS55ICogdG8ueSArIGZyb20ueiAqIHRvLnogKyAxOwogICAgICBsZXQgeCA9IGZyb20ueSAqIHRvLnogLSBmcm9tLnogKiB0by55OwogICAgICBsZXQgeSA9IGZyb20ueiAqIHRvLnggLSBmcm9tLnggKiB0by56OwogICAgICBsZXQgeiA9IGZyb20ueCAqIHRvLnkgLSBmcm9tLnkgKiB0by54OwoKICAgICAgbGV0IG5vcm0gPSBNYXRoLnNxcnQodyAqIHcgKyB4ICogeCArIHkgKiB5ICsgeiAqIHopOwogICAgICByZXR1cm4geyB3OiB3IC8gbm9ybSwgeDogeCAvIG5vcm0sIHk6IHkgLyBub3JtLCB6OiB6IC8gbm9ybSB9OwogICAgfSwKCiAgICAvLyDlupTnlKjlm5vlhYPmlbDml4vovawKICAgIGFwcGx5UXVhdGVybmlvbihwb2ludCwgcXVhdCkgewogICAgICBsZXQgeCA9IHF1YXQudyAqIHF1YXQudyAqIHBvaW50LnggKyAyICogcXVhdC55ICogcXVhdC53ICogcG9pbnQueiAtIDIgKiBxdWF0LnogKiBxdWF0LncgKiBwb2ludC55ICsgcXVhdC54ICogcXVhdC54ICogcG9pbnQueCArIDIgKiBxdWF0LnkgKiBxdWF0LnggKiBwb2ludC55ICsgMiAqIHF1YXQueiAqIHF1YXQueCAqIHBvaW50LnogLSBxdWF0LnogKiBxdWF0LnogKiBwb2ludC54IC0gcXVhdC55ICogcXVhdC55ICogcG9pbnQueDsKICAgICAgbGV0IHkgPSAyICogcXVhdC54ICogcXVhdC55ICogcG9pbnQueCArIHF1YXQueSAqIHF1YXQueSAqIHBvaW50LnkgKyAyICogcXVhdC56ICogcXVhdC55ICogcG9pbnQueiArIDIgKiBxdWF0LncgKiBxdWF0LnogKiBwb2ludC54IC0gcXVhdC56ICogcXVhdC56ICogcG9pbnQueSArIHF1YXQudyAqIHF1YXQudyAqIHBvaW50LnkgLSAyICogcXVhdC54ICogcXVhdC53ICogcG9pbnQueiAtIHF1YXQueCAqIHF1YXQueCAqIHBvaW50Lnk7CiAgICAgIGxldCB6ID0gMiAqIHF1YXQueCAqIHF1YXQueiAqIHBvaW50LnggKyAyICogcXVhdC55ICogcXVhdC56ICogcG9pbnQueSArIHF1YXQueiAqIHF1YXQueiAqIHBvaW50LnogLSAyICogcXVhdC53ICogcXVhdC55ICogcG9pbnQueCAtIHF1YXQueSAqIHF1YXQueSAqIHBvaW50LnogKyAyICogcXVhdC53ICogcXVhdC54ICogcG9pbnQueSAtIHF1YXQueCAqIHF1YXQueCAqIHBvaW50LnogKyBxdWF0LncgKiBxdWF0LncgKiBwb2ludC56OwogICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB6OiB6IH07CiAgICB9LAoKICAgIC8vIOWwhuesm+WNoeWwlOWdkOagh+i9rOaNouWbnueQg+WdkOaghwogICAgY2FydGVzaWFuVG9TcGhlcmljYWwoY2FydGVzaWFuKSB7CiAgICAgIGxldCByID0gTWF0aC5zcXJ0KGNhcnRlc2lhbi54ICoqIDIgKyBjYXJ0ZXNpYW4ueSAqKiAyICsgY2FydGVzaWFuLnogKiogMik7CiAgICAgIGxldCBhemltdXRoID0gTWF0aC5hdGFuMihjYXJ0ZXNpYW4ueSwgY2FydGVzaWFuLngpOwogICAgICBsZXQgYWx0aXR1ZGUgPSBNYXRoLmFzaW4oY2FydGVzaWFuLnogLyByKTsKICAgICAgcmV0dXJuIHsKICAgICAgICBBel9kZWdyZWU6IGF6aW11dGggKiAxODAgLyBNYXRoLlBJLAogICAgICAgIEFsdF9kZWdyZWU6IGFsdGl0dWRlICogMTgwIC8gTWF0aC5QSQogICAgICB9OwogICAgfSwKCiAgICBTb2x2ZUZvdk1hcmsoUmFEZWMpIHsKICAgICAgY29uc29sZS5sb2coJ1JhRGVjWzRdOicsIFJhRGVjKTsKCiAgICAgIC8vIGxldCByZWN0YW5nbGUgPSB0aGlzLkFkZE1hcmtSZWN0YW5nbGUodGhpcy4kc3RlbCwgZ2xMYXllciwgUmFEZWMpOwoKICAgICAgdGhpcy5DaXJjbGVzLnB1c2gocmVjdGFuZ2xlKTsKCiAgICB9LAoKICAgIENhbGlicmF0ZVBvbGFyQXhpcygpIHsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdDYWxpYnJhdGVQb2xhckF4aXNNb2RlJyk7CiAgICAgIC8vIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnU3RhcnRMb29wQ2FwdHVyZScpOwogICAgICB0aGlzLm5hdiA9IGZhbHNlOwogICAgfSwKCiAgICBSZWNhbGlicmF0ZVBvbGFyQXhpcygpIHsKICAgICAgLy8g5riF56m65YiX6KGo77yM5YeG5aSH5LiL5qyh6K6h566XCiAgICAgIHRoaXMuQ2FydGVzaWFuTGlzdCA9IFtdOwogICAgICB0aGlzLk1hcmtDaXJjbGVOdW0gPSAwOwogICAgICB0aGlzLlJlbW92ZUFsbENpcmNsZXMoKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdDbGVhclNsb3ZlUmVzdWx0TGlzdCcpOwogICAgfSwKCgoKICAgIC8vIOS9v+eUqOaWsOeahOWkmui+ueW9ouaWueW8j+e7mOWItuagoeWHhueCuQogICAgZHJhd0NhbGlicmF0aW9uUG9pbnRQb2x5Z29uKGNvb3JkaW5hdGVzLCBjb2xvciwgbmFtZSkgewogICAgICBjb25zb2xlLmxvZyhg57uY5Yi25qCh5YeG54K55aSa6L655b2iOiAke25hbWV9YCwgY29vcmRpbmF0ZXMpOwoKICAgICAgdHJ5IHsKICAgICAgICAvLyDpqozor4HovpPlhaXlj4LmlbAKICAgICAgICBpZiAoIWNvb3JkaW5hdGVzIHx8ICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzKSkgewogICAgICAgICAgY29uc29sZS5lcnJvcign5qCh5YeG54K55Z2Q5qCH5b+F6aG75piv5pWw57uEJyk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoICE9PSA1KSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKGDmoKHlh4bngrnlnZDmoIflv4XpobvmmK815Liq54K577yM5b2T5YmN5pyJJHtjb29yZGluYXRlcy5sZW5ndGh95Liq54K5YCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICAvLyDpqozor4Hmr4/kuKrlnZDmoIfngrkKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBjb29yZCA9IGNvb3JkaW5hdGVzW2ldOwogICAgICAgICAgaWYgKCFjb29yZCB8fCB0eXBlb2YgY29vcmQucmEgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjb29yZC5kZWMgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOagoeWHhueCueWdkOaghyR7aX3moLzlvI/plJnor6/vvJpgLCBjb29yZCk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZENvb3JkaW5hdGUoY29vcmQucmEpIHx8ICF0aGlzLmlzVmFsaWRDb29yZGluYXRlKGNvb3JkLmRlYykpIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihg5qCh5YeG54K55Z2Q5qCHJHtpfeWAvOaXoOaViO+8mmAsIGNvb3JkKTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8g5L2/55So5paw55qE5aSa6L655b2i57uY5Yi25pa55rOVCiAgICAgICAgbGV0IGNhbGlicmF0aW9uUG9seWdvbiA9IHRoaXMuQWRkRmllbGRPZlZpZXdQb2x5Z29uKAogICAgICAgICAgdGhpcy4kc3RlbCwKICAgICAgICAgIGdsTGF5ZXIsCiAgICAgICAgICBjb29yZGluYXRlcywKICAgICAgICAgIGNvbG9yLAogICAgICAgICAgbmFtZQogICAgICAgICk7CgogICAgICAgIGlmIChjYWxpYnJhdGlvblBvbHlnb24pIHsKICAgICAgICAgIC8vIOa3u+WKoOWIsOagoeWHhueCueaVsOe7hAogICAgICAgICAgaWYgKCF0aGlzLmNhbGlicmF0aW9uQ2lyY2xlcykgewogICAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uQ2lyY2xlcyA9IFtdOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5jYWxpYnJhdGlvbkNpcmNsZXMucHVzaChjYWxpYnJhdGlvblBvbHlnb24pOwoKICAgICAgICAgIGNvbnNvbGUubG9nKGDmoKHlh4bngrnlpJrovrnlvaLliJvlu7rmiJDlip86ICR7bmFtZX1gLCBjYWxpYnJhdGlvblBvbHlnb24pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKGDmoKHlh4bngrnlpJrovrnlvaLliJvlu7rlpLHotKU6ICR7bmFtZX1gKTsKICAgICAgICB9CgogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+e7mOWItuagoeWHhueCueWkmui+ueW9ouaXtuWHuumUmTonLCBlcnJvcik7CiAgICAgIH0KICAgIH0sCgogICAgLy8g5riF6Zmk5omA5pyJ5qCh5YeG54K5CiAgICBjbGVhckNhbGlicmF0aW9uUG9pbnRzKCkgewogICAgICBjb25zb2xlLmxvZygn5riF6Zmk5omA5pyJ5qCh5YeG54K5Jyk7CgogICAgICAvLyDnoa7kv53mlbDnu4TlrZjlnKgKICAgICAgaWYgKCF0aGlzLmNhbGlicmF0aW9uQ2lyY2xlcykgewogICAgICAgIHRoaXMuY2FsaWJyYXRpb25DaXJjbGVzID0gW107CiAgICAgIH0KICAgICAgaWYgKCF0aGlzLmFkanVzdG1lbnRDaXJjbGVzKSB7CiAgICAgICAgdGhpcy5hZGp1c3RtZW50Q2lyY2xlcyA9IFtdOwogICAgICB9CgogICAgICAvLyDmuIXpmaTmoKHlh4bngrkKICAgICAgaWYgKHRoaXMuY2FsaWJyYXRpb25DaXJjbGVzLmxlbmd0aCA+IDApIHsKICAgICAgICBjb25zb2xlLmxvZyhg5riF6ZmkICR7dGhpcy5jYWxpYnJhdGlvbkNpcmNsZXMubGVuZ3RofSDkuKrmoKHlh4bngrlgKTsKICAgICAgICB0aGlzLmNhbGlicmF0aW9uQ2lyY2xlcy5mb3JFYWNoKChjaXJjbGUsIGluZGV4KSA9PiB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoY2lyY2xlICYmIGdsTGF5ZXIpIHsKICAgICAgICAgICAgICBnbExheWVyLnJlbW92ZShjaXJjbGUpOwogICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDmiJDlip/muIXpmaTmoKHlh4bngrkgJHtpbmRleCArIDF9YCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2Fybihg5riF6Zmk5qCh5YeG54K5ICR7aW5kZXggKyAxfSDml7blh7rplJk6YCwgZXJyb3IpOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHRoaXMuY2FsaWJyYXRpb25DaXJjbGVzID0gW107CiAgICAgIH0KCiAgICAgIC8vIOa4hemZpOiwg+aVtOeCuQogICAgICBpZiAodGhpcy5hZGp1c3RtZW50Q2lyY2xlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc29sZS5sb2coYOa4hemZpCAke3RoaXMuYWRqdXN0bWVudENpcmNsZXMubGVuZ3RofSDkuKrosIPmlbTngrlgKTsKICAgICAgICB0aGlzLmFkanVzdG1lbnRDaXJjbGVzLmZvckVhY2goKGNpcmNsZSwgaW5kZXgpID0+IHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmIChjaXJjbGUgJiYgZ2xMYXllcikgewogICAgICAgICAgICAgIGdsTGF5ZXIucmVtb3ZlKGNpcmNsZSk7CiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOaIkOWKn+a4hemZpOiwg+aVtOeCuSAke2luZGV4ICsgMX1gKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgY29uc29sZS53YXJuKGDmuIXpmaTosIPmlbTngrkgJHtpbmRleCArIDF9IOaXtuWHuumUmTpgLCBlcnJvcik7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgdGhpcy5hZGp1c3RtZW50Q2lyY2xlcyA9IFtdOwogICAgICB9CgogICAgICAvLyDmuIXpmaTkuIrkuIDmrKHkvY3nva4KICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSBudWxsOwoKICAgICAgLy8g5riF6Zmk55uu5qCH54K5CiAgICAgIGlmICh0aGlzLnRhcmdldFBvaW50Q2lyY2xlKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChnbExheWVyKSB7CiAgICAgICAgICAgIGdsTGF5ZXIucmVtb3ZlKHRoaXMudGFyZ2V0UG9pbnRDaXJjbGUpOwogICAgICAgICAgICBjb25zb2xlLmxvZygn5oiQ5Yqf5riF6Zmk55uu5qCH54K5Jyk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnRhcmdldFBvaW50Q2lyY2xlID0gbnVsbDsKICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgY29uc29sZS53YXJuKCfmuIXpmaTnm67moIfngrnml7blh7rplJk6JywgZXJyb3IpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgY29uc29sZS5sb2coJ+aJgOacieagoeWHhuebuOWFs+WFg+e0oOa4hemZpOWujOaIkCcpOwogICAgfSwKCgogICAgLy8g5L2/55So5paw55qE5aSa6L655b2i5pa55byP57uY5Yi26LCD5pW054K5CiAgICAvLyDkvb/nlKjmlrDnmoTlpJrovrnlvaLmlrnlvI/nu5jliLbosIPmlbTngrnvvIjkuI3lnKjmraTlpITnlLvlnIbvvIkKICAgIGRyYXdBZGp1c3RtZW50UG9pbnRzUG9seWdvbihjdXJyZW50Q29vcmRpbmF0ZXMsIHRhcmdldENvb3JkaW5hdGVzLCBjdXJyZW50Q29sb3IsIHRhcmdldENvbG9yLCBpc1RpbWVyVXBkYXRlKSB7CiAgICAgIGlmIChpc1RpbWVyVXBkYXRlID09PSB1bmRlZmluZWQpIGlzVGltZXJVcGRhdGUgPSBmYWxzZTsKICAgICAgY29uc29sZS5sb2coJ+e7mOWItuiwg+aVtOeCueWkmui+ueW9oicsIHsgY3VycmVudENvb3JkaW5hdGVzLCB0YXJnZXRDb29yZGluYXRlcyB9KTsKCiAgICAgIHRyeSB7CiAgICAgICAgLy8gMSkg5riF6Zmk5LmL5YmN55qE6LCD5pW054K5CiAgICAgICAgaWYgKHRoaXMuYWRqdXN0bWVudENpcmNsZXMpIHsKICAgICAgICAgIHRoaXMuYWRqdXN0bWVudENpcmNsZXMuZm9yRWFjaChvYmogPT4gewogICAgICAgICAgICB0cnkgeyBnbExheWVyLnJlbW92ZShvYmopOyB9IGNhdGNoIChlKSB7IGNvbnNvbGUud2Fybign5riF6Zmk6LCD5pW054K55pe25Ye66ZSZOicsIGUpOyB9CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgdGhpcy5hZGp1c3RtZW50Q2lyY2xlcyA9IFtdOwoKICAgICAgICAvLyAyKSDnu5jliLblvZPliY3kvY3nva7op4blnLrlpJrovrnlvaIKICAgICAgICBpZiAoY3VycmVudENvb3JkaW5hdGVzICYmIEFycmF5LmlzQXJyYXkoY3VycmVudENvb3JkaW5hdGVzKSAmJiBjdXJyZW50Q29vcmRpbmF0ZXMubGVuZ3RoID09PSA1KSB7CiAgICAgICAgICBjb25zb2xlLmxvZygn57uY5Yi25b2T5YmN5L2N572u5aSa6L655b2iJyk7CiAgICAgICAgICBjb25zdCBjdXJyZW50UG9seWdvbiA9IHRoaXMuQWRkRmllbGRPZlZpZXdQb2x5Z29uKAogICAgICAgICAgICB0aGlzLiRzdGVsLAogICAgICAgICAgICBnbExheWVyLAogICAgICAgICAgICBjdXJyZW50Q29vcmRpbmF0ZXMsCiAgICAgICAgICAgIGN1cnJlbnRDb2xvciwKICAgICAgICAgICAgJ0N1cnJlbnQnCiAgICAgICAgICApOwogICAgICAgICAgaWYgKGN1cnJlbnRQb2x5Z29uKSB7CiAgICAgICAgICAgIHRoaXMuYWRqdXN0bWVudENpcmNsZXMucHVzaChjdXJyZW50UG9seWdvbik7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCflvZPliY3kvY3nva7lpJrovrnlvaLliJvlu7rmiJDlip8nKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+W9k+WJjeS9jee9ruWkmui+ueW9ouWIm+W7uuWksei0pScpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zb2xlLndhcm4oJ+W9k+WJjeS9jee9ruWdkOagh+aXoOaViO+8jOi3s+i/h+e7mOWIticpOwogICAgICAgIH0KCiAgICAgICAgLy8gMykg6KeG6KeS6L2s5ZCR77yI5Y+v6YCJ77yb5LiN5Yib5bu65ZyG77yJCiAgICAgICAgaWYgKCFpc1RpbWVyVXBkYXRlICYmIHRhcmdldENvb3JkaW5hdGVzICYmIEFycmF5LmlzQXJyYXkodGFyZ2V0Q29vcmRpbmF0ZXMpICYmIHRhcmdldENvb3JkaW5hdGVzLmxlbmd0aCA9PT0gNSkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgY29uc3QgY2VudGVyUmEgPSB0YXJnZXRDb29yZGluYXRlcy5yZWR1Y2UoKHMsIGMpID0+IHMgKyBjLnJhLCAwKSAvIHRhcmdldENvb3JkaW5hdGVzLmxlbmd0aDsKICAgICAgICAgICAgY29uc3QgY2VudGVyRGVjID0gdGFyZ2V0Q29vcmRpbmF0ZXMucmVkdWNlKChzLCBjKSA9PiBzICsgYy5kZWMsIDApIC8gdGFyZ2V0Q29vcmRpbmF0ZXMubGVuZ3RoOwogICAgICAgICAgICBjb25zb2xlLmxvZyhg6KeG6KeS6L2s5ZCR55uu5qCHOiBSQT0ke2NlbnRlclJhfSwgREVDPSR7Y2VudGVyRGVjfWApOwoKICAgICAgICAgICAgLy8g55So5Li05pe25a+56LGh5Y+q5YGa5oyH5ZCR77yM5LiN5Yqg5YWlIGxheWVyCiAgICAgICAgICAgIGNvbnN0IHRhcmdldE9iakNvbmZpZyA9IHsKICAgICAgICAgICAgICBpZDogJ3RlbXBfdGFyZ2V0XycgKyBEYXRlLm5vdygpLAogICAgICAgICAgICAgIG1vZGVsX2RhdGE6IHt9LAogICAgICAgICAgICAgIG5hbWVzOiBbJ1RhcmdldCBQb3NpdGlvbiddLAogICAgICAgICAgICAgIHR5cGVzOiBbJ1RlbXBvcmFyeSddLAogICAgICAgICAgICAgIG1vZGVsOiAndGVtcG9yYXJ5JwogICAgICAgICAgICB9OwogICAgICAgICAgICBjb25zdCB0YXJnZXRPYmogPSB0aGlzLiRzdGVsLmNyZWF0ZU9iaignY2lyY2xlJywgdGFyZ2V0T2JqQ29uZmlnKTsKICAgICAgICAgICAgbGV0IG1tID0gdGFyZ2V0T2JqLnBvczsKICAgICAgICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZShjZW50ZXJSYSwgY2VudGVyRGVjLCBtbSk7CiAgICAgICAgICAgIHRhcmdldE9iai5wb3MgPSBtbTsKICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRPYmoudXBkYXRlID09PSAnZnVuY3Rpb24nKSB0YXJnZXRPYmoudXBkYXRlKCk7CgogICAgICAgICAgICB0aGlzLiRzdGVsLnBvaW50QW5kTG9jayh0YXJnZXRPYmosIDEuMCk7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfop4bop5LovazlkJHlrozmiJAnKTsKCiAgICAgICAgICAgIC8vIOa4heeQhuS4tOaXtuWvueixoe+8iOacquWKoOWFpSBsYXllcu+8jOaXoOmcgCByZW1vdmXvvIkKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRyeSB7IC8qIG5vLW9wICovIH0gY2F0Y2ggKF8pIHsgfSB9LCAwKTsKICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+inhuinkui9rOWQkeWHuumUmTonLCBlcnJvcik7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCfnu5jliLbosIPmlbTngrnlpJrovrnlvaLml7blh7rplJk6JywgZXJyb3IpOwogICAgICB9CiAgICB9LAoKCiAgICAvLyDnu5jliLbnm67moIfngrnlnIblvaLvvIjlnZDmoIfvvJpSQS9EZWPvvIzljZXkvY3vvJrluqbvvIkKICAgIGRyYXdUYXJnZXRQb2ludENpcmNsZSh0YXJnZXRSYSwgdGFyZ2V0RGVjLCBjb2xvciwgbmFtZSwgdGV4dCwgY2xlYXJsYXN0KSB7CiAgICAgIGlmIChjbGVhcmxhc3QgPT09IHVuZGVmaW5lZCkgY2xlYXJsYXN0ID0gdHJ1ZTsgLy8g5YaF6YOo6K6+572u6buY6K6k5YC8CiAgICAgIGNvbnNvbGUubG9nKCfnu5jliLbnm67moIfngrnlnIblvaInLCB7IHRhcmdldFJhLCB0YXJnZXREZWMsIGNvbG9yIH0pOwoKICAgICAgdHJ5IHsKICAgICAgICAvLyAxKSDmoKHpqowKICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZENvb3JkaW5hdGUodGFyZ2V0UmEpIHx8ICF0aGlzLmlzVmFsaWRDb29yZGluYXRlKHRhcmdldERlYykpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGV4dCArICflnZDmoIfml6DmlYg6JywgeyB0YXJnZXRSYSwgdGFyZ2V0RGVjIH0pOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgLy8gMikg5riF6Zmk5LmL5YmN55qE55uu5qCH54K5CiAgICAgICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRDaXJjbGUgJiYgY2xlYXJsYXN0KSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoZ2xMYXllcikgewogICAgICAgICAgICAgIGdsTGF5ZXIucmVtb3ZlKHRoaXMudGFyZ2V0UG9pbnRDaXJjbGUpOwogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfmiJDlip/muIXpmaTkuYvliY3nmoQnICsgbmFtZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2Fybign5riF6Zmk5LmL5YmN55qEJyArIHRleHQgKyAn5pe25Ye66ZSZOicsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIDMpIOWIm+W7uuWchuWvueixoQogICAgICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuQWRkTWFya0NpcmNsZSh0aGlzLiRzdGVsLCBnbExheWVyLCA0LCBuYW1lKTsgLy8gZnJhbWU9NO+8mui1pOmBk+ezuwogICAgICAgIGlmICghY2lyY2xlKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKHRleHQgKyAn5ZyG5b2i5Yib5bu65aSx6LSlJyk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICAvLyA0KSDkvY3nva7vvIhSQS9EZWMg5bqmIOKGkiAzRCDljZXkvY3lkJHph4/vvIkKICAgICAgICBjb25zdCBtbSA9IGNpcmNsZS5wb3M7CiAgICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZSh0YXJnZXRSYSwgdGFyZ2V0RGVjLCBtbSk7CiAgICAgICAgY2lyY2xlLnBvcyA9IG1tOwoKICAgICAgICAvLyA1KSDmoLflvI8KICAgICAgICBpZiAoY29sb3IpIHsKICAgICAgICAgIGNvbnN0IHJnYiA9IHRoaXMuaGV4VG9SZ2IoY29sb3Iuc3Ryb2tlIHx8IGNvbG9yLmZpbGwgfHwgJyNGRjhDMDAnKTsKICAgICAgICAgIGNvbnN0IGFscGhhID0gKGNvbG9yLmZpbGxPcGFjaXR5IHx8IDAuMyk7CiAgICAgICAgICBjb25zdCBib3JkZXJBbHBoYSA9IChjb2xvci5zdHJva2VPcGFjaXR5IHx8IDEuMCk7CiAgICAgICAgICBjaXJjbGUuY29sb3IgPSBbcmdiLnIgLyAyNTUsIHJnYi5nIC8gMjU1LCByZ2IuYiAvIDI1NSwgYWxwaGFdOwogICAgICAgICAgY2lyY2xlLmJvcmRlcl9jb2xvciA9IFtyZ2IuciAvIDI1NSwgcmdiLmcgLyAyNTUsIHJnYi5iIC8gMjU1LCBib3JkZXJBbHBoYV07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNpcmNsZS5jb2xvciA9IFsxLCAwLjU1LCAwLCAwLjNdOwogICAgICAgICAgY2lyY2xlLmJvcmRlcl9jb2xvciA9IFsxLCAwLjU1LCAwLCAxXTsKICAgICAgICB9CiAgICAgICAgY29uc3Qgc2l6ZSA9IDAuMDI7CiAgICAgICAgY2lyY2xlLnNpemUgPSBbc2l6ZSwgc2l6ZV07CgogICAgICAgIC8vIDYpIOabtOaWsCAmIOS/neWtmOW8leeUqAogICAgICAgIGlmICh0eXBlb2YgY2lyY2xlLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykgY2lyY2xlLnVwZGF0ZSgpOwogICAgICAgIHRoaXMudGFyZ2V0UG9pbnRDaXJjbGUgPSBjaXJjbGU7CgogICAgICAgIGNvbnNvbGUubG9nKHRleHQgKyAn5ZyG5b2i5Yib5bu65oiQ5YqfJywgY2lyY2xlKTsKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCfnu5jliLYnICsgdGV4dCArICflnIblvaLml7blh7rplJk6JywgZXJyb3IpOwogICAgICB9CiAgICB9LAoKCiAgICAvLyDnu5jliLblgYfmnoHovbTlnIblvaIKICAgIERyYXdGYWtlUG9sYXJBeGlzQ2lyY2xlKHRhcmdldFJhLCB0YXJnZXREZWMsIGNvbG9yLCBuYW1lLCB0ZXh0KSB7CiAgICAgIGNvbnNvbGUubG9nKCfnu5jliLbnm67moIfngrnlnIblvaInLCB7IHRhcmdldFJhLCB0YXJnZXREZWMsIGNvbG9yIH0pOwoKICAgICAgdHJ5IHsKICAgICAgICAvLyDpqozor4HovpPlhaXlj4LmlbAKICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZENvb3JkaW5hdGUodGFyZ2V0UmEpIHx8ICF0aGlzLmlzVmFsaWRDb29yZGluYXRlKHRhcmdldERlYykpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGV4dCArICflnZDmoIfml6DmlYg6JywgeyB0YXJnZXRSYSwgdGFyZ2V0RGVjIH0pOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgLy8g5riF6Zmk5LmL5YmN55qE55uu5qCH54K5CiAgICAgICAgaWYgKHRoaXMuZmFrZVBvbGFyQXhpc0NpcmNsZSkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKGdsTGF5ZXIpIHsKICAgICAgICAgICAgICBnbExheWVyLnJlbW92ZSh0aGlzLmZha2VQb2xhckF4aXNDaXJjbGUpOwogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfmiJDlip/muIXpmaTkuYvliY3nmoQnICsgbmFtZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2Fybign5riF6Zmk5LmL5YmN55qEJyArIHRleHQgKyAn5pe25Ye66ZSZOicsIGVycm9yKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIOWIm+W7uuebruagh+eCueWchuW9ogogICAgICAgIGxldCB0YXJnZXRDaXJjbGUgPSB0aGlzLkFkZE1hcmtDaXJjbGUodGhpcy4kc3RlbCwgZ2xMYXllciwgNCwgbmFtZSk7CiAgICAgICAgaWYgKHRhcmdldENpcmNsZSkgewogICAgICAgICAgLy8g6K6+572u55uu5qCH54K55L2N572uCiAgICAgICAgICBsZXQgdGFyZ2V0TW0gPSB0YXJnZXRDaXJjbGUucG9zOwogICAgICAgICAgdGhpcy52ZWMzX2Zyb21fc3BoZSh0YXJnZXRSYSwgdGFyZ2V0RGVjLCB0YXJnZXRNbSk7CiAgICAgICAgICB0YXJnZXRDaXJjbGUucG9zID0gdGFyZ2V0TW07CgogICAgICAgICAgLy8g6K6+572u55uu5qCH54K56aKc6Imy5ZKM5qC35byPCiAgICAgICAgICBpZiAoY29sb3IpIHsKICAgICAgICAgICAgLy8g5bCG5Y2B5YWt6L+b5Yi26aKc6Imy6L2s5o2i5Li6UkdC5pWw57uECiAgICAgICAgICAgIGNvbnN0IHJnYiA9IHRoaXMuaGV4VG9SZ2IoY29sb3Iuc3Ryb2tlIHx8IGNvbG9yLmZpbGwgfHwgJyNGRjhDMDAnKTsKICAgICAgICAgICAgY29uc3QgYWxwaGEgPSAoY29sb3IuZmlsbE9wYWNpdHkgfHwgMC4zKTsKICAgICAgICAgICAgY29uc3QgYm9yZGVyQWxwaGEgPSAoY29sb3Iuc3Ryb2tlT3BhY2l0eSB8fCAxLjApOwoKICAgICAgICAgICAgdGFyZ2V0Q2lyY2xlLmNvbG9yID0gW3JnYi5yIC8gMjU1LCByZ2IuZyAvIDI1NSwgcmdiLmIgLyAyNTUsIGFscGhhXTsKICAgICAgICAgICAgdGFyZ2V0Q2lyY2xlLmJvcmRlcl9jb2xvciA9IFtyZ2IuciAvIDI1NSwgcmdiLmcgLyAyNTUsIHJnYi5iIC8gMjU1LCBib3JkZXJBbHBoYV07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyDpu5jorqTmqZnoibIKICAgICAgICAgICAgdGFyZ2V0Q2lyY2xlLmNvbG9yID0gWzEsIDAuNTUsIDAsIDAuM107ICAvLyDmqZnoibLvvIzljYrpgI/mmI4KICAgICAgICAgICAgdGFyZ2V0Q2lyY2xlLmJvcmRlcl9jb2xvciA9IFsxLCAwLjU1LCAwLCAxXTsgIC8vIOapmeiJsui+ueahhgogICAgICAgICAgfQoKICAgICAgICAgIC8vIOiuvue9ruebruagh+eCueWkp+WwjwogICAgICAgICAgY29uc3QgdGFyZ2V0U2l6ZSA9IDAuMDI7IC8vIOWbuuWumuWwj+WwuuWvuAogICAgICAgICAgdGFyZ2V0Q2lyY2xlLnNpemUgPSBbdGFyZ2V0U2l6ZSwgdGFyZ2V0U2l6ZV07CgogICAgICAgICAgLy8g5L+d5a2Y55uu5qCH54K55byV55So77yM55So5LqO5ZCO57ut5riF6ZmkCiAgICAgICAgICB0aGlzLmZha2VQb2xhckF4aXNDaXJjbGUgPSB0YXJnZXRDaXJjbGU7CgogICAgICAgICAgY29uc29sZS5sb2codGV4dCArICflnIblvaLliJvlu7rmiJDlip8nLCB0YXJnZXRDaXJjbGUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKHRleHQgKyAn5ZyG5b2i5Yib5bu65aSx6LSlJyk7CiAgICAgICAgfQoKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCfnu5jliLYnICsgdGV4dCArICflnIblvaLml7blh7rplJk6JywgZXJyb3IpOwogICAgICB9CiAgICB9LAoKICAgIFNob3dDb25maXJtRGlhbG9nKFRpdGxlLCBUZXh0LCBUb0RvKSB7CiAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTsKICAgICAgdGhpcy5uYXYgPSBmYWxzZTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdTaG93Q29uZmlybURpYWxvZycsIFRpdGxlLCBUZXh0LCBUb0RvKTsKICAgIH0sCgogICAgZGVjcmVtZW50KGl0ZW0pIHsKICAgICAgY29uc29sZS5sb2coJ2RlY3JlbWVudDonLCBpdGVtLnZhbHVlKTsKICAgICAgaWYgKGl0ZW0udmFsdWUgPiBpdGVtLmlucHV0TWluKSB7CiAgICAgICAgaXRlbS52YWx1ZSAtPSBpdGVtLmlucHV0U3RlcDsKICAgICAgfQogICAgfSwKCiAgICBpbmNyZW1lbnQoaXRlbSkgewogICAgICBjb25zb2xlLmxvZygnaW5jcmVtZW50OicsIGl0ZW0udmFsdWUpOwogICAgICBpZiAoaXRlbS52YWx1ZSA8IGl0ZW0uaW5wdXRNYXgpIHsKICAgICAgICBpdGVtLnZhbHVlICs9IGl0ZW0uaW5wdXRTdGVwOwogICAgICB9CiAgICB9LAoKICAgIFBvbGFyQXhpc01vZGUoYm9vbCkgewogICAgICB0aGlzLmlzUG9sYXJBeGlzTW9kZSA9IGJvb2w7CiAgICB9LAoKICAgIGhhbmRsZUd1aWRlckNhbnZhc0NsaWNrKGV2ZW50KSB7CiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuJHJlZnMuZ3VpZGVyQ2FudmFzOwogICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDsgLy8g54K55Ye75Z2Q5qCHWAogICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wOyAgLy8g54K55Ye75Z2Q5qCHWQogICAgICBjb25zb2xlLmxvZyhgQ2xpY2tlZCBhdDogKCR7eH0sICR7eX0pYCk7CiAgICAgIGNvbnN0IENhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7CiAgICAgIGNvbnN0IENhbnZhc0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdHdWlkZXJDYW52YXNDbGljazonICsgQ2FudmFzV2lkdGggKyAnOicgKyBDYW52YXNIZWlnaHQgKyAnOicgKyB4ICsgJzonICsgeSk7CiAgICB9LAogICAgY29ubmVjdERyaXZlcigpIHsKICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSB0cnVlOwogICAgICAvLyB0aGlzLmlzT3BlbkRldmljZVBhZ2UgPSBmYWxzZTsKICAgICAgdGhpcy5zdGFydExvYWRpbmcoKTsKICAgICAgY29uc3QgRGV2aWNlVHlwZSA9IHRoaXMuQ3VycmVudERyaXZlclR5cGU7CiAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIHRoaXMuZGV2aWNlcykgewogICAgICAgIGlmIChkZXZpY2UuZHJpdmVyVHlwZSA9PT0gRGV2aWNlVHlwZSAmJiBkZXZpY2UuaXNDb25uZWN0ZWQgPT0gZmFsc2UpIHsKICAgICAgICAgIGNvbnN0IERyaXZlck5hbWUgPSBkZXZpY2UuZHJpdmVyTmFtZTsKICAgICAgICAgIGlmIChEcml2ZXJOYW1lID09ICcnKSB7CiAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ05vIGRyaXZlciBzZWxlY3RlZCcsICd3YXJuaW5nJyk7CiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnQ29ubmVjdERyaXZlcjonICsgRHJpdmVyTmFtZSArICc6JyArIERldmljZVR5cGUpOwogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnU3RhcnQgQ29ubmVjdGluZyBkcml2ZXI6JyArIERldmljZVR5cGUgKyAnICcgKyBEcml2ZXJOYW1lLCAnaW5mbycpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIGNvbm5lY3REcml2ZXJTdWNjZXNzKGRldmljZXR5cGUpIHsKICAgICAgY29uc29sZS5sb2coJ2Nvbm5lY3REcml2ZXJTdWNjZXNzOicsIGRldmljZXR5cGUpOwogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCJjb25uZWN0RHJpdmVyU3VjY2VzczoiICsgZGV2aWNldHlwZSwgJ2luZm8nKTsKICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTsKICAgICAgaWYgKHRoaXMuZHJhd2VyXzIgPT0gdHJ1ZSkgewogICAgICAgIHRoaXMuZHJhd2VyXzIgPSBmYWxzZQogICAgICB9CgogICAgICB0aGlzLnN0b3BMb2FkaW5nKCk7CiAgICB9LAogICAgY29ubmVjdERyaXZlckZhaWxlZChtZXNzYWdlKSB7CiAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0RHJpdmVyRmFpbGVkOicsIG1lc3NhZ2UpOwogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCJjb25uZWN0RHJpdmVyRmFpbGVkOiIgKyBtZXNzYWdlLCAnZXJyb3InKTsKICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5zdG9wTG9hZGluZygpOwogICAgfSwKICAgIGRpc2Nvbm5lY3REcml2ZXIoKSB7CiAgICAgIGNvbnN0IERldmljZVR5cGUgPSB0aGlzLkN1cnJlbnREcml2ZXJUeXBlOwogICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiB0aGlzLmRldmljZXMpIHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09IERldmljZVR5cGUgJiYgZGV2aWNlLmlzQ29ubmVjdGVkKSB7CiAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ0Rpc2Nvbm5lY3REZXZpY2U6JyArIGRldmljZS5kZXZpY2UgKyAiOiIgKyBEZXZpY2VUeXBlKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBkaXNjb25uZWN0RHJpdmVyc3VjY2VzcyhkZXZpY2V0eXBlKSB7CiAgICAgIGNvbnNvbGUubG9nKCdkaXNjb25uZWN0RGV2aWNlc3VjY2VzczonLCBkZXZpY2V0eXBlKTsKICAgICAgdGhpcy5kcmF3ZXJfMiA9IGZhbHNlCiAgICAgIGlmIChkZXZpY2V0eXBlID09ICJhbGwiKSB7CiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnVnVlX0NvbW1hbmQnLCAnZGlzY29ubmVjdEFsbERldmljZScpOwogICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0Rpc2Nvbm5lY3QgQWxsIERldmljZScsICdpbmZvJyk7CiAgICAgICAgdGhpcy5oYXZlRGV2aWNlQ29ubmVjdCA9IGZhbHNlOwogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnTWFpbkNhbWVyYUNvbm5lY3RlZCcsIDApOwogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnTW91bnRDb25uZWN0ZWQnLCAwKTsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0NGV0Nvbm5lY3RlZCcsIDApOwogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnR3VpZGVyQ29ubmVjdGVkJywgMCk7CiAgICAgICAgdGhpcy5jbGVhckRldmljZUxpc3QoKTsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ2RlbGV0ZURldmljZVR5cGVBbGxvY2F0aW9uTGlzdCcsICdhbGwnKTsKICAgICAgICByZXR1cm47CiAgICAgIH07CgogICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiB0aGlzLmRldmljZXMpIHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09IGRldmljZXR5cGUgJiYgZGV2aWNlLmlzQ29ubmVjdGVkKSB7CiAgICAgICAgICBkZXZpY2UuaXNDb25uZWN0ZWQgPSBmYWxzZTsKICAgICAgICAgIGRldmljZS5pc2dldCA9IGZhbHNlOwogICAgICAgICAgZGV2aWNlLmRldmljZSA9IGRldmljZS5kcml2ZXJOYW1lOwogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiB0aGlzLlRvQmVDb25uZWN0RGV2aWNlKSB7CiAgICAgICAgaWYgKGRldmljZS5kcml2ZXJUeXBlID09PSBkZXZpY2V0eXBlKSB7CiAgICAgICAgICBkZXZpY2UuaXNDb25uZWN0ZWQgPSBmYWxzZTsKICAgICAgICAgIGRldmljZS5pc2dldCA9IGZhbHNlOwogICAgICAgICAgZGV2aWNlLmRldmljZSA9IGRldmljZS5kcml2ZXJOYW1lOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdkZWxldGVEZXZpY2VUeXBlQWxsb2NhdGlvbkxpc3QnLCBkZXZpY2V0eXBlKTsKICAgICAgaWYgKGRldmljZXR5cGUgPT0gIk1haW5DYW1lcmEiKSB7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNYWluQ2FtZXJhQ29ubmVjdGVkJywgMCk7CiAgICAgIH0gZWxzZSBpZiAoZGV2aWNldHlwZSA9PSAiTW91bnQiKSB7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudENvbm5lY3RlZCcsIDApOwogICAgICB9IGVsc2UgaWYgKGRldmljZXR5cGUgPT0gIkNGVyIpIHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0NGV0Nvbm5lY3RlZCcsIDApOwogICAgICB9IGVsc2UgaWYgKGRldmljZXR5cGUgPT0gIkd1aWRlciIpIHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0d1aWRlckNvbm5lY3RlZCcsIDApOwogICAgICB9CiAgICB9LAoKICAgIGRpc2Nvbm5lY3REcml2ZXJGYWlsKGRldmljZXR5cGUpIHsKICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3REZXZpY2VGYWlsOicsIGRldmljZXR5cGUpOwogICAgICB0aGlzLmRyYXdlcl8yID0gZmFsc2UKICAgICAgaWYgKGRldmljZXR5cGUgPT0gImFsbCIpIHsKICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdkaXNjb25uZWN0QWxsRGV2aWNlJyk7CiAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnRGlzY29ubmVjdCBBbGwgRGV2aWNlJywgJ2luZm8nKTsKICAgICAgICB0aGlzLmhhdmVEZXZpY2VDb25uZWN0ID0gZmFsc2U7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNYWluQ2FtZXJhQ29ubmVjdGVkJywgMCk7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdNb3VudENvbm5lY3RlZCcsIDApOwogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQ0ZXQ29ubmVjdGVkJywgMCk7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdHdWlkZXJDb25uZWN0ZWQnLCAwKTsKICAgICAgICB0aGlzLmNsZWFyRGV2aWNlTGlzdCgpOwogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnZGVsZXRlRGV2aWNlVHlwZUFsbG9jYXRpb25MaXN0JywgJ2FsbCcpOwogICAgICAgIHJldHVybjsKICAgICAgfTsKCiAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIHRoaXMuZGV2aWNlcykgewogICAgICAgIGlmIChkZXZpY2UuZHJpdmVyVHlwZSA9PT0gZGV2aWNldHlwZSAmJiBkZXZpY2UuaXNDb25uZWN0ZWQpIHsKICAgICAgICAgIGRldmljZS5pc0Nvbm5lY3RlZCA9IGZhbHNlOwogICAgICAgICAgZGV2aWNlLmlzZ2V0ID0gZmFsc2U7CiAgICAgICAgICBkZXZpY2UuZGV2aWNlID0gZGV2aWNlLmRyaXZlck5hbWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIHRoaXMuVG9CZUNvbm5lY3REZXZpY2UpIHsKICAgICAgICBpZiAoZGV2aWNlLmRyaXZlclR5cGUgPT09IGRldmljZXR5cGUpIHsKICAgICAgICAgIGRldmljZS5pc0Nvbm5lY3RlZCA9IGZhbHNlOwogICAgICAgICAgZGV2aWNlLmlzZ2V0ID0gZmFsc2U7CiAgICAgICAgICBkZXZpY2UuZGV2aWNlID0gZGV2aWNlLmRyaXZlck5hbWU7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLiRidXMuJGVtaXQoJ2RlbGV0ZURldmljZVR5cGVBbGxvY2F0aW9uTGlzdCcsIGRldmljZXR5cGUpOwogICAgICBpZiAoZGV2aWNldHlwZSA9PSAiTWFpbkNhbWVyYSIpIHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ01haW5DYW1lcmFDb25uZWN0ZWQnLCAwKTsKICAgICAgfSBlbHNlIGlmIChkZXZpY2V0eXBlID09ICJNb3VudCIpIHsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ01vdW50Q29ubmVjdGVkJywgMCk7CiAgICAgIH0gZWxzZSBpZiAoZGV2aWNldHlwZSA9PSAiQ0ZXIikgewogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQ0ZXQ29ubmVjdGVkJywgMCk7CiAgICAgIH0gZWxzZSBpZiAoZGV2aWNldHlwZSA9PSAiR3VpZGVyIikgewogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnR3VpZGVyQ29ubmVjdGVkJywgMCk7CiAgICAgIH0KICAgIH0sCiAgICBsb2FkU2VsZWN0ZWREcml2ZXJMaXN0KGRldmljZU9iamVjdCkgewogICAgICBjb25zb2xlLmxvZygnbG9hZFNlbGVjdGVkRHJpdmVyTGlzdDonLCBkZXZpY2VPYmplY3QpOwogICAgICBkZXZpY2VPYmplY3QuZm9yRWFjaChkZXZpY2UgPT4gewogICAgICAgIC8vIOWBh+iuvuS9oOaDs+imgeaJk+WNsOavj+S4quiuvuWkh+WvueixoeeahOmUruWAvOWvuQogICAgICAgIGZvciAoY29uc3QgW2RyaXZlclR5cGUsIGRyaXZlck5hbWVdIG9mIE9iamVjdC5lbnRyaWVzKGRldmljZSkpIHsKICAgICAgICAgIHRoaXMuZGV2aWNlcy5mb3JFYWNoKGRldmljZSA9PiB7CiAgICAgICAgICAgIGlmIChkZXZpY2UuZHJpdmVyVHlwZSA9PT0gZHJpdmVyVHlwZSAmJiBkZXZpY2UuaXNDb25uZWN0ZWQgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICBkZXZpY2UuZGV2aWNlID0gZHJpdmVyTmFtZTsKICAgICAgICAgICAgICBkZXZpY2UuZHJpdmVyTmFtZSA9IGRyaXZlck5hbWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9LAogICAgbG9hZEJpbmREZXZpY2VMaXN0KGRldmljZU9iamVjdCkgewogICAgICBjb25zb2xlLmxvZygnbG9hZEJpbmREZXZpY2VMaXN0OicsIGRldmljZU9iamVjdCk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnbG9hZEJpbmREZXZpY2VMaXN0JywgZGV2aWNlT2JqZWN0KTsKCiAgICB9LAogICAgbG9hZEJpbmREZXZpY2VUeXBlTGlzdChkZXZpY2VUeXBlT2JqZWN0KSB7CiAgICAgIGNvbnNvbGUubG9nKCdsb2FkQmluZERldmljZVR5cGVMaXN0OicsIGRldmljZVR5cGVPYmplY3QpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ2xvYWRCaW5kRGV2aWNlVHlwZUxpc3QnLCBkZXZpY2VUeXBlT2JqZWN0KTsKICAgICAgZGV2aWNlVHlwZU9iamVjdC5mb3JFYWNoKGRldmljZVR5cGUgPT4gewogICAgICAgIGNvbnN0IHsgVHlwZSwgRGV2aWNlTmFtZSwgRHJpdmVyTmFtZSwgaXNiaW5kIH0gPSBkZXZpY2VUeXBlOwogICAgICAgIHRoaXMudXBkYXRlRGV2aWNlc0Nvbm5lY3QoVHlwZSwgRGV2aWNlTmFtZSwgRHJpdmVyTmFtZSwgaXNiaW5kKTsKICAgICAgfSk7CiAgICB9LAogICAgdXBkYXRlU2VsZWN0ZWREcml2ZXIoZHJpdmVyVHlwZSkgewoKICAgICAgdGhpcy5zZWxlY3RlZERyaXZlciA9IG51bGw7CiAgICAgIHRoaXMuZGV2aWNlcy5mb3JFYWNoKGRldmljZSA9PiB7CiAgICAgICAgaWYgKGRldmljZS5kcml2ZXJUeXBlID09PSBkcml2ZXJUeXBlKSB7CiAgICAgICAgICB0aGlzLnNlbGVjdGVkRHJpdmVyID0gZGV2aWNlLmRyaXZlck5hbWUKICAgICAgICB9CiAgICAgIH0pOwogICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBkcml2ZXJzOicsIHRoaXMuc2VsZWN0ZWREcml2ZXIpOwogICAgfSwKICAgIHN0YXJ0TG9hZGluZygpIHsKICAgICAgdGhpcy5sb2FkaW5nRGV2aWNlU2VsZWN0aW9uID0gdHJ1ZTsKICAgIH0sCiAgICBzdG9wTG9hZGluZygpIHsKICAgICAgdGhpcy5sb2FkaW5nRGV2aWNlU2VsZWN0aW9uID0gZmFsc2U7CiAgICB9LAogICAgZGVsZXRlRGV2aWNlQWxsb2NhdGlvbkxpc3QoZGV2aWNlTmFtZSkgewogICAgICBjb25zb2xlLmxvZygnZGVsZXRlRGV2aWNlQWxsb2NhdGlvbkxpc3Q6JywgZGV2aWNlTmFtZSk7CiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnZGVsZXRlRGV2aWNlQWxsb2NhdGlvbkxpc3QnLCBkZXZpY2VOYW1lKTsKICAgIH0sCiAgICBVbkJpbmRpbmdEZXZpY2UodHlwZSwgbmFtZSwgZHJpdmVyTmFtZSkgewogICAgICBjb25zb2xlLmxvZygnVW5CaW5kaW5nRGV2aWNlOicsIHR5cGUsIG5hbWUsIGRyaXZlck5hbWUpOwogICAgICB0aGlzLnVwZGF0ZURldmljZXNDb25uZWN0KHR5cGUsIG5hbWUsIGRyaXZlck5hbWUsIGZhbHNlKTsKICAgIH0sCgogICAgZGlzcGxheUVycm9ySW1hZ2UoKSB7CiAgICAgIGNvbnNvbGUuZXJyb3IoImltYWdlIGlzIGVycm9yLCBsb2FkIGVycm9ySW1hZ2Uuc3ZnIik7CiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluQ2FtZXJhLWNhbnZhcycpOwogICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsKCiAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHsKICAgICAgICAvLyDojrflj5borr7lpIflg4/ntKDmr5QKICAgICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTsKCiAgICAgICAgLy8g6LCD5pW055S75biD5bC65a+45Lul6YCC5bqU6auY5riF5pi+56S6CiAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvOwogICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvOwogICAgICAgIGN0eC5zY2FsZShkZXZpY2VQaXhlbFJhdGlvLCBkZXZpY2VQaXhlbFJhdGlvKTsgLy8g57yp5pS+Y3R45Lul6YCC5bqU6auY5riF55S75biDCgogICAgICAgIC8vIOe7mOWItuWbvuWDjwogICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApOwogICAgICB9OwoKICAgICAgaW1hZ2Uub25lcnJvciA9ICgpID0+IHsKICAgICAgICBjb25zb2xlLmVycm9yKCJGYWlsZWQgdG8gbG9hZCBpbWFnZSBmcm9tICIgKyBpbWFnZS5zcmMpOwogICAgICAgIC8vIOWPr+S7peWcqOi/memHjOa3u+WKoOWkh+eUqOWbvuWDj+aIluWFtuS7lumUmeivr+WkhOeQhumAu+i+kQogICAgICB9OwoKICAgICAgLy8g56Gu5L+dRXJyb3JJbWFnZeaYr+acieaViOeahFVSTAogICAgICBpbWFnZS5zcmMgPSBFcnJvckltYWdlOyAvLyDor7fmm7/mjaLkuLrlrp7pmYXnmoTlm77lg4/ot6/lvoQKICAgIH0sCiAgICBoYW5kbGVFcnJvcihtZXNzYWdlLCBsb2NhdGlvbiwgZXJyb3IgPSBudWxsKSB7CiAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyb3IgPyBgJHttZXNzYWdlfSBhdCAke2xvY2F0aW9ufTogJHtlcnJvcn1gIDogYCR7bWVzc2FnZX0gYXQgJHtsb2NhdGlvbn1gOwogICAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnKTsKICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZyhlcnJvck1zZywgJ2Vycm9yJyk7CiAgICAgIHRoaXMuZGlzcGxheUVycm9ySW1hZ2UoKTsgLy8g5pi+56S66ZSZ6K+v5Zu+5YOPCiAgICB9LAogICAgc2hvd1NlbGVjdGRpc2Nvbm5lY3REcml2ZXIoZHJpdmVybmFtZSkgewogICAgICB0aGlzLnNob3dEaXNjb25uZWN0RGlhbG9nID0gdHJ1ZTsKICAgICAgdGhpcy5jdXJyZW50RGlzY29ubmVjdERyaXZlck5hbWUgPSBkcml2ZXJuYW1lOwogICAgfSwKICAgIGNvbmZpcm1EaXNjb25uZWN0KCkgewogICAgICB0aGlzLnNlbmRNZXNzYWdlKCdWdWVfQ29tbWFuZCcsICdkaXNjb25uZWN0U2VsZWN0RHJpdmVyOicgKyB0aGlzLmN1cnJlbnREaXNjb25uZWN0RHJpdmVyTmFtZSk7CiAgICAgIHRoaXMuc2hvd0Rpc2Nvbm5lY3REaWFsb2cgPSBmYWxzZTsKICAgIH0sCgogICAgLy8g5Li755S75biD54K55Ye75LqL5Lu2CiAgICBoYW5kbGVNYWluQ2FudmFzQ2xpY2soZXZlbnQpIHsKICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn6Kem5Y+R6byg5qCH54K55Ye75LqL5Lu2OicsICdpbmZvJyk7CiAgICAgIGlmICghdGhpcy5lbmFibGVNYWluQ2FudmFzQ2xpY2sgfHwgdGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuZHJhd0ltZ0RhdGEgPT0gbnVsbCkgcmV0dXJuOyAvLyDlpoLmnpznlLvluIPkuI3lj6/ngrnlh7vvvIzliJnkuI3lpITnkIbngrnlh7vkuovku7YKICAgICAgLy8gY29uc29sZS5sb2coJ+inpuWPkem8oOagh+eCueWHu+S6i+S7tjonLCBldmVudCk7CiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuJHJlZnMubWFpbkNhbnZhczsKICAgICAgaWYgKCFjYW52YXMpIHJldHVybjsgLy8g56Gu5L+dIGNhbnZhcyDlhYPntKDlrZjlnKgKICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsvLyDojrflj5YgY2FudmFzIOWFg+e0oOeahOi+ueeVjOefqeW9ogogICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDsKICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDsKICAgICAgY29uc29sZS5sb2coJ01vdXNlIGNsaWNrZWQgYXQ6JywgeCwgeSk7CiAgICAgIGlmICghdGhpcy5pc0ZvY3VzTG9vcFNob290aW5nKSB7CiAgICAgICAgLy8g5pyf5pyb5Lit5b+D77yI55S75biD5Z2Q5qCHIOKGkiDkvKDmhJ/lmajlg4/ntKDlnZDmoIfvvIkKICAgICAgICBjb25zdCBkZXNpcmVkQ2VudGVyWCA9ICh4IC8gd2luZG93LmlubmVyV2lkdGggKiB0aGlzLnZpc2libGVXaWR0aCkgKyB0aGlzLnZpc2libGVYIC0gdGhpcy52aXNpYmxlV2lkdGggLyAyOwogICAgICAgIGNvbnN0IGRlc2lyZWRDZW50ZXJZID0gKHkgLyB3aW5kb3cuaW5uZXJIZWlnaHQgKiB0aGlzLnZpc2libGVIZWlnaHQpICsgdGhpcy52aXNpYmxlWSAtIHRoaXMudmlzaWJsZUhlaWdodCAvIDI7CgogICAgICAgIC8vIFJPSSDovrnplb/vvIjlg4/ntKDvvIzlgbbmlbDljJbvvInvvIzmnaXmupDkuo7lm7rlrpogUmVkQm94U2lkZUxlbmd0aAogICAgICAgIGxldCBzaWRlID0gdGhpcy5SZWRCb3hTaWRlTGVuZ3RoIC8gdGhpcy5jYW1lcmFCaW47CiAgICAgICAgc2lkZSA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3Ioc2lkZSkpOwogICAgICAgIGlmIChzaWRlICUgMiAhPT0gMCkgc2lkZSArPSAxOyAvLyDlvLrliLblgbbmlbAKCiAgICAgICAgLy8g5bCGIFJPSSDlt6bkuIrop5LmjInkuK3lv4Plj43mjqjvvIzlubbnuqbmnZ/lnKjlm77lg4/ojIPlm7TlhoUKICAgICAgICBjb25zdCBoYWxmID0gc2lkZSAvIDI7CiAgICAgICAgY29uc3QgaW1nVyA9IHRoaXMubWFpbkNhbWVyYVNpemVYOwogICAgICAgIGNvbnN0IGltZ0ggPSB0aGlzLm1haW5DYW1lcmFTaXplWTsKCiAgICAgICAgbGV0IHJvaVggPSBkZXNpcmVkQ2VudGVyWCAtIGhhbGY7CiAgICAgICAgbGV0IHJvaVkgPSBkZXNpcmVkQ2VudGVyWSAtIGhhbGY7CgogICAgICAgIC8vIOi+ueeVjOe6puadnwogICAgICAgIGNvbnN0IG1heFggPSBNYXRoLm1heCgwLCBpbWdXIC0gc2lkZSk7CiAgICAgICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KDAsIGltZ0ggLSBzaWRlKTsKICAgICAgICByb2lYID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcm9pWCksIG1heFgpOwogICAgICAgIHJvaVkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByb2lZKSwgbWF4WSk7CgogICAgICAgIC8vIOWBtuaVsOWvuem9kOS9jee9rgogICAgICAgIHJvaVggPSBNYXRoLmZsb29yKHJvaVgpOwogICAgICAgIHJvaVkgPSBNYXRoLmZsb29yKHJvaVkpOwogICAgICAgIGlmIChyb2lYICUgMiAhPT0gMCkgcm9pWCArPSAxOwogICAgICAgIGlmIChyb2lZICUgMiAhPT0gMCkgcm9pWSArPSAxOwoKICAgICAgICB0aGlzLlJPSV94ID0gcm9pWDsKICAgICAgICB0aGlzLlJPSV95ID0gcm9pWTsKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ3NlbmRSZWRCb3hTdGF0ZTonICsgdGhpcy5SZWRCb3hTaWRlTGVuZ3RoICsgJzonICsgdGhpcy5ST0lfeCArICc6JyArIHRoaXMuUk9JX3kpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuc2VsZWN0U3RhclggPSAoKHggLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHRoaXMudmlzaWJsZVdpZHRoKSArIHRoaXMudmlzaWJsZVggLSB0aGlzLnZpc2libGVXaWR0aCAvIDIgLSB0aGlzLlJPSV94KSAqIHRoaXMuY2FtZXJhQmluOyAvLyDorqHnrpfpgInmi6nkvY3nva7nmoR45Z2Q5qCHCiAgICAgICAgdGhpcy5zZWxlY3RTdGFyWSA9ICgoeSAvIHdpbmRvdy5pbm5lckhlaWdodCAqIHRoaXMudmlzaWJsZUhlaWdodCkgKyB0aGlzLnZpc2libGVZIC0gdGhpcy52aXNpYmxlSGVpZ2h0IC8gMiAtIHRoaXMuUk9JX3kpICogdGhpcy5jYW1lcmFCaW47IC8vIOiuoeeul+mAieaLqeS9jee9rueahHnlnZDmoIcKCiAgICAgICAgaWYgKHRoaXMuc2VsZWN0U3RhclggPj0gMCAmJiB0aGlzLnNlbGVjdFN0YXJYIDwgdGhpcy5SZWRCb3hTaWRlTGVuZ3RoICYmCiAgICAgICAgICB0aGlzLnNlbGVjdFN0YXJZID49IDAgJiYgdGhpcy5zZWxlY3RTdGFyWSA8IHRoaXMuUmVkQm94U2lkZUxlbmd0aCkgewogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnU2VsZWN0IFN0YXIgaXMgaW4gUk9JJywgJ2luZm8nKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnU2VsZWN0IFN0YXIgaXMgbm90IGluIFJPSScsICdlcnJvcicpOwogICAgICAgICAgdGhpcy5zZWxlY3RTdGFyWCA9IC0xOwogICAgICAgICAgdGhpcy5zZWxlY3RTdGFyWSA9IC0xOwogICAgICAgIH0KICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ3NlbmRTZWxlY3RTdGFyczonICsgdGhpcy5zZWxlY3RTdGFyWCArICc6JyArIHRoaXMuc2VsZWN0U3RhclkpOwogICAgICB9CiAgICAgIHRoaXMuZHJhd0ltYWdlRGF0YSgpOwogICAgfSwKCiAgICAvLyDkuLvnlLvluIPmi5bliqgKICAgIGhhbmRsZU1vdXNlRG93bihldmVudCkgewogICAgICAvLyB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfop6blj5HpvKDmoIfmjInkuIvkuovku7Y6JywgJ2luZm8nKTsKICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZyB8fCB0aGlzLmRyYXdJbWdEYXRhID09IG51bGwpIHJldHVybjsKICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsKICAgICAgdGhpcy5zdGFydFggPSBldmVudC5jbGllbnRYOwogICAgICB0aGlzLnN0YXJ0WSA9IGV2ZW50LmNsaWVudFk7CiAgICAgIHRoaXMuY3VycmVudFggPSBldmVudC5jbGllbnRYOwogICAgICB0aGlzLmN1cnJlbnRZID0gZXZlbnQuY2xpZW50WTsKCiAgICAgIC8vIOiuvue9ruS4gOS4quWumuaXtuWZqO+8jOavjzEwMG1z5omn6KGM5LiA5qyh6byg5qCH56e75Yqo55qE6YC76L6RCiAgICAgIHRoaXMubW92ZUludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7CiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHJldHVybjsKCiAgICAgICAgY29uc3QgZHggPSB0aGlzLnN0YXJ0WCAtIHRoaXMuY3VycmVudFg7CiAgICAgICAgY29uc3QgZHkgPSB0aGlzLnN0YXJ0WSAtIHRoaXMuY3VycmVudFk7CiAgICAgICAgaWYgKGlzTmFOKGR4KSB8fCBpc05hTihkeSkpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgbGV0IG5ld1Zpc2libGVYID0gdGhpcy52aXNpYmxlWCArIGR4IC8gd2luZG93LmlubmVyV2lkdGggKiB0aGlzLnZpc2libGVXaWR0aDsKICAgICAgICBsZXQgbmV3VmlzaWJsZVkgPSB0aGlzLnZpc2libGVZICsgZHkgLyB3aW5kb3cuaW5uZXJIZWlnaHQgKiB0aGlzLnZpc2libGVIZWlnaHQ7CiAgICAgICAgaWYgKG5ld1Zpc2libGVYIDwgMCkgewogICAgICAgICAgbmV3VmlzaWJsZVggPSAwOwogICAgICAgIH0KICAgICAgICBpZiAobmV3VmlzaWJsZVkgPCAwKSB7CiAgICAgICAgICBuZXdWaXNpYmxlWSA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChuZXdWaXNpYmxlWCA+IHRoaXMubWFpbkNhbWVyYVNpemVYKSB7CiAgICAgICAgICBuZXdWaXNpYmxlWCA9IHRoaXMubWFpbkNhbWVyYVNpemVYOwogICAgICAgIH0KICAgICAgICBpZiAobmV3VmlzaWJsZVkgPiB0aGlzLm1haW5DYW1lcmFTaXplWSkgewogICAgICAgICAgbmV3VmlzaWJsZVkgPSB0aGlzLm1haW5DYW1lcmFTaXplWTsKICAgICAgICB9CgogICAgICAgIHRoaXMudmlzaWJsZVggPSBuZXdWaXNpYmxlWDsKICAgICAgICB0aGlzLnZpc2libGVZID0gbmV3VmlzaWJsZVk7CgogICAgICAgIHRoaXMuc3RhcnRYID0gdGhpcy5jdXJyZW50WDsKICAgICAgICB0aGlzLnN0YXJ0WSA9IHRoaXMuY3VycmVudFk7CiAgICAgICAgdGhpcy5kcmF3SW1hZ2VEYXRhKCk7CiAgICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn5ouW5Yqo5LqL5Lu2LOaLluWKqOi3neemuzonICsgZHggKyAnLCcgKyBkeSwgJ2luZm8nKTsKICAgICAgfSwgMTAwKTsKICAgIH0sCiAgICBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHsKICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn6Kem5Y+R6byg5qCH56e75Yqo5LqL5Lu2OicsICdpbmZvJyk7CiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSByZXR1cm47CiAgICAgIHRoaXMuY3VycmVudFggPSBldmVudC5jbGllbnRYOwogICAgICB0aGlzLmN1cnJlbnRZID0gZXZlbnQuY2xpZW50WTsKICAgIH0sCiAgICBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7CiAgICAgIC8vIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+inpuWPkem8oOagh+aKrOi1t+S6i+S7tjonLCAnaW5mbycpOwogICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsKCiAgICAgIC8vIOa4hemZpOWumuaXtuWZqAogICAgICBjbGVhckludGVydmFsKHRoaXMubW92ZUludGVydmFsSWQpOwogICAgICB0aGlzLm1vdmVJbnRlcnZhbElkID0gbnVsbDsKICAgIH0sCiAgICBoYW5kbGVXaGVlbChldmVudCkgewogICAgICAvLyB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfop6blj5HpvKDmoIfmu5rova7kuovku7Y6JywgJ2luZm8nKTsKICAgICAgaWYgKHRoaXMuZHJhd0ltZ0RhdGEgPT0gbnVsbCkgcmV0dXJuOwogICAgICBjb25zdCBzY2FsZUNoYW5nZSA9IGV2ZW50LmRlbHRhWSA+IDAgPyAwLjEgOiAtMC4xOyAvLyDmoLnmja7mu5rova7nmoTmu5rliqjmlrnlkJHvvIzorqHnrpfnvKnmlL7mr5TkvovnmoTlj5jljJbph48KICAgICAgbGV0IG5ld1NjYWxlID0gdGhpcy5zY2FsZSArIHNjYWxlQ2hhbmdlOyAvLyDmm7TmlrDnvKnmlL7mr5TkvosKICAgICAgaWYgKG5ld1NjYWxlIDwgMC4xKSB7CiAgICAgICAgbmV3U2NhbGUgPSAwLjE7CiAgICAgIH0KICAgICAgaWYgKG5ld1NjYWxlID4gMSkgewogICAgICAgIG5ld1NjYWxlID0gMTsKICAgICAgfQoKICAgICAgLy8g5aaC5p6c5bey57uP5pyJ5LiA5Liq5b6F5omn6KGM55qE57yp5pS+5pON5L2c77yM5YiZ55u05o6l6L+U5ZueCiAgICAgIGlmICh0aGlzLnBlbmRpbmdTY2FsZUNoYW5nZSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgLy8g5qCH6K6w5pyJ5LiA5Liq5b6F5omn6KGM55qE57yp5pS+5pON5L2cCiAgICAgIHRoaXMucGVuZGluZ1NjYWxlQ2hhbmdlID0gdHJ1ZTsKCiAgICAgIC8vIOS9v+eUqCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUg5p2l5o6n5Yi257yp5pS+5pON5L2c55qE5omn6KGM6aKR546HCiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7CiAgICAgICAgaWYgKG5ld1NjYWxlICE9IHRoaXMuc2NhbGUpIHsKICAgICAgICAgIHRoaXMuc2NhbGUgPSBuZXdTY2FsZTsgLy8g5pu05paw57yp5pS+5q+U5L6LCiAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3NldFNjYWxlJywgdGhpcy5zY2FsZSk7CiAgICAgICAgICB0aGlzLmRyYXdJbWFnZURhdGEoKTsKICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+e8qeaUvuavlOS+i+WPmOWMliznvKnmlL7mr5Tkvos6JyArIG5ld1NjYWxlLCAnaW5mbycpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfnvKnmlL7mr5TkvovmsqHmnInlj5jljJYs57yp5pS+5q+U5L6LOicgKyB0aGlzLnNjYWxlLCAnaW5mbycpOwogICAgICAgIH0KICAgICAgICB0aGlzLnBlbmRpbmdTY2FsZUNoYW5nZSA9IGZhbHNlOyAvLyDmuIXpmaTlvoXmiafooYznmoTnvKnmlL7mk43kvZzmoIforrAKICAgICAgfSk7CiAgICB9LAoKICAgIGhhbmRsZU1haW5DYW52YXNUb3VjaChldmVudCkgewogICAgICAvLyB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfop6blj5Hop6bmkbjkuovku7Y6JywgJ2luZm8nKTsKICAgICAgaWYgKCF0aGlzLmVuYWJsZU1haW5DYW52YXNDbGljayB8fCB0aGlzLmlzRHJhZ2dpbmcgfHwgdGhpcy5kcmF3SW1nRGF0YSA9PSBudWxsKSByZXR1cm47IC8vIOWmguaenOeUu+W4g+S4jeWPr+eCueWHu++8jOWImeS4jeWkhOeQhueCueWHu+S6i+S7tgogICAgICAvLyBjb25zb2xlLmxvZygn6Kem5Y+R6Kem5pG45LqL5Lu2OicsIGV2ZW50KTsKICAgICAgaWYgKCF0aGlzLmVuYWJsZU1haW5DYW52YXNDbGljayB8fCAhZXZlbnQudG91Y2hlcyB8fCBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOwogICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLm1haW5DYW52YXM7CiAgICAgIGlmICghY2FudmFzKSByZXR1cm47IC8vIOehruS/nSBjYW52YXMg5YWD57Sg5a2Y5ZyoCiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTsKICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsvLyDojrflj5YgY2FudmFzIOWFg+e0oOeahOi+ueeVjOefqeW9ogogICAgICBjb25zdCB4ID0gdG91Y2guY2xpZW50WCAtIHJlY3QubGVmdDsKICAgICAgY29uc3QgeSA9IHRvdWNoLmNsaWVudFkgLSByZWN0LnRvcDsKICAgICAgY29uc29sZS5sb2coJ1RvdWNoIGF0OicsIHgsIHkpOwogICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOy8vIOmYu+atoum7mOiupOS6i+S7tu+8jOWmgumhtemdoua7muWKqAogICAgICBpZiAoIXRoaXMuaXNGb2N1c0xvb3BTaG9vdGluZykgewogICAgICAgIC8vIOacn+acm+S4reW/g++8iOeUu+W4g+WdkOaghyDihpIg5Lyg5oSf5Zmo5YOP57Sg5Z2Q5qCH77yJCiAgICAgICAgY29uc3QgZGVzaXJlZENlbnRlclggPSAoeCAvIHdpbmRvdy5pbm5lcldpZHRoICogdGhpcy52aXNpYmxlV2lkdGgpICsgdGhpcy52aXNpYmxlWCAtIHRoaXMudmlzaWJsZVdpZHRoIC8gMjsKICAgICAgICBjb25zdCBkZXNpcmVkQ2VudGVyWSA9ICh5IC8gd2luZG93LmlubmVySGVpZ2h0ICogdGhpcy52aXNpYmxlSGVpZ2h0KSArIHRoaXMudmlzaWJsZVkgLSB0aGlzLnZpc2libGVIZWlnaHQgLyAyOwoKICAgICAgICAvLyBST0kg6L656ZW/77yI5YOP57Sg77yM5YG25pWw5YyW77yJ77yM5p2l5rqQ5LqO5Zu65a6aIFJlZEJveFNpZGVMZW5ndGgKICAgICAgICBsZXQgc2lkZSA9IHRoaXMuUmVkQm94U2lkZUxlbmd0aCAvIHRoaXMuY2FtZXJhQmluOwogICAgICAgIHNpZGUgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKHNpZGUpKTsKICAgICAgICBpZiAoc2lkZSAlIDIgIT09IDApIHNpZGUgKz0gMTsgLy8g5by65Yi25YG25pWwCgogICAgICAgIC8vIOWwhiBST0kg5bem5LiK6KeS5oyJ5Lit5b+D5Y+N5o6o77yM5bm257qm5p2f5Zyo5Zu+5YOP6IyD5Zu05YaFCiAgICAgICAgY29uc3QgaGFsZiA9IHNpZGUgLyAyOwogICAgICAgIGNvbnN0IGltZ1cgPSB0aGlzLm1haW5DYW1lcmFTaXplWDsKICAgICAgICBjb25zdCBpbWdIID0gdGhpcy5tYWluQ2FtZXJhU2l6ZVk7CgogICAgICAgIGxldCByb2lYID0gZGVzaXJlZENlbnRlclggLSBoYWxmOwogICAgICAgIGxldCByb2lZID0gZGVzaXJlZENlbnRlclkgLSBoYWxmOwoKICAgICAgICAvLyDovrnnlYznuqbmnZ8KICAgICAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgoMCwgaW1nVyAtIHNpZGUpOwogICAgICAgIGNvbnN0IG1heFkgPSBNYXRoLm1heCgwLCBpbWdIIC0gc2lkZSk7CiAgICAgICAgcm9pWCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJvaVgpLCBtYXhYKTsKICAgICAgICByb2lZID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcm9pWSksIG1heFkpOwoKICAgICAgICAvLyDlgbbmlbDlr7npvZDkvY3nva4KICAgICAgICByb2lYID0gTWF0aC5mbG9vcihyb2lYKTsKICAgICAgICByb2lZID0gTWF0aC5mbG9vcihyb2lZKTsKICAgICAgICBpZiAocm9pWCAlIDIgIT09IDApIHJvaVggKz0gMTsKICAgICAgICBpZiAocm9pWSAlIDIgIT09IDApIHJvaVkgKz0gMTsKCiAgICAgICAgdGhpcy5ST0lfeCA9IHJvaVg7CiAgICAgICAgdGhpcy5ST0lfeSA9IHJvaVk7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdzZW5kUmVkQm94U3RhdGU6JyArIHRoaXMuUmVkQm94U2lkZUxlbmd0aCArICc6JyArIHRoaXMuUk9JX3ggKyAnOicgKyB0aGlzLlJPSV95KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnNlbGVjdFN0YXJYID0gKCh4IC8gd2luZG93LmlubmVyV2lkdGggKiB0aGlzLnZpc2libGVXaWR0aCkgKyB0aGlzLnZpc2libGVYIC0gdGhpcy52aXNpYmxlV2lkdGggLyAyIC0gdGhpcy5ST0lfeCkgKiB0aGlzLmNhbWVyYUJpbjsgLy8g6K6h566X6YCJ5oup5L2N572u55qEeOWdkOaghwogICAgICAgIHRoaXMuc2VsZWN0U3RhclkgPSAoKHkgLyB3aW5kb3cuaW5uZXJIZWlnaHQgKiB0aGlzLnZpc2libGVIZWlnaHQpICsgdGhpcy52aXNpYmxlWSAtIHRoaXMudmlzaWJsZUhlaWdodCAvIDIgLSB0aGlzLlJPSV95KSAqIHRoaXMuY2FtZXJhQmluOyAvLyDorqHnrpfpgInmi6nkvY3nva7nmoR55Z2Q5qCHCgogICAgICAgIGlmICh0aGlzLnNlbGVjdFN0YXJYID49IDAgJiYgdGhpcy5zZWxlY3RTdGFyWCA8IHRoaXMuUmVkQm94U2lkZUxlbmd0aCAmJgogICAgICAgICAgdGhpcy5zZWxlY3RTdGFyWSA+PSAwICYmIHRoaXMuc2VsZWN0U3RhclkgPCB0aGlzLlJlZEJveFNpZGVMZW5ndGgpIHsKICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1NlbGVjdCBTdGFyIGlzIGluIFJPSScsICdpbmZvJyk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1NlbGVjdCBTdGFyIGlzIG5vdCBpbiBST0knLCAnZXJyb3InKTsKICAgICAgICAgIHRoaXMuc2VsZWN0U3RhclggPSAtMTsKICAgICAgICAgIHRoaXMuc2VsZWN0U3RhclkgPSAtMTsKICAgICAgICB9CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdzZW5kU2VsZWN0U3RhcnM6JyArIHRoaXMuc2VsZWN0U3RhclggKyAnOicgKyB0aGlzLnNlbGVjdFN0YXJZKTsKICAgICAgfQogICAgICB0aGlzLmRyYXdJbWFnZURhdGEoKTsKICAgIH0sCiAgICBoYW5kbGVUb3VjaFN0YXJ0KGV2ZW50KSB7CiAgICAgIGlmICh0aGlzLmRyYXdJbWdEYXRhID09IG51bGwpIHJldHVybjsKICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn6Kem5Y+R6Kem5pG45byA5aeL5LqL5Lu2OicsICdpbmZvJyk7CiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkgeyAvLyDljZXmjIfop6bmkbjvvIzlvIDlp4vmi5bliqgKICAgICAgICB0aGlzLmlzT25lVG91Y2ggPSB0cnVlOwogICAgICAgIC8vIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+inpuWPkeWNleaMh+inpuaRuOS6i+S7ticsICdpbmZvJyk7CiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsKICAgICAgICB0aGlzLnN0YXJ0VG91Y2hYWzBdID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYOwogICAgICAgIHRoaXMuc3RhcnRUb3VjaFlbMF0gPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7CiAgICAgICAgdGhpcy5jdXJyZW50VG91Y2hYWzBdID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYOwogICAgICAgIHRoaXMuY3VycmVudFRvdWNoWVswXSA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WTsKICAgICAgICAvLyDmuIXpmaTlj6/og73lrZjlnKjnmoTlj4zmjIfop6bmkbjnmoTlrprml7blmagKICAgICAgICBpZiAodGhpcy56b29tSW50ZXJ2YWxJZCkgewogICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnpvb21JbnRlcnZhbElkKTsKICAgICAgICAgIHRoaXMuem9vbUludGVydmFsSWQgPSBudWxsOwogICAgICAgIH0KCgogICAgICAgIHRoaXMuaGFuZGxlTWFpbkNhbnZhc1RvdWNoKGV2ZW50KTsKICAgICAgfSBlbHNlIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+PSAyKSB7IC8vIOWPjOaMh+inpuaRuO+8jOW8gOWni+e8qeaUvgogICAgICAgIHRoaXMuaXNPbmVUb3VjaCA9IGZhbHNlOwogICAgICAgIC8vIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+inpuWPkeWPjOaMh+inpuaRuOS6i+S7ticsICdpbmZvJyk7CiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsKICAgICAgICAvLyDorqHnrpfkuKTkuKrop6bmkbjngrnkuYvpl7TnmoTot53nprsKICAgICAgICBjb25zdCBkeCA9IHRoaXMuY3VycmVudFRvdWNoWFswXSAtIHRoaXMuY3VycmVudFRvdWNoWFsxXTsKICAgICAgICBjb25zdCBkeSA9IHRoaXMuY3VycmVudFRvdWNoWVswXSAtIHRoaXMuY3VycmVudFRvdWNoWVsxXTsKICAgICAgICB0aGlzLnN0YXJ0VG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7CiAgICAgICAgLy8g5riF6Zmk5Y+v6IO95a2Y5Zyo55qE5Y2V5oyH6Kem5pG455qE5a6a5pe25ZmoCiAgICAgICAgaWYgKHRoaXMubW92ZUludGVydmFsSWQpIHsKICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlSW50ZXJ2YWxJZCk7CiAgICAgICAgICB0aGlzLm1vdmVJbnRlcnZhbElkID0gbnVsbDsKICAgICAgICB9CgoKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfop6blj5HlpJrmjIfop6bmkbjkuovku7bvvIzojrflj5blvZPliY3op6bmkbjngrnmlbDph486JyArIGV2ZW50LnRvdWNoZXMubGVuZ3RoLCAnaW5mbycpOwogICAgICB9CgogICAgfSwKCiAgICBoYW5kbGVUb3VjaE1vdmUoZXZlbnQpIHsKICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn6Kem5Y+R6Kem5pG456e75Yqo5LqL5Lu2OicsICdpbmZvJyk7CiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuZHJhd0ltZ0RhdGEgPT0gbnVsbCkgcmV0dXJuOwogICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT0gMSkgewogICAgICAgIHRoaXMuY3VycmVudFRvdWNoWFswXSA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDsKICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaFlbMF0gPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7CiAgICAgICAgaWYgKHRoaXMuem9vbUludGVydmFsSWQpIHsKICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy56b29tSW50ZXJ2YWxJZCk7CiAgICAgICAgICB0aGlzLnpvb21JbnRlcnZhbElkID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMubW92ZUludGVydmFsSWQgIT0gbnVsbCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICAvLyDorr7nva7kuIDkuKrlrprml7blmajvvIzmr48xMDBtc+aJp+ihjOS4gOasoeinpuaRuOenu+WKqOeahOmAu+i+kQogICAgICAgIHRoaXMubW92ZUludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7CiAgICAgICAgICAvLyBjb25zb2xlLmxvZygn5omn6KGM6Kem5pG456e75YqoIScpOwogICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcgfHwgIXRoaXMuaXNPbmVUb3VjaCkgcmV0dXJuOwoKICAgICAgICAgIGNvbnN0IGR4ID0gdGhpcy5zdGFydFRvdWNoWFswXSAtIHRoaXMuY3VycmVudFRvdWNoWFswXTsKICAgICAgICAgIGNvbnN0IGR5ID0gdGhpcy5zdGFydFRvdWNoWVswXSAtIHRoaXMuY3VycmVudFRvdWNoWVswXTsKICAgICAgICAgIGlmIChpc05hTihkeCkgfHwgaXNOYU4oZHkpKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIGxldCBuZXdWaXNpYmxlWCA9IHRoaXMudmlzaWJsZVggKyBkeCAvIHdpbmRvdy5pbm5lcldpZHRoICogdGhpcy52aXNpYmxlV2lkdGg7CiAgICAgICAgICBsZXQgbmV3VmlzaWJsZVkgPSB0aGlzLnZpc2libGVZICsgZHkgLyB3aW5kb3cuaW5uZXJIZWlnaHQgKiB0aGlzLnZpc2libGVIZWlnaHQ7CiAgICAgICAgICBpZiAobmV3VmlzaWJsZVggPCAwKSB7CiAgICAgICAgICAgIG5ld1Zpc2libGVYID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChuZXdWaXNpYmxlWSA8IDApIHsKICAgICAgICAgICAgbmV3VmlzaWJsZVkgPSAwOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG5ld1Zpc2libGVYID4gdGhpcy5tYWluQ2FtZXJhU2l6ZVgpIHsKICAgICAgICAgICAgbmV3VmlzaWJsZVggPSB0aGlzLm1haW5DYW1lcmFTaXplWDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChuZXdWaXNpYmxlWSA+IHRoaXMubWFpbkNhbWVyYVNpemVZKSB7CiAgICAgICAgICAgIG5ld1Zpc2libGVZID0gdGhpcy5tYWluQ2FtZXJhU2l6ZVk7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy52aXNpYmxlWCA9IG5ld1Zpc2libGVYOwogICAgICAgICAgdGhpcy52aXNpYmxlWSA9IG5ld1Zpc2libGVZOwoKICAgICAgICAgIHRoaXMuc3RhcnRUb3VjaFhbMF0gPSB0aGlzLmN1cnJlbnRUb3VjaFhbMF07CiAgICAgICAgICB0aGlzLnN0YXJ0VG91Y2hZWzBdID0gdGhpcy5jdXJyZW50VG91Y2hZWzBdOwoKICAgICAgICAgIHRoaXMuZHJhd0ltYWdlRGF0YSgpOwogICAgICAgIH0sIDEwMCk7CgogICAgICB9IGVsc2UgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID49IDIpIHsKICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaFhbMF0gPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7CiAgICAgICAgdGhpcy5jdXJyZW50VG91Y2hZWzBdID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRZOwogICAgICAgIHRoaXMuY3VycmVudFRvdWNoWFsxXSA9IGV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WDsKICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaFlbMV0gPSBldmVudC50b3VjaGVzWzFdLmNsaWVudFk7CgogICAgICAgIC8vIOa4hemZpOWPr+iDveWtmOWcqOeahOWNleaMh+inpuaRuOeahOWumuaXtuWZqAogICAgICAgIGlmICh0aGlzLm1vdmVJbnRlcnZhbElkKSB7CiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubW92ZUludGVydmFsSWQpOwogICAgICAgICAgdGhpcy5tb3ZlSW50ZXJ2YWxJZCA9IG51bGw7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLnpvb21JbnRlcnZhbElkICE9IG51bGwpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgLy8g6K6+572u5LiA5Liq5a6a5pe25Zmo77yM5q+PMTAwbXPmiafooYzkuIDmrKHnvKnmlL7pgLvovpEKICAgICAgICB0aGlzLnpvb21JbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gewogICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcgfHwgIXRoaXMuaXNPbmVUb3VjaCkgcmV0dXJuOwogICAgICAgICAgY29uc3QgZHggPSB0aGlzLmN1cnJlbnRUb3VjaFhbMF0gLSB0aGlzLmN1cnJlbnRUb3VjaFhbMV07CiAgICAgICAgICBjb25zdCBkeSA9IHRoaXMuY3VycmVudFRvdWNoWVswXSAtIHRoaXMuY3VycmVudFRvdWNoWVsxXTsKICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTsKICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+i3neemu+WPmOWMliBkaXN0YW5jZTonICsgZGlzdGFuY2UsICdpbmZvJyk7CiAgICAgICAgICBpZiAodGhpcy5zdGFydFRvdWNoRGlzdGFuY2UgPT0gMCkgewogICAgICAgICAgICB0aGlzLnN0YXJ0VG91Y2hEaXN0YW5jZSA9IGRpc3RhbmNlOwogICAgICAgICAgfQogICAgICAgICAgLy8g6K6h566X57yp5pS+5q+U5L6L55qE5Y+Y5YyW6YePCiAgICAgICAgICBjb25zdCBzY2FsZUNoYW5nZSA9IGRpc3RhbmNlIC8gdGhpcy5zdGFydFRvdWNoRGlzdGFuY2U7CiAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfot53nprvlj5jljJbmr5Tkvosgc2NhbGVDaGFuZ2U6JyArIHNjYWxlQ2hhbmdlLCAnaW5mbycpOwogICAgICAgICAgbGV0IG5ld1NjYWxlID0gdGhpcy5zY2FsZSAqIHNjYWxlQ2hhbmdlOyAvLyDmm7TmlrDnvKnmlL7mr5TkvosKICAgICAgICAgIGlmIChuZXdTY2FsZSA8IDAuMSkgewogICAgICAgICAgICBuZXdTY2FsZSA9IDAuMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChuZXdTY2FsZSA+IDEpIHsKICAgICAgICAgICAgbmV3U2NhbGUgPSAxOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG5ld1NjYWxlICE9IHRoaXMuc2NhbGUpIHsKICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn57yp5pS+5q+U5L6L5Y+Y5YyWLOe8qeaUvuavlOS+izonICsgbmV3U2NhbGUsICdpbmZvJyk7CiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBuZXdTY2FsZTsgLy8g5pu05paw57yp5pS+5q+U5L6LCiAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnc2V0U2NhbGUnLCB0aGlzLnNjYWxlKTsKICAgICAgICAgICAgdGhpcy5kcmF3SW1hZ2VEYXRhKCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfnvKnmlL7mr5TkvovmsqHmnInlj5jljJYs57yp5pS+5q+U5L6LOicgKyB0aGlzLnNjYWxlLCAnaW5mbycpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5zdGFydFRvdWNoRGlzdGFuY2UgPSBkaXN0YW5jZTsgLy8g5pu05paw5Lik5Liq6Kem5pG454K55LmL6Ze055qE6Led56a7CiAgICAgICAgfSwgMTAwKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfop6blj5HlpJrmjIfop6bmkbjkuovku7bvvIzojrflj5blvZPliY3op6bmkbjngrnmlbDph486JyArIGV2ZW50LnRvdWNoZXMubGVuZ3RoLCAnaW5mbycpOwogICAgICB9CiAgICB9LAoKICAgIGhhbmRsZVRvdWNoRW5kKGV2ZW50KSB7CiAgICAgIC8vIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+inpuWPkeinpuaRuOe7k+adn+S6i+S7tjonLCAnaW5mbycpOwogICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsgLy8g5YGc5q2i5ouW5YqoCiAgICAgIC8vIOa4hemZpOWumuaXtuWZqAogICAgICBpZiAodGhpcy5tb3ZlSW50ZXJ2YWxJZCkgewogICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlSW50ZXJ2YWxJZCk7CiAgICAgICAgdGhpcy5tb3ZlSW50ZXJ2YWxJZCA9IG51bGw7CiAgICAgIH0KICAgICAgaWYgKHRoaXMuem9vbUludGVydmFsSWQpIHsKICAgICAgICBjbGVhckludGVydmFsKHRoaXMuem9vbUludGVydmFsSWQpOwogICAgICAgIHRoaXMuem9vbUludGVydmFsSWQgPSBudWxsOwogICAgICB9CiAgICB9LAoKICAgIFNjYWxlQ2hhbmdlKHR5cGUpIHsKICAgICAgaWYgKHRoaXMuZHJhd0ltZ0RhdGEgPT0gbnVsbCkgcmV0dXJuOwogICAgICBpZiAodHlwZSA9PSAnKycpIHsKICAgICAgICB0aGlzLnNjYWxlIC09IDAuMTsKICAgICAgfSBlbHNlIGlmICh0eXBlID09ICctJykgewogICAgICAgIHRoaXMuc2NhbGUgKz0gMC4xOwogICAgICB9CiAgICAgIGlmICh0aGlzLnNjYWxlIDwgMC4xKSB7CiAgICAgICAgdGhpcy5zY2FsZSA9IDAuMTsKICAgICAgfQogICAgICBpZiAodGhpcy5zY2FsZSA+IDEpIHsKICAgICAgICB0aGlzLnNjYWxlID0gMTsKICAgICAgfQogICAgICB0aGlzLiRidXMuJGVtaXQoJ3NldFNjYWxlJywgdGhpcy5zY2FsZSk7CiAgICAgIHRoaXMuZHJhd0ltYWdlRGF0YSgpOwogICAgfSwKCiAgICAvLyDmmL7npLpST0nlm77lg48KICAgIHNob3dSb2lJbWFnZShmaWxlTmFtZSwgZGVzdFgsIGRlc3RZKSB7CiAgICAgIGlmICh0aGlzLlJlZEJveFNpZGVMZW5ndGggPT0gMCB8fCB0aGlzLlJlZEJveFNpZGVMZW5ndGggPT0gbnVsbCkgewogICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ1JlZEJveFNpZGVMZW5ndGggaXMgMCBvciBudWxsJywgJ2Vycm9yJyk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZ0ltYWdlKSB7CiAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnSW1hZ2UgaXMgYmVpbmcgdHJhbnNtaXR0ZWQsIGN1cnJlbnQgcHJvY2Vzc2luZyBpcyBzbG93LCBza2lwcGluZyBvbmUgZnJhbWUuJywgJ3dhcm5pbmcnKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgdGhpcy5pc1Byb2Nlc3NpbmdJbWFnZSA9IHRydWU7CiAgICAgIGNvbnN0IGltYWdlUGF0aCA9ICdpbWcvJyArIGZpbGVOYW1lOwogICAgICAvLyDliJvlu7rkuIDkuKpBYm9ydENvbnRyb2xsZXLlrp7kvovmnaXlj5bmtohmZXRjaOivt+axggogICAgICBjb25zdCBmZXRjaENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7CiAgICAgIGNvbnN0IGZldGNoU2lnbmFsID0gZmV0Y2hDb250cm9sbGVyLnNpZ25hbDsKCiAgICAgIC8vIGNvbnN0IHN0YXJ0RG93bmxvYWRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7CgogICAgICAvLyDkvb/nlKggZmV0Y2ggQVBJIOiOt+WPluS6jOi/m+WItuaVsOaNrgogICAgICBmZXRjaChpbWFnZVBhdGgsIHsgY2FjaGU6ICduby1zdG9yZScsIHNpZ25hbDogZmV0Y2hTaWduYWwgfSkKICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKQogICAgICAgIC50aGVuKGJ1ZmZlciA9PiB7CiAgICAgICAgICAvLyBjb25zdCBlbmREb3dubG9hZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgICAgIC8vIGNvbnN0IGRvd25sb2FkVGltZSA9IGVuZERvd25sb2FkVGltZSAtIHN0YXJ0RG93bmxvYWRUaW1lOwogICAgICAgICAgaWYgKHRoaXMuaXNGb2N1c0xvb3BTaG9vdGluZykgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdzaG93Um9pSW1hZ2VTdWNjZXNzOnRydWUnKTsKICAgICAgICAgIGVsc2UgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdzaG93Um9pSW1hZ2VTdWNjZXNzOmZhbHNlJyk7CiAgICAgICAgICBsZXQgdGltZTEgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgICAgIGxldCBzcmMsIGltZ0RhdGEsIHRhcmdldEltZzg7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBjb25zdCB1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpOwogICAgICAgICAgICBsZXQgbmV3V2lkdGggPSBwYXJzZUludCh0aGlzLlJlZEJveFNpZGVMZW5ndGggLyB0aGlzLmNhbWVyYUJpbik7CiAgICAgICAgICAgIGxldCBuZXdIZWlnaHQgPSBwYXJzZUludCh0aGlzLlJlZEJveFNpZGVMZW5ndGggLyB0aGlzLmNhbWVyYUJpbik7CiAgICAgICAgICAgIGlmIChuZXdXaWR0aCAlIDIgIT0gMCkgewogICAgICAgICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggLSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgJSAyICE9IDApIHsKICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgLSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh1aW50MTZBcnJheS5sZW5ndGggIT09IG5ld1dpZHRoICogbmV3SGVpZ2h0KSB7CiAgICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygndWludDE2QXJyYXkubGVuZ3RoICgnICsgdWludDE2QXJyYXkubGVuZ3RoICsgJykgIT09IG5ld1dpZHRoICogbmV3SGVpZ2h0ICgnICsgbmV3V2lkdGggKiBuZXdIZWlnaHQgKyAnKScsICdlcnJvcicpOwogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyDliJvlu7rkuIDkuKrnqbrnmoQgTWF0IOWvueixoQogICAgICAgICAgICBzcmMgPSBuZXcgY3YuTWF0KG5ld0hlaWdodCwgbmV3V2lkdGgsIGN2LkNWXzE2VUMxKTsKICAgICAgICAgICAgc3JjLmRhdGExNlUuc2V0KHVpbnQxNkFycmF5KTsKICAgICAgICAgICAgbGV0IHRpbWUyID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ+WIm+W7um1hdOWvueixoeaXtumXtDogJyArICh0aW1lMiAtIHRpbWUxKS50b0ZpeGVkKDApICsgJ21zJywgJ2luZm8nKTsKICAgICAgICAgICAgaWYgKHRoaXMubGFzdEltYWdlUHJvY2Vzc1BhcmFtcy5pc0NvbG9yQ2FtZXJhID09ICd0cnVlJyB8fCB0aGlzLmxhc3RJbWFnZVByb2Nlc3NQYXJhbXMuaXNDb2xvckNhbWVyYSA9PSAnVHJ1ZScgfHwgdGhpcy5sYXN0SW1hZ2VQcm9jZXNzUGFyYW1zLmlzQ29sb3JDYW1lcmEpIHsKICAgICAgICAgICAgICB0YXJnZXRJbWc4ID0gdGhpcy5hcHBseVN0cmV0Y2hBbmRHYWluKHNyYywgdGhpcy5sYXN0SW1hZ2VQcm9jZXNzUGFyYW1zLmFuYWx5c2lzLCAnYmF5ZXInLCB0aGlzLmxhc3RJbWFnZVByb2Nlc3NQYXJhbXMuQ0ZBLCB0aGlzLmxhc3RJbWFnZVByb2Nlc3NQYXJhbXMuYmxhY2tMZXZlbCwgdGhpcy5sYXN0SW1hZ2VQcm9jZXNzUGFyYW1zLndoaXRlTGV2ZWwpOwoKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0YXJnZXRJbWc4ID0gdGhpcy5hcHBseVN0cmV0Y2hBbmRHYWluKHNyYywgdGhpcy5sYXN0SW1hZ2VQcm9jZXNzUGFyYW1zLmFuYWx5c2lzLCAnZ3JheScsIHRoaXMubGFzdEltYWdlUHJvY2Vzc1BhcmFtcy5DRkEsIHRoaXMubGFzdEltYWdlUHJvY2Vzc1BhcmFtcy5ibGFja0xldmVsLCB0aGlzLmxhc3RJbWFnZVByb2Nlc3NQYXJhbXMud2hpdGVMZXZlbCk7CiAgICAgCiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGltZTEgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgICAgICAgdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnYXBwbHlTdHJldGNoQW5kR2FpbuaXtumXtDogJyArICh0aW1lMSAtIHRpbWUyKS50b0ZpeGVkKDApICsgJ21zJywgJ2luZm8nKTsKICAgICAgICAgICAgc3JjLmRlbGV0ZSgpOwogICAgICAgICAgICBzcmMgPSBudWxsOwoKICAgICAgICAgICAgLy8g5bCGIE1hdCDlr7nosaHovazmjaLlm54gSW1hZ2VEYXRhIOWvueixoQogICAgICAgICAgICBpbWdEYXRhID0gbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkodGFyZ2V0SW1nOC5kYXRhKSwgdGFyZ2V0SW1nOC5jb2xzLCB0YXJnZXRJbWc4LnJvd3MpOwogICAgICAgICAgICB0YXJnZXRJbWc4LmRlbGV0ZSgpOwogICAgICAgICAgICB0YXJnZXRJbWc4ID0gbnVsbDsKICAgICAgICAgICAgLy8g5Zyo5oyH5a6a5L2N572u5byA5aeL57uY5Yi25Zu+5YOPCiAgICAgICAgICAgIC8vIHRoaXMuYnVmZmVyQ3R4LmNsZWFyUmVjdCh0aGlzLlJPSV94LCB0aGlzLlJPSV95LCB0YXJnZXRJbWc4LmNvbHMsIHRhcmdldEltZzgucm93cyk7CiAgICAgICAgICAgIHRoaXMuYnVmZmVyQ3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCB0aGlzLlJPSV94LCB0aGlzLlJPSV95KTsKICAgICAgICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn57uY5Yi25LiA5qyhUk9J5pWw5o2uOicgKyBmaWxlTmFtZSArICc6JyArIHRoaXMuUk9JX3ggKyAnOicgKyB0aGlzLlJPSV95LCAnaW5mbycpOwogICAgICAgICAgICAvLyDmoIfms6jor4bliKvliLDnmoTmmJ/ngrnkvY3nva4KICAgICAgICAgICAgLy8gdGltZTIgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygn57uY5Yi25Zyo57yT5a2Y55S75biD6ICX5pe2OiAnICsgKHRpbWUyIC0gdGltZTEpLnRvRml4ZWQoMCkgKyAnbXMnLCAnaW5mbycpOwogICAgICAgICAgICB0aGlzLmRyYXdJbWFnZURhdGEoKTsKICAgICAgICAgICAgLy8gdGltZTEgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgICAgICAgLy8gdGhpcy5TZW5kQ29uc29sZUxvZ01zZygnZHJhd0ltYWdlRGF0YeaXtumXtDogJyArICh0aW1lMSAtIHRpbWUyKS50b0ZpeGVkKDApICsgJ21zJywgJ2luZm8nKTsKICAgICAgICAgICAgdGhpcy5mb2N1c2VyUGljdHVyZUZpbGVOYW1lID0gZmlsZU5hbWU7CiAgICAgICAgICAgIC8vIGNvbnN0IHByb2Nlc3NUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBkb3dubG9hZFRpbWU7CiAgICAgICAgICAgIC8vIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coYFJPSeeahOaJp+ihjOaXtumXtCDkuIvovb06ICR7ZG93bmxvYWRUaW1lLnRvRml4ZWQoMCl9bXMsIOWkhOeQhjogJHtwcm9jZXNzVGltZS50b0ZpeGVkKDApfW1zYCwgJ2luZm8nKTsKCiAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGDlpITnkIblm77lg4/lpLHotKU6ICR7aW1hZ2VQYXRofWAsIGVycm9yKTsKICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIC8vIOehruS/nSBNYXQg5a+56LGh5ZKMIEltYWdlRGF0YSDlr7nosaHooqvliKDpmaQKICAgICAgICAgICAgaWYgKHNyYyAmJiAhc3JjLmlzRGVsZXRlZCgpKSB7CiAgICAgICAgICAgICAgc3JjLmRlbGV0ZSgpOwogICAgICAgICAgICAgIHNyYyA9IG51bGw7IC8vIOa3u+WKoOi/meihjOS7o+egge+8jOehruS/nSBzcmMg5a+56LGh6KKr5riF55CGCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRhcmdldEltZzggJiYgIXRhcmdldEltZzguaXNEZWxldGVkKCkpIHsKICAgICAgICAgICAgICB0YXJnZXRJbWc4LmRlbGV0ZSgpOwogICAgICAgICAgICAgIHRhcmdldEltZzggPSBudWxsOyAvLyDmt7vliqDov5nooYzku6PnoIHvvIznoa7kv50gb3JpZ2luYWxJbWc4IOWvueixoeiiq+a4heeQhgogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIOehruS/nSBidWZmZXIg6KKr5riF55CGCiAgICAgICAgICAgIGJ1ZmZlciA9IG51bGw7CiAgICAgICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nSW1hZ2UgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9KQogICAgICAgIC5jYXRjaChlcnJvciA9PiB7CiAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaCByZXF1ZXN0IGNhbmNlbGxlZCcpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihg6I635Y+W5Zu+5YOP5aSx6LSlOiAke2ltYWdlUGF0aH1gLCBlcnJvcik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZ0ltYWdlID0gZmFsc2U7CiAgICAgICAgfSk7CgogICAgICAvLyDlnKjnu4Tku7bljbjovb3ml7blj5bmtoggZmV0Y2gg6K+35rGCCiAgICAgIHRoaXMuJG9uY2UoJ2hvb2s6YmVmb3JlRGVzdHJveScsICgpID0+IHsKICAgICAgICBmZXRjaENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgfSk7CiAgICB9LAogICAgc2V0UmVkQm94U3RhdGUobGVuZ3RoLCB4LCB5KSB7CiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ3NldFJlZEJveFN0YXRlOicgKyBsZW5ndGggKyAnLCcgKyB4ICsgJywnICsgeSwgJ2luZm8nKTsKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdzZXRSZWRCb3hQb3NpdGlvbicsIHgsIHkpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ3NldFJlZEJveFNpZGVMZW5ndGgnLCBsZW5ndGgpOwogICAgfSwKICAgIHNldEZvY3VzZXJTdGF0ZShzdGF0ZSkgewogICAgICBpZiAoc3RhdGUgPT09ICdzZWxlY3RzdGFycycpIHsKICAgICAgICB0aGlzLmlzRm9jdXNMb29wU2hvb3RpbmcgPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuaXNGb2N1c0xvb3BTaG9vdGluZyA9IGZhbHNlOwogICAgICB9CiAgICB9LAogICAgc2V0U2hvd1NlbGVjdFN0YXIoc3RhdGUpIHsKICAgICAgdGhpcy5zaG93U2VsZWN0U3RhciA9IHN0YXRlOwogICAgfSwKICAgIFJlZEJveFNpemVDaGFuZ2UobGVuZ3RoKSB7CiAgICAgIHRoaXMuUmVkQm94U2lkZUxlbmd0aCA9IHBhcnNlSW50KGxlbmd0aCk7CiAgICAgIC8vIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnc2VuZFJlZEJveFN0YXRlOicgKyB0aGlzLlJlZEJveFNpZGVMZW5ndGggKyAnOicgKyB0aGlzLlJPSV94ICsgJzonICsgdGhpcy5ST0lfeSk7CiAgICB9LAogICAgc2V0TWFpbkNhbWVyYVBhcmFtZXRlcnMocGFyYW1ldGVycykgewogICAgICBmb3IgKGNvbnN0IHBhcmFtZXRlciBpbiBwYXJhbWV0ZXJzKSB7CiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuTWFpbkNhbWVyYUNvbmZpZ0l0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLmxhYmVsID09PSBwYXJhbWV0ZXIpOwogICAgICAgIGlmIChpdGVtKSB7CiAgICAgICAgICBpdGVtLnZhbHVlID0gcGFyYW1ldGVyc1twYXJhbWV0ZXJdOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAocGFyYW1ldGVyID09ICdSZWRCb3hTaXplJykgewogICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ3NldFJlZEJveFNpZGVMZW5ndGgnLCBwYXJhbWV0ZXJzW3BhcmFtZXRlcl0pOwogICAgICAgICAgICB0aGlzLlJlZEJveFNpZGVMZW5ndGggPSBwYXJzZUludChwYXJhbWV0ZXJzW3BhcmFtZXRlcl0pOwogICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXIgPT0gJ1JPSV94JykgewogICAgICAgICAgICB0aGlzLlJPSV94ID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzW3BhcmFtZXRlcl0pOwogICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXIgPT0gJ1JPSV95JykgewogICAgICAgICAgICB0aGlzLlJPSV95ID0gcGFyc2VGbG9hdChwYXJhbWV0ZXJzW3BhcmFtZXRlcl0pOwogICAgICAgICAgfSAKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGDmnKrmib7liLDlj4LmlbDvvJoke3BhcmFtZXRlcn1gKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgdGhpcy5jb25maXJtQ29uZmlndXJhdGlvbih0aGlzLk1haW5DYW1lcmFDb25maWdJdGVtcyk7CiAgICB9LAogICAgc2hvd0NhbnZhcyhjYW52YXMpIHsKICAgICAgaWYgKGNhbnZhcyA9PT0gJ1N0ZWwnKSB7CiAgICAgICAgdGhpcy5jdXJyZW50Y2FudmFzID0gJ1N0ZWwnOwogICAgICAgIHRoaXMuc2hvd1N0ZWxDYW52YXMoKTsKICAgICAgfQogICAgICBlbHNlIGlmIChjYW52YXMgPT09ICdNYWluQ2FtZXJhJykgewoKICAgICAgICB0aGlzLmN1cnJlbnRjYW52YXMgPSAnTWFpbkNhbWVyYSc7CiAgICAgICAgdGhpcy5zaG93TWFpbkNhbWVyYUNhbnZhcygpOwogICAgICAgIHRoaXMuZHJhd0ltYWdlRGF0YSgpCiAgICAgIH0KICAgICAgZWxzZSBpZiAoY2FudmFzID09PSAnR3VpZGVyQ2FtZXJhJykgewogICAgICAgIHRoaXMuY3VycmVudGNhbnZhcyA9ICdHdWlkZXJDYW1lcmEnOwogICAgICAgIHRoaXMuc2hvd0d1aWRlckNhbWVyYUNhbnZhcygpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coInVua25vd24gY2FudmFzOiAiICsgY2FudmFzLCAnZXJyb3InKTsKICAgICAgfQogICAgfSwKICAgIC8vIOeOsOacieeahOWKoOWHj+WHveaVsOmcgOimgeS/ruaUuQogICAgZGVjcmVtZW50QW5kTm90aWZ5KGl0ZW0pIHsKICAgICAgaWYgKGl0ZW0udmFsdWUgPiBpdGVtLmlucHV0TWluKSB7CiAgICAgICAgaXRlbS52YWx1ZSAtPSBpdGVtLmlucHV0U3RlcDsKICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ0NoYW5nZShpdGVtLmxhYmVsLCBpdGVtLnZhbHVlKTsKICAgICAgfQogICAgfSwKCiAgICBpbmNyZW1lbnRBbmROb3RpZnkoaXRlbSkgewogICAgICBpZiAoaXRlbS52YWx1ZSA8IGl0ZW0uaW5wdXRNYXgpIHsKICAgICAgICBpdGVtLnZhbHVlICs9IGl0ZW0uaW5wdXRTdGVwOwogICAgICAgIHRoaXMuaGFuZGxlQ29uZmlnQ2hhbmdlKGl0ZW0ubGFiZWwsIGl0ZW0udmFsdWUpOwogICAgICB9CiAgICB9LAoKICAgIC8vIOmAmueUqOeahOmFjee9ruabtOaUueWkhOeQhuWHveaVsAogICAgaGFuZGxlQ29uZmlnQ2hhbmdlKGxhYmVsLCB2YWx1ZSkgewogICAgICBjb25zb2xlLmxvZyhg6YWN572u5bey5pu05pS5OiAke2xhYmVsfSA9ICR7dmFsdWV9YCk7CiAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHsKICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtLmxhYmVsLCBpdGVtLnZhbHVlKTsKICAgICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKGxhYmVsICsgJzonICsgdmFsdWUsICdpbmZvJyk7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KGxhYmVsLCBsYWJlbCArICc6JyArIHZhbHVlKTsKICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSAnJyAmJiBsYWJlbCA9PT0gJ0ZvY2FsIExlbmd0aCAobW0pJykgewogICAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2cobGFiZWwgKyAnaXMgTlVMTCcsICdpbmZvJyk7CiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KGl0ZW0ubGFiZWwsIGl0ZW0ubGFiZWwgKyAnOicpOwogICAgICB9CiAgICB9LAogICAgLy8g5qCh5YeG55u45YWz5pa55rOVCiAgICBzdGFydENhbGlicmF0aW9uUHJvY2VzcygpIHsKICAgICAgdGhpcy5jYWxpYnJhdGlvbkluZm8uaXNDYWxpYnJhdGluZyA9IHRydWU7CiAgICAgIHRoaXMuY2FsaWJyYXRpb25JbmZvLmNhbGlicmF0aW9uU3RhdGUgPSAncnVubmluZyc7CiAgICAgIHRoaXMuY2FsaWJyYXRpb25JbmZvLmNhbGlicmF0aW9uU3RlcCA9IDA7CiAgICAgIHRoaXMuY2FsaWJyYXRpb25JbmZvLmNhbGlicmF0aW9uTWVzc2FnZSA9IHRoaXMuJHQoJ1ByZXBhcmluZyB0byBzdGFydCBmb2N1c2VyIHRyYXZlbCBjYWxpYnJhdGlvbi4uLicpOwogICAgICBjb25zb2xlLmxvZygnQXBwOiBDYWxpYnJhdGlvbiBzdGFydGVkOicsIHRoaXMuY2FsaWJyYXRpb25JbmZvKTsKICAgIH0sCgogICAgdXBkYXRlQ2FsaWJyYXRpb25JbmZvKHN0ZXAsIG1lc3NhZ2UsIHN0YXRlKSB7CiAgICAgIHRyeSB7CiAgICAgICAgdGhpcy5jYWxpYnJhdGlvbkluZm8uY2FsaWJyYXRpb25TdGVwID0gc3RlcDsKICAgICAgICAvLyDlpoLmnpzmtojmga/mmK/lm73pmYXljJbplK7vvIzliJnnv7vor5HlroMKICAgICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25JbmZvLmNhbGlicmF0aW9uTWVzc2FnZSA9IHRoaXMuJHQobWVzc2FnZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25JbmZvLmNhbGlicmF0aW9uTWVzc2FnZSA9IG1lc3NhZ2U7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZSkgewogICAgICAgICAgdGhpcy5jYWxpYnJhdGlvbkluZm8uY2FsaWJyYXRpb25TdGF0ZSA9IHN0YXRlOwogICAgICAgIH0KICAgICAgICBpZiAoc3RlcCA9PT0gMCkgewogICAgICAgICAgdGhpcy5jYWxpYnJhdGlvbkluZm8uaXNDYWxpYnJhdGluZyA9IHRydWU7CiAgICAgICAgfQogICAgICAgIGNvbnNvbGUubG9nKCdBcHA6IENhbGlicmF0aW9uIGluZm8gdXBkYXRlZDonLCB0aGlzLmNhbGlicmF0aW9uSW5mbyk7CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXBkYXRlQ2FsaWJyYXRpb25JbmZvOicsIGVycm9yKTsKICAgICAgfQogICAgfSwKCiAgICBlbmRDYWxpYnJhdGlvbigpIHsKICAgICAgdGhpcy5jYWxpYnJhdGlvbkluZm8uaXNDYWxpYnJhdGluZyA9IGZhbHNlOwogICAgICB0aGlzLmNhbGlicmF0aW9uSW5mby5jYWxpYnJhdGlvblN0YXRlID0gJ2lkbGUnOwogICAgICB0aGlzLmNhbGlicmF0aW9uSW5mby5jYWxpYnJhdGlvblN0ZXAgPSAwOwogICAgICB0aGlzLmNhbGlicmF0aW9uSW5mby5jYWxpYnJhdGlvbk1lc3NhZ2UgPSAnJzsKICAgICAgY29uc29sZS5sb2coJ0FwcDogQ2FsaWJyYXRpb24gZW5kZWQnKTsKICAgIH0sCiAgfSwKICBjb21wdXRlZDogewogICAgbmF2OiB7CiAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgIGNvbnNvbGUubG9nKCduYXY6JywgdGhpcy4kc3RvcmUuc3RhdGUuc2hvd05hdmlnYXRpb25EcmF3ZXIpOwogICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5zdGF0ZS5zaG93TmF2aWdhdGlvbkRyYXdlcgogICAgICB9LAogICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7CiAgICAgICAgaWYgKHRoaXMuJHN0b3JlLnN0YXRlLnNob3dOYXZpZ2F0aW9uRHJhd2VyICE9PSB2KSB7CiAgICAgICAgICBjb25zb2xlLmxvZygnbmF2OicsIHRoaXMuJHN0b3JlLnN0YXRlLnNob3dOYXZpZ2F0aW9uRHJhd2VyKTsKICAgICAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgndG9nZ2xlQm9vbCcsICdzaG93TmF2aWdhdGlvbkRyYXdlcicpCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgc3RvcmVDdXJyZW50TG9jYXRpb246IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLmN1cnJlbnRMb2NhdGlvbgogICAgfSwKICAgIGdldFFUQ2xpZW50VmVyc2lvbkNvbG9yKCkgewogICAgICBpZiAodGhpcy5RVENsaWVudFZlcnNpb24gPT09ICdOb3QgY29ubmVjdGVkJykgewogICAgICAgIHJldHVybiAncmdiYSgyNTUsIDAsIDAsIDAuNSknOyAvLyDnuqLoibLvvIzpgI/mmI7luqYgMC41CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknOyAvLyDpu5jorqTnmb3oibLvvIzpgI/mmI7luqYgMC41CiAgICAgIH0KICAgIH0sCiAgICBpc01vYmlsZSgpIHsKICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJzsKICAgICAgdmFyIHRvdWNoID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApOwogICAgICB2YXIgdWFEYXRhTW9iaWxlID0gbnVsbDsKICAgICAgLy8g5YW85a656ICB5rWP6KeI5Zmo77ya6YG/5YWN5Y+v6YCJ6ZO+CiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEubW9iaWxlICE9PSAndW5kZWZpbmVkJykgewogICAgICAgIHVhRGF0YU1vYmlsZSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhLm1vYmlsZTsKICAgICAgfQogICAgICB2YXIgbW9iaWxlTGlrZSA9IC9BbmRyb2lkfGlQaG9uZXxpUGFkfGlQb2R8TW9iaWxlfFRhYmxldC9pLnRlc3QodWEpOwogICAgICByZXR1cm4gKHVhRGF0YU1vYmlsZSAhPT0gbnVsbCA/IHVhRGF0YU1vYmlsZSA6IG1vYmlsZUxpa2UpICYmICEhdG91Y2g7CiAgICB9LAogICAgaXNEZXNrdG9wKCkgewogICAgICByZXR1cm4gIXRoaXMuaXNNb2JpbGU7CiAgICB9LAogIH0sCiAgd2F0Y2g6IHsKICAgIHN0b3JlQ3VycmVudExvY2F0aW9uOiBmdW5jdGlvbiAobG9jKSB7CiAgICAgIGNvbnN0IEREMlIgPSBNYXRoLlBJIC8gMTgwCiAgICAgIHRoaXMuJHN0ZWwuY29yZS5vYnNlcnZlci5sYXRpdHVkZSA9IGxvYy5sYXQgKiBERDJSCiAgICAgIHRoaXMuJHN0ZWwuY29yZS5vYnNlcnZlci5sb25naXR1ZGUgPSBsb2MubG5nICogREQyUgogICAgICB0aGlzLiRzdGVsLmNvcmUub2JzZXJ2ZXIuZWxldmF0aW9uID0gbG9jLmFsdAoKICAgICAgLy8gQXQgc3RhcnR1cCwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbG9jYXRpb24gdG8gYmUgc2V0IGJlZm9yZSBkZWNpZGluZyB3aGljaAogICAgICAvLyBzdGFydHVwIHRpbWUgdG8gc2V0IHNvIHRoYXQgaXQncyBuaWdodCB0aW1lLgogICAgICBpZiAoIXRoaXMuc3RhcnRUaW1lSXNTZXQpIHsKICAgICAgICB0aGlzLiRzdGVsLmNvcmUub2JzZXJ2ZXIudXRjID0gc3doLmdldFRpbWVBZnRlclN1bnNldCh0aGlzLiRzdGVsKQogICAgICAgIHRoaXMuc3RhcnRUaW1lSXNTZXQgPSB0cnVlCiAgICAgIH0KICAgICAgLy8gSW5pdCBvZiB0aW1lIGFuZCBkYXRlIGlzIGNvbXBsZXRlCiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnc2V0VmFsdWUnLCB7IHZhck5hbWU6ICdpbml0Q29tcGxldGUnLCBuZXdWYWx1ZTogdHJ1ZSB9KQogICAgfSwKICAgICRyb3V0ZTogZnVuY3Rpb24gKCkgewogICAgICAvLyByZWFjdCB0byByb3V0ZSBjaGFuZ2VzLi4uCiAgICAgIHRoaXMuc2V0U3RhdGVGcm9tUXVlcnlBcmdzKCkKICAgIH0sCiAgICBDdXJyZW50RHJpdmVyVHlwZShuZXdWYWwpIHsKICAgICAgLy8g5b2TIEN1cnJlbnREcml2ZXJUeXBlIOWPmOWMluaXtu+8jOabtOaWsCBzZWxlY3RlZERyaXZlcgogICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkRHJpdmVyKG5ld1ZhbCk7CiAgICB9CiAgfSwKICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7CiAgICAvLyAvLyDpmLvmraLpu5jorqTnmoTop6bmkbjooYzkuLoKICAgIC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLnByZXZlbnREZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pOwogICAgLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5wcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTsKICAgIC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5wcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTsKCiAgICAvLyAvLyDpmLvmraLpu5jorqTnmoTpvKDmoIfooYzkuLoKICAgIC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMucHJldmVudERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7CiAgICAvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnByZXZlbnREZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pOwogICAgLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMucHJldmVudERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7CgogICAgLy8gLy8g6Zi75q2i6buY6K6k55qE5rua6L2u6KGM5Li6CiAgICAvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMucHJldmVudERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7CgogICAgbGV0IHRoYXQgPSB0aGlzCgogICAgdGhpcy5nZXRMb2NhdGlvbkhvc3ROYW1lKCk7CgogICAgdGhpcy5sb2FkSW1hZ2VUb0NhbnZhc01haW5DYW1lcmEoKTsKICAgIHRoaXMubG9hZEltYWdlVG9DYW52YXNHdWlkZXJDYW1lcmEoKTsKCiAgICB0aGlzLmluaXRDYW52YXMoKTsKICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTsKCiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy4kc3RlbGxhcml1bVdlYlBsdWdpbnMoKSkgewogICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLiRzdGVsbGFyaXVtV2ViUGx1Z2lucygpW2ldCiAgICAgIGlmIChwbHVnaW4ub25BcHBNb3VudGVkKSB7CiAgICAgICAgcGx1Z2luLm9uQXBwTW91bnRlZCh0aGF0KQogICAgICB9CiAgICB9CgogICAgdGhpcy5jb25uZWN0KCk7CiAgICB0aGlzLnNldHVwTmV0d29ya1N0YXR1c0xpc3RlbmVyKCk7CgogICAgLy8g5L2/55SoIFByb21pc2Ug5qOA5p+lIE9wZW5DVi5qcyDmmK/lkKbliqDovb3lrozmiJAKICAgIHRoaXMubG9hZE9wZW5DdigpLnRoZW4oKCkgPT4gewogICAgICBpZiAoIXRoaXMuX2lzRGVzdHJveWVkKSB7IC8vIOajgOafpee7hOS7tuaYr+WQpuW3sumUgOavgQogICAgICAgIGNvbnNvbGUubG9nKCdPcGVuQ1YuanMgaXMgcmVhZHknKTsKICAgICAgICB0aGlzLm9uQ3ZSZWFkeSgpOyAgLy8g6LCD55SoIE9wZW5DViDlh4blpIflpb3nmoTlm57osIMKICAgICAgfQogICAgfSkuY2F0Y2goZXJyb3IgPT4gewogICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIE9wZW5DVi5qczonLCBlcnJvcik7CiAgICB9KTsKCiAgICAvLyBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTsKICAgIC8vIHNjcmlwdC5zcmMgPSAnaHR0cHM6Ly9kb2NzLm9wZW5jdi5vcmcvNC41LjUvb3BlbmN2LmpzJzsKICAgIC8vIHNjcmlwdC5hc3luYyA9IHRydWU7CiAgICAvLyBzY3JpcHQub25sb2FkID0gKCkgPT4gdGhpcy5vbkN2UmVhZHkoKTsKICAgIC8vIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTsKCiAgICBpbXBvcnQoJ0AvYXNzZXRzL2pzL3N0ZWxsYXJpdW0td2ViLWVuZ2luZS53YXNtJykudGhlbihmID0+IHsKICAgICAgaWYgKCF0aGlzLl9pc0Rlc3Ryb3llZCkgeyAvLyDlho3mrKHmo4Dmn6Xnu4Tku7bmmK/lkKblt7LplIDmr4EKICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBTdGVsV2ViRW5naW5lIHZpZXdlciBzaW5nbGV0b24KICAgICAgICAvLyBBZnRlciB0aGlzIGNhbGwsIHRoZSBTdGVsV2ViRW5naW5lIHN0YXRlIHdpbGwgYWx3YXlzIGJlIGF2YWlsYWJsZSBpbiB2dWV4IHN0b3JlCiAgICAgICAgLy8gaW4gdGhlICRzdG9yZS5zdGVsIG9iamVjdCBpbiBhIHJlYWN0aXZlIHdheSAodXNlZnVsIGZvciB2dWUgY29tcG9uZW50cykuCiAgICAgICAgLy8gVG8gbW9kaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgU3RlbFdlYkVuZ2luZSwgaXQncyBlbm91Z2ggdG8gY2FsbC9zZXQgdmFsdWVzIGRpcmVjdGx5IG9uIHRoZSAkc3RlbCBvYmplY3QKICAgICAgICB0cnkgewogICAgICAgICAgc3doLmluaXRTdGVsV2ViRW5naW5lKHRoYXQuJHN0b3JlLCBmLmRlZmF1bHQsIHRoYXQuJHJlZnMuc3RlbENhbnZhcywgZnVuY3Rpb24gKCkgewogICAgICAgICAgICAvLyBTdGFydCBhdXRvIGxvY2F0aW9uIGRldGVjdGlvbiAoZXZlbiBpZiB3ZSBkb24ndCB1c2UgaXQpCiAgICAgICAgICAgIHN3aC5nZXRHZW9sb2NhdGlvbigpLnRoZW4ocCA9PiBzd2guZ2VvQ29kZVBvc2l0aW9uKHAsIHRoYXQpKS50aGVuKChsb2MpID0+IHsKICAgICAgICAgICAgICB0aGF0LiRzdG9yZS5jb21taXQoJ3NldEF1dG9EZXRlY3RlZExvY2F0aW9uJywgbG9jKQogICAgICAgICAgICB9LCAoZXJyb3IpID0+IHsgY29uc29sZS5sb2coZXJyb3IpIH0pCgogICAgICAgICAgICB0aGF0LiRzdGVsLnNldEZvbnQoJ3JlZ3VsYXInLCBwcm9jZXNzLmVudi5CQVNFX1VSTCArICdmb250cy9Sb2JvdG8tUmVndWxhci50dGYnLCAxLjM4KQogICAgICAgICAgICB0aGF0LiRzdGVsLnNldEZvbnQoJ2JvbGQnLCBwcm9jZXNzLmVudi5CQVNFX1VSTCArICdmb250cy9Sb2JvdG8tQm9sZC50dGYnLCAxLjM4KQogICAgICAgICAgICB0aGF0LiRzdGVsLmNvcmUuY29uc3RlbGxhdGlvbnMuc2hvd19vbmx5X3BvaW50ZWQgPSBmYWxzZQoKICAgICAgICAgICAgdGhhdC5zZXRTdGF0ZUZyb21RdWVyeUFyZ3MoKQogICAgICAgICAgICB0aGF0Lmd1aUNvbXBvbmVudCA9ICdHdWknCiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGF0LiRzdGVsbGFyaXVtV2ViUGx1Z2lucygpKSB7CiAgICAgICAgICAgICAgY29uc3QgcGx1Z2luID0gdGhhdC4kc3RlbGxhcml1bVdlYlBsdWdpbnMoKVtpXQogICAgICAgICAgICAgIGlmIChwbHVnaW4ub25FbmdpbmVSZWFkeSkgewogICAgICAgICAgICAgICAgcGx1Z2luLm9uRW5naW5lUmVhZHkodGhhdCkKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICghdGhhdC5kYXRhU291cmNlSW5pdERvbmUpIHsKICAgICAgICAgICAgICAvLyBTZXQgYWxsIGRlZmF1bHQgZGF0YSBzb3VyY2VzCiAgICAgICAgICAgICAgY29uc3QgY29yZSA9IHRoYXQuJHN0ZWwuY29yZQogICAgICAgICAgICAgIGNvcmUuc3RhcnMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9zdGFycycgfSkKICAgICAgICAgICAgICBjb3JlLnN0YXJzLmFkZERhdGFTb3VyY2UoeyB1cmw6IHByb2Nlc3MuZW52LkJBU0VfVVJMICsgJ3NreWRhdGEvc3RhcnNfYmFzZScgfSkKICAgICAgICAgICAgICBjb3JlLnN0YXJzLmFkZERhdGFTb3VyY2UoeyB1cmw6IHByb2Nlc3MuZW52LkJBU0VfVVJMICsgJ3NreWRhdGEvc3RhcnNfZXh0ZW5kJyB9KQogICAgICAgICAgICAgIGNvcmUuZHNzLmFkZERhdGFTb3VyY2UoeyB1cmw6IHByb2Nlc3MuZW52LkJBU0VfVVJMICsgJ3NreWRhdGEvZHNzL3YxJyB9KQogICAgICAgICAgICAgIC8vIGNvcmUuc3RhcnMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9zdGFycycgfSkKCiAgICAgICAgICAgICAgLy8gQWxsb3cgdG8gc3BlY2lmeSBhIGN1c3RvbSBwYXRoIGZvciBza3kgY3VsdHVyZSBkYXRhCiAgICAgICAgICAgICAgaWYgKHRoYXQuJHJvdXRlLnF1ZXJ5LnNjKSB7CiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGF0LiRyb3V0ZS5xdWVyeS5zYy5zdWJzdHJpbmcodGhhdC4kcm91dGUucXVlcnkuc2MubGFzdEluZGV4T2YoJy8nKSArIDEpCiAgICAgICAgICAgICAgICBjb3JlLnNreWN1bHR1cmVzLmFkZERhdGFTb3VyY2UoeyB1cmw6IHRoYXQuJHJvdXRlLnF1ZXJ5LnNjLCBrZXk6IGtleSB9KQogICAgICAgICAgICAgICAgY29yZS5za3ljdWx0dXJlcy5jdXJyZW50X2lkID0ga2V5CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNvcmUuc2t5Y3VsdHVyZXMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9za3ljdWx0dXJlcy93ZXN0ZXJuJywga2V5OiAnd2VzdGVybicgfSkKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNvcmUuZHNvcy5hZGREYXRhU291cmNlKHsgdXJsOiBwcm9jZXNzLmVudi5CQVNFX1VSTCArICdza3lkYXRhL2RzbycgfSkKICAgICAgICAgICAgICBjb3JlLmxhbmRzY2FwZXMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9sYW5kc2NhcGVzL2d1ZXJlaW5zJywga2V5OiAnZ3VlcmVpbnMnIH0pCiAgICAgICAgICAgICAgY29yZS5taWxreXdheS5hZGREYXRhU291cmNlKHsgdXJsOiBwcm9jZXNzLmVudi5CQVNFX1VSTCArICdza3lkYXRhL3N1cnZleXMvbWlsa3l3YXknIH0pCiAgICAgICAgICAgICAgLy8gY29yZS5kc3MuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9zdXJ2ZXlzL2RzcycgfSkKICAgICAgICAgICAgICBjb3JlLm1pbm9yX3BsYW5ldHMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9tcGNvcmIuZGF0Jywga2V5OiAnbXBjX2FzdGVyb2lkcycgfSkKICAgICAgICAgICAgICBjb3JlLnBsYW5ldHMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9zdXJ2ZXlzL3Nzby9tb29uJywga2V5OiAnbW9vbicgfSkKICAgICAgICAgICAgICBjb3JlLnBsYW5ldHMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9zdXJ2ZXlzL3Nzby9zdW4nLCBrZXk6ICdzdW4nIH0pCiAgICAgICAgICAgICAgY29yZS5wbGFuZXRzLmFkZERhdGFTb3VyY2UoeyB1cmw6IHByb2Nlc3MuZW52LkJBU0VfVVJMICsgJ3NreWRhdGEvc3VydmV5cy9zc28vbW9vbicsIGtleTogJ2RlZmF1bHQnIH0pCiAgICAgICAgICAgICAgY29yZS5jb21ldHMuYWRkRGF0YVNvdXJjZSh7IHVybDogcHJvY2Vzcy5lbnYuQkFTRV9VUkwgKyAnc2t5ZGF0YS9Db21ldEVscy50eHQnLCBrZXk6ICdtcGNfY29tZXRzJyB9KQogICAgICAgICAgICAgIGNvcmUuc2F0ZWxsaXRlcy5hZGREYXRhU291cmNlKHsgdXJsOiBwcm9jZXNzLmVudi5CQVNFX1VSTCArICdza3lkYXRhL3RsZV9zYXRlbGxpdGUuanNvbmwuZ3onLCBrZXk6ICdqc29ubC9zYXQnIH0pCgogICAgICAgICAgICAgIC8vIE1vdW50IFBvaW50aW5nCiAgICAgICAgICAgICAgZ2xTdGVsID0gdGhhdC5zZXRHbG9hYmFsU3RlbCh0aGF0LiRzdGVsKTsKICAgICAgICAgICAgICBnbExheWVyID0gdGhhdC5zZXRHbG9iYWxMYXllcih0aGF0LiRzdGVsKTsKICAgICAgICAgICAgICBnbFRlc3RDaXJjbGUgPSB0aGF0LnRlc3RBZGRDaXJjbGUodGhhdC4kc3RlbCwgZ2xMYXllcik7CgogICAgICAgICAgICB9CiAgICAgICAgICB9KQogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnc2V0VmFsdWUnLCB7IHZhck5hbWU6ICd3YXNtU3VwcG9ydCcsIG5ld1ZhbHVlOiBmYWxzZSB9KQogICAgICAgIH0KICAgICAgfQogICAgfSk7CgogICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7CiAgICAgIC8vIOmhtemdouWujOWFqOWKoOi9vQogICAgICB0aGlzLlNlbmRDb25zb2xlTG9nTXNnKCfpobXpnaLlt7LlrozlhajliqDovb0nLCAnaW5mbycpOwogICAgICB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Byb2Nlc3NfQ29tbWFuZF9SZXR1cm4nLCAnVnVlQ2xpZW50VmVyc2lvbjonICsgcHJvY2Vzcy5lbnYuVlVFX0FQUF9WRVJTSU9OKTsKICAgIH0pCgogICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHsKICAgICAgLy8gRE9N5Yqg6L295a6M5oiQCiAgICAgIHRoaXMuU2VuZENvbnNvbGVMb2dNc2coJ0RPTeW3suWKoOi9veWujOaIkCcsICdpbmZvJyk7CiAgICB9KQoKICB9LAogIC8vIOWcqOe7hOS7tumUgOavgeaXtuenu+mZpAogIGJlZm9yZURlc3Ryb3koKSB7CiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5wcmV2ZW50RGVmYXVsdCk7CiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnByZXZlbnREZWZhdWx0KTsKICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5wcmV2ZW50RGVmYXVsdCk7CgogICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5wcmV2ZW50RGVmYXVsdCk7CiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnByZXZlbnREZWZhdWx0KTsKICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnByZXZlbnREZWZhdWx0KTsKCiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMucHJldmVudERlZmF1bHQpOwoKICAgIC8vIOa4heeQhuaegei9tOagoeWHhuebuOWFs+eahOWchuWciAogICAgaWYgKHRoaXMuY2FsaWJyYXRpb25DaXJjbGVzKSB7CiAgICAgIHRoaXMuY2FsaWJyYXRpb25DaXJjbGVzLmZvckVhY2goY2lyY2xlID0+IHsKICAgICAgICBpZiAoZ2xMYXllciAmJiBjaXJjbGUpIHsKICAgICAgICAgIGdsTGF5ZXIucmVtb3ZlKGNpcmNsZSk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdGhpcy5jYWxpYnJhdGlvbkNpcmNsZXMgPSBbXTsKICAgIH0KCiAgICBpZiAodGhpcy5hZGp1c3RtZW50Q2lyY2xlcykgewogICAgICB0aGlzLmFkanVzdG1lbnRDaXJjbGVzLmZvckVhY2goY2lyY2xlID0+IHsKICAgICAgICBpZiAoZ2xMYXllciAmJiBjaXJjbGUpIHsKICAgICAgICAgIGdsTGF5ZXIucmVtb3ZlKGNpcmNsZSk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdGhpcy5hZGp1c3RtZW50Q2lyY2xlcyA9IFtdOwogICAgfQoKICAgIC8vIOWBnOatouinhuWcuuabtOaWsOWumuaXtuWZqAogICAgdGhpcy5zdG9wRmllbGRVcGRhdGVUaW1lcigpOwogIH0sCgoKfQo="},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA","file":"App.vue","sourceRoot":"src","sourcesContent":["// Stellarium Web - Copyright (c) 2022 - Stellarium Labs SRL\n//\n// This program is licensed under the terms of the GNU AGPL v3, or\n// alternatively under a commercial licence.\n//\n// The terms of the AGPL v3 license can be found in the main directory of this\n// repository.\n\n<template>\n  <v-app>\n    <v-navigation-drawer v-model=\"drawer_2\" ref=\"Drawer_2\" app absolute temporary :width=\"DeviceIsConnected ? 200 : 200\"\n      style=\"left: 170px; backdrop-filter: blur(5px); background-color: rgba(0, 0, 0, 0.1);\">\n\n      <div v-show=\"isOpenDevicePage\">\n        <span\n          style=\"position: absolute; top: 0px; left: 50%; transform: translateX(-50%); font-size: 30px; color: rgba(255, 255, 255, 0.5); user-select: none;\">\n          {{ $t(CurrentDriverType) }}\n          <v-divider></v-divider>\n        </span>\n\n        <div :style=\"{ width: DeviceIsConnected ? '200px' : '200px' }\"\n          style=\"position: absolute; top: 50px; max-height: calc(100% - 95px); overflow-y: auto;\"\n          class=\"params-container\">\n\n          <div v-show=\"!DeviceIsConnected\" style=\"text-align: center;\">\n            <span style=\"display: inline-block; font-size: 15px; color: rgba(255, 255, 255, 0.5); user-select: none;\">\n              {{ $t('Device Connection') }}\n            </span>\n\n            <!-- @change -->\n            <v-select :label=\"$t('Select Driver')\" :items=\"drivers\" item-text=\"label\" item-value=\"value\"\n              v-model=\"selectedDriver\" @change=\"confirmDriver\" style=\"width: 150px; display: inline-block;\">\n            </v-select>\n\n            <!-- @change -->\n            <v-select v-if=\"CurrentDriverType === 'Mount' || CurrentDriverType === 'Focuser'\" :label=\"$t('Baud Rate')\"\n              :items=\"BaudRateItems\" item-text=\"label\" item-value=\"value\" v-model=\"BaudRateSelected\"\n              @change=\"confirmDriver\" style=\"width: 150px; display: inline-block;\">\n            </v-select>\n\n            <v-row no-gutters>\n              <v-col cols=\"6\">\n                <button @click=\"clearDriver\" class=\"btn-confirm\" style=\"display: inline-block;\">\n                  <div style=\"display: flex; justify-content: center; align-items: center;\">\n                    <img src=\"@/assets/images/svg/ui/delete.svg\" height=\"20px\"\n                      style=\"min-height: 20px; pointer-events: none;\"></img>\n                  </div>\n                </button>\n              </v-col>\n              <v-col cols=\"6\">\n                <button v-if=\"!isConnecting\" @click=\"connectDriver(selectedDriver)\" class=\"btn-confirm\"\n                  style=\"display: inline-block; background-color: green;\">\n                  <div style=\"display: flex; justify-content: center; align-items: center;\">\n                    <v-icon color=\"white\">mdi-link</v-icon>\n                  </div>\n                </button>\n                <v-progress-circular v-else indeterminate color=\"green\" size=\"24\"></v-progress-circular>\n              </v-col>\n            </v-row>\n          </div>\n\n          <div v-show=\"DeviceIsConnected\" v-for=\"(item, index) in CurrentConfigItems()\" :key=\"index\"\n            class=\"config-item\">\n            <!--  -->\n            <span v-if=\"index === 0\" class=\"config-title\">\n              {{ $t('Device Config Items') }}\n            </span>\n\n            <!--  -->\n            <v-card-text>\n              <!--  -->\n              <v-text-field v-if=\"item.inputType === 'text'\" v-model=\"item.value\" :label=\"item.label\"\n                @input=\"handleConfigChange(item.label, item.value)\" class=\"config-input\">\n              </v-text-field>\n\n              <!--  -->\n              <v-text-field v-if=\"item.inputType === 'number'\" v-model=\"item.value\" :label=\"item.label\"\n                :type=\"isDesktop ? 'number' : 'text'\" :min=\"item.min\" :max=\"item.max\"\n                :step=\"item.step !== undefined && item.step !== null ? item.step : 1\" :rules=\"numberRules(item)\"\n                :inputmode=\"isMobile ? getInputMode(item) : ''\" :pattern=\"isMobile ? getPattern(item) : ''\"\n                enterkeyhint=\"done\" @blur=\"onNumberCommit(item)\" @keydown.enter.prevent=\"onNumberCommit(item)\"\n                class=\"config-input\" />\n\n              <!--  -->\n              <div v-if=\"item.inputType === 'slider'\" class=\"slider-container\">\n                <span class=\"slider-label\">\n                  {{ item.label }}: {{ item.value }}\n                </span>\n                <div>\n                  <!--  -->\n                  <button @click=\"decrementAndNotify(item)\" class=\"get-click btn-slider btn-minus\">\n                    <div class=\"btn-content\">\n                      <img src=\"@/assets/images/svg/ui/Minus.svg\" height=\"10px\" class=\"btn-icon\">\n                    </div>\n                  </button>\n\n                  <!--  -->\n                  <v-slider v-model=\"item.value\" :step=\"item.inputStep\" :max=\"item.inputMax\" :min=\"item.inputMin\"\n                    @change=\"handleConfigChange(item.label, item.value)\" color=\"white\"\n                    class=\"align-center slider-control\">\n                  </v-slider>\n\n                  <!--  -->\n                  <button @click=\"incrementAndNotify(item)\" class=\"get-click btn-slider btn-plus\">\n                    <div class=\"btn-content\">\n                      <img src=\"@/assets/images/svg/ui/Plus.svg\" height=\"10px\" class=\"btn-icon\">\n                    </div>\n                  </button>\n                </div>\n              </div>\n\n              <!--  -->\n              <v-select v-if=\"item.inputType === 'select'\" v-model=\"item.value\" :label=\"item.label\"\n                @change=\"handleConfigChange(item.label, item.value)\" :items=\"item.selectValue\" class=\"config-input\">\n              </v-select>\n\n              <!--  -->\n              <v-switch v-if=\"item.inputType === 'switch'\" v-model=\"item.value\" :label=\"item.label\"\n                @change=\"handleConfigChange(item.label, item.value)\" class=\"config-switch\">\n              </v-switch>\n\n              <!--  -->\n              <div v-if=\"item.inputType === 'tip'\" class=\"tip-field\">\n                <div class=\"tip-label\">{{ item.label }}</div>\n                <div class=\"tip-value\" :title=\"formatTipTitle(item)\">\n                  {{ formatTipValue(item) }}\n                </div>\n              </div>\n            </v-card-text>\n          </div>\n\n          <div v-show=\"DeviceIsConnected\"\n            style=\"text-align: center; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px;\">\n            <button @click=\"disconnectDriver\" class=\"btn-confirm\" style=\"display: inline-block; background-color: red;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <v-icon color=\"white\">mdi-link-off</v-icon>\n              </div>\n            </button>\n          </div>\n\n        </div>\n\n        <div v-show=\"isOpenPowerPage\">\n          <span\n            style=\"position: absolute; top: 0px; left: 50%; transform: translateX(-50%); font-size: 26px; color: rgba(255, 255, 255, 0.5); user-select: none; white-space: nowrap; \">\n            {{ $t('Power Management') }}\n            <v-divider></v-divider>\n          </span>\n\n          <div style=\"position: absolute; top: 50px; max-height: calc(100% - 50px); width: 200px; overflow-y: auto;\">\n            <v-list dense>\n\n              <v-list-item @click.stop=\"SwitchOutPutPower(1, OutPutPower_1_ON)\"\n                :style=\"{ height: '36px', marginBottom: '10px' }\">\n                <v-list-item-icon style=\"margin-right: 10px;\">\n                  <div style=\"display: flex; justify-content: center; align-items: center;\">\n                    <img src=\"@/assets/images/svg/ui/OutPutPower.svg\" height=\"30px\"\n                      style=\"min-height: 30px; pointer-events: none;\"></img>\n                  </div>\n                </v-list-item-icon>\n                <v-list-item-content>\n                  <v-list-item-title>\n                    <span>\n                      <div :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('OutPut Power 1') }}\n                      </div>\n                      <div :style=\"{ fontSize: '7px' }\" :class=\"{ 'connected-device': OutPutPower_1_ON }\">{{\n                        OutPutPower_1_ON ?\n                          '[ON]' : '[OFF]' }}</div>\n                    </span>\n                  </v-list-item-title>\n\n                </v-list-item-content>\n              </v-list-item>\n\n              <v-list-item @click.stop=\"SwitchOutPutPower(2, OutPutPower_2_ON)\"\n                :style=\"{ height: '36px', marginBottom: '10px' }\">\n                <v-list-item-icon style=\"margin-right: 10px;\">\n                  <div style=\"display: flex; justify-content: center; align-items: center;\">\n                    <img src=\"@/assets/images/svg/ui/OutPutPower.svg\" height=\"30px\"\n                      style=\"min-height: 30px; pointer-events: none;\"></img>\n                  </div>\n                </v-list-item-icon>\n                <v-list-item-content>\n                  <v-list-item-title>\n                    <span>\n                      <div :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('OutPut Power 2') }}\n                      </div>\n                      <div :style=\"{ fontSize: '7px' }\" :class=\"{ 'connected-device': OutPutPower_2_ON }\">{{\n                        OutPutPower_2_ON ?\n                          '[ON]' : '[OFF]' }}</div>\n                    </span>\n                  </v-list-item-title>\n\n                </v-list-item-content>\n              </v-list-item>\n\n              <v-divider :style=\"{ marginBottom: '10px' }\"></v-divider>\n\n              <v-list-item @click.stop=\"RestartRaspberryPi()\" :style=\"{ height: '36px', marginBottom: '10px' }\">\n                <v-list-item-icon style=\"margin-right: 10px;\">\n                  <div style=\"display: flex; justify-content: center; align-items: center;\">\n                    <img src=\"@/assets/images/svg/ui/Reboot.svg\" height=\"30px\"\n                      style=\"min-height: 30px; pointer-events: none;\"></img>\n                  </div>\n                </v-list-item-icon>\n                <v-list-item-content>\n                  <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Restart')\n                  }}</v-list-item-title>\n                </v-list-item-content>\n              </v-list-item>\n\n              <v-list-item @click.stop=\"ShutdownRaspberryPi()\" :style=\"{ height: '36px', marginBottom: '10px' }\">\n                <v-list-item-icon style=\"margin-right: 10px;\">\n                  <div style=\"display: flex; justify-content: center; align-items: center;\">\n                    <img src=\"@/assets/images/svg/ui/PowerOFF.svg\" height=\"30px\"\n                      style=\"min-height: 30px; pointer-events: none;\"></img>\n                  </div>\n                </v-list-item-icon>\n                <v-list-item-content>\n                  <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Shut Down')\n                  }}</v-list-item-title>\n                </v-list-item-content>\n              </v-list-item>\n              <!--  -->\n              <v-list-item @click.stop=\"ForceUpdate()\" :style=\"{ height: '36px', marginBottom: '10px' }\">\n                <v-list-item-icon style=\"margin-right: 10px;\">\n                  <div style=\"display: flex; justify-content: center; align-items: center;\">\n                    <img src=\"@/assets/images/svg/ui/PowerOFF.svg\" height=\"30px\"\n                      style=\"min-height: 30px; pointer-events: none;\"></img>\n                  </div>\n                </v-list-item-icon>\n                <v-list-item-content>\n                  <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Force Update')\n                  }}</v-list-item-title>\n                </v-list-item-content>\n              </v-list-item>\n\n            </v-list>\n          </div>\n\n        </div>\n\n      </div>\n\n    </v-navigation-drawer>\n\n    <v-navigation-drawer v-model=\"nav\" app :stateless=\"drawer_2\" temporary width=\"170\"\n      style=\"backdrop-filter: blur(5px); background-color: rgba(0, 0, 0, 0.1);\">\n      <v-layout column fill-height>\n        <v-list dense>\n          <!--  -->\n          <template>\n            <div style=\"display: flex; justify-content: center; align-items: center;\">\n              <span style=\"font-size: 10px; color: rgba(255, 255, 255, 0.5); user-select: none; white-space: nowrap;\">\n                Client Version: {{ VueClientVersion }}\n              </span>\n            </div>\n            <div style=\"display: flex; justify-content: center; align-items: center;\">\n              <!-- <span style=\"font-size: 10px; color: getQTClientVersionColor,rgba(255, 255, 255, 0.5); user-select: none; white-space: nowrap;\">\n                Server Version: {{ QTClientVersion }}\n              </span> -->\n              <span :style=\"{\n                fontSize: '10px',\n                color: getQTClientVersionColor,\n                userSelect: 'none',\n                whiteSpace: 'nowrap'\n              }\">\n                Server Version: {{ QTClientVersion }}\n              </span>\n            </div>\n            <v-divider></v-divider>\n          </template>\n\n          <!-- (Quit) -->\n          <v-list-item @click.stop=\"QuitToMainApp()\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/Quit.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Quit')\n                }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (View Settings) -->\n          <v-list-item @click.stop=\"toggleStoreValue('showViewSettingsDialog')\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/Setting.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('View Settings')\n                }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Power Management) -->\n          <v-list-item @click.stop=\"openPowerManagerPage()\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/Power.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Power Management')\n                }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <v-divider></v-divider>\n\n          <!-- () -->\n          <v-list-item v-for=\"(device, index) in devices\" :key=\"index\" @click.stop=\"selectDevice(device)\"\n            :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img :src=\"require(`@/assets/images/svg/ui/${device.driverType}.svg`)\" height=\"30px\"\n                  style=\"min-height: 30px\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title>\n                <span>\n                  <div :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t(device.driverType) }}</div>\n                  <div :style=\"{ fontSize: '7px' }\" :class=\"{ 'connected-device': device.isConnected }\">{{\n                    device.device }}\n                  </div>\n                </span>\n              </v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <v-divider></v-divider>\n\n          <!-- (Connect All) -->\n          <v-list-item :disabled=\"loadingConnectAllDevice\" @touchstart=\"startConnectBtnPress\"\n            @touchend=\"endConnectBtnPress\" @mousedown=\"startConnectBtnPress\" @mouseup=\"endConnectBtnPress\"\n            :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/Connect.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\">\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px', userSelect: 'none' }\">\n                {{ $t('Connect All') }}\n              </v-list-item-title>\n              <v-progress-linear v-if=\"loadingConnectAllDevice\" indeterminate color=\"white\"\n                height=\"5\"></v-progress-linear>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Disconnect All) -->\n          <v-list-item @click.stop=\"disconnectAllDevice(false)\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/DisConnect.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px', userSelect: 'none' }\">{{\n                $t('Disconnect All') }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Device Allocation) -->\n          <v-list-item @click.stop=\"DeviceAllocation()\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/Allocation.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{\n                $t('Device Allocation') }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Calibrate Polar Axis) -->\n          <v-list-item @click.stop=\"CalibratePolarAxis()\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/PoleAxis.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{\n                $t('Calibrate Polar Axis') }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Image Files) -->\n          <v-list-item @click.stop=\"OpenIamgeFolder()\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/FolderSwitch.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Image Files')\n                }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Logs) -->\n          <v-list-item @click.stop=\"OpenDebugLog()\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/DebugLog.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Logs')\n                }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <v-divider></v-divider>\n\n          <!-- (Lat & Long) -->\n          <v-list-item @click.stop=\"locationClicked()\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img :src=\"require(`@/assets/images/svg/ui/Location.svg`)\" height=\"30px\" style=\"min-height: 30px\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title>\n                <span>\n                  <div :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Lat & Long') }}</div>\n                  <div :style=\"{ fontSize: '7px' }\">{{ '(' + $store.state.currentLocation.lat + ', ' +\n                    $store.state.currentLocation.lng + ')' }}</div>\n                </span>\n              </v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Refresh Page) -->\n          <v-list-item @click.stop=\"ShowConfirmDialog('Confirm', $t('Are you sure you need to refresh?'), 'Refresh')\"\n            :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img :src=\"require(`@/assets/images/svg/ui/Refresh.svg`)\" height=\"30px\" style=\"min-height: 30px\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title>\n                <span>\n                  <div :style=\"{ fontSize: '10px' }\">{{ $t('Refresh Page') }}</div>\n                </span>\n              </v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n          <!-- (Data Credits) -->\n          <v-list-item @click.stop=\"toggleStoreValue('showDataCreditsDialog')\" :style=\"{ height: '36px' }\">\n            <v-list-item-icon style=\"margin-right: 10px;\">\n              <div style=\"display: flex; justify-content: center; align-items: center;\">\n                <img src=\"@/assets/images/svg/ui/DataCredits.svg\" height=\"30px\"\n                  style=\"min-height: 30px; pointer-events: none;\"></img>\n              </div>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title :style=\"{ height: '15px', padding: '1px', fontSize: '10px' }\">{{ $t('Data Credits')\n                }}</v-list-item-title>\n            </v-list-item-content>\n          </v-list-item>\n\n        </v-list>\n      </v-layout>\n    </v-navigation-drawer>\n\n\n\n\n    <v-main>\n\n      <canvas v-show=false id=\"TestCanvas\" width=\"1920\" height=\"1080\"></canvas>\n\n      <v-container class=\"fill-height\" fluid style=\"padding: 0\">\n        <div id=\"stel\" v-bind:class=\"{ right_panel: $store.state.showSidePanel }\">\n          <div style=\"position: relative; width: 100%; height: 100%\">\n            <component v-bind:is=\"guiComponent\"></component>\n            <canvas id=\"stel-canvas\" ref='stelCanvas' :style=\"{ zIndex: canvasZIndexStel }\"></canvas>\n            <canvas ref=\"mainCanvas\" id=\"mainCamera-canvas\" :style=\"{ zIndex: canvasZIndexMainCamera }\"\n              @click=\"handleMainCanvasClick\" @touchstart=\"handleTouchStart\" @touchmove=\"handleTouchMove\"\n              @touchend=\"handleTouchEnd\" @mousedown=\"handleMouseDown\" @mouseup=\"handleMouseUp\"\n              @mousemove=\"handleMouseMove\" @wheel=\"handleWheel\">\n            </canvas>\n            <canvas ref=\"guiderCanvas\" id=\"guiderCamera-canvas\" :style=\"{ zIndex: canvasZIndexGuiderCamera }\"\n              @click=\"handleGuiderCanvasClick\"></canvas>\n            <!-- <img id=\"imageSrc\" alt=\"Source\" :src=\"imageSrc\" crossOrigin = \"\" /> -->\n            <ProgressBar :progress=\"progressValue\" :description=\"progressDescription\" :showDescription=\"true\"\n              :isShow=\"currentcanvas === 'MainCamera'\" />\n          </div>\n        </div>\n\n\n      </v-container>\n    </v-main>\n\n    <v-dialog v-model=\"showDisconnectDialog\" persistent max-width=\"290\">\n      <v-card>\n        <v-card-title class=\"text-h5\">Confirm Action</v-card-title>\n        <v-card-text>Are you sure you want to disconnect the driver {{ currentDisconnectDriverName }}?</v-card-text>\n        <v-card-actions>\n          <v-spacer></v-spacer>\n          <v-btn color=\"red darken-1\" text @click=\"showDisconnectDialog = false\">Cancel</v-btn>\n          <v-btn color=\"green darken-1\" text @click=\"confirmDisconnect\">Confirm</v-btn>\n        </v-card-actions>\n      </v-card>\n    </v-dialog>\n\n    <!--  -->\n    <div v-if=\"calibrationInfo.isCalibrating || calibrationInfo.calibrationState === 'complete'\"\n      class=\"calibration-info-box\">\n      <div class=\"calibration-content\">\n        <div class=\"calibration-title\">{{ $t('Focuser Travel Calibration') }}</div>\n        <div class=\"calibration-message\">{{ calibrationInfo.calibrationMessage }}</div>\n        <div class=\"calibration-progress\">{{ $t('Step') }} {{ calibrationInfo.calibrationStep }}/3</div>\n      </div>\n    </div>\n\n  </v-app>\n</template>\n<script>\nimport _ from 'lodash'\nimport Gui from '@/components/gui.vue'\nimport GuiLoader from '@/components/gui-loader.vue'\nimport swh from '@/assets/sw_helpers.js'\nimport Moment from 'moment'\nimport BackgroundImage from '@/assets/images/svg/ui/Background.svg';\nimport ErrorImage from '@/assets/images/svg/ui/errorImage.svg';\nimport ProgressBar from '@/components/ProgressBar.vue';\n\nlet glTestCircle;\nlet glLayer;\nlet glStel;\n\nexport default {\n  data(context) {\n    return {\n      menuItems: [\n        { title: this.$t('View Settings'), icon: 'mdi-settings', store_var_name: 'showViewSettingsDialog', store_show_menu_item: 'showViewSettingsMenuItem' },\n        { title: this.$t('Planets Tonight'), icon: 'mdi-panorama-fisheye', store_var_name: 'showPlanetsVisibilityDialog', store_show_menu_item: 'showPlanetsVisibilityMenuItem' },\n        { divider: true }\n      ].concat(this.getPluginsMenuItems()).concat([\n        { title: this.$t('Data Credits'), footer: true, icon: 'mdi-copyright', store_var_name: 'showDataCreditsDialog' }\n      ]),\n      menuComponents: [].concat(this.getPluginsMenuComponents()),\n      guiComponent: 'GuiLoader',\n      startTimeIsSet: false,\n      initDone: false,\n      dataSourceInitDone: false,\n      imageSrc: 'https://i.imgur.com/egA5FIv.jpeg', // \n      cvReady: false,\n      canvasZIndexStel: -10,\n      canvasZIndexMainCamera: -11,\n      canvasZIndexGuiderCamera: -12,\n      currentcanvas: 'Stel',\n\n      WebSocketUrl: '',\n\n      websocket: null,\n      message: '',\n      receivedMessages: [],// \n      sentMessages: [], // \n      messageCounter: 0, // ID\n      websocketState: 'disconnected', // WebSocket\n      networkDisconnected: false, // \n\n      QTClientVersion: 'Not connected',\n      VueClientVersion: process.env.VUE_APP_VERSION,\n\n      // \n      calibrationInfo: {\n        isCalibrating: false,\n        calibrationState: 'idle',\n        calibrationStep: 0,\n        calibrationMessage: ''\n      },\n\n      // isMessageBoxShow: false,\n\n      CurrentDriverType: '',\n      DeviceIsConnected: null,\n      confirmDriverType: '',\n\n      MainCameraOffsetMin: 0,\n      MainCameraOffsetMax: 0,\n\n      MainCameraGainMin: 0,\n      MainCameraGainMax: 0,\n\n      devices: [\n        { name: '', driverType: 'Guider', type: 'CCDs', ListNum: \"1\", isget: false, device: '', BaudRate: 9600, driverName: '', isConnected: false, dialogStateVar: 'showDeviceSettingsDialog_Guider' },\n        { name: '', driverType: 'MainCamera', type: 'CCDs', ListNum: \"20\", isget: false, device: '', BaudRate: 9600, driverName: '', isConnected: false, dialogStateVar: 'showDeviceSettingsDialog_MainCamera' },\n        { name: '', driverType: 'Mount', type: 'Telescopes', ListNum: \"0\", isget: false, device: '', BaudRate: 9600, driverName: '', isConnected: false, dialogStateVar: 'showDeviceSettingsDialog_Mount' },\n        { name: '', driverType: 'Telescopes', device: '', isConnected: true },\n        { name: '', driverType: 'Focuser', type: 'Focusers', ListNum: \"22\", isget: false, device: '', BaudRate: 9600, driverName: '', isConnected: false, dialogStateVar: 'showDeviceSettingsDialog_Focuser' },\n        { name: '', driverType: 'PoleCamera', type: 'CCDs', ListNum: \"2\", isget: false, device: '', BaudRate: 9600, driverName: '', isConnected: false, dialogStateVar: 'showDeviceSettingsDialog_PoleCamera' },\n        { name: '', driverType: 'CFW', type: 'Filter Wheels', ListNum: \"21\", isget: false, device: '', BaudRate: 9600, driverName: '', isConnected: false, dialogStateVar: 'showDeviceSettingsDialog_CFW' },\n      ],\n\n      // Changing the label name also requires changing the emit signal name\n      GuiderConfigItems: [\n        { driverType: 'Guider', label: 'Guider Focal Length (mm)', value: '', inputType: 'text' },\n        { driverType: 'Guider', label: 'Multi Star Guider', value: false, inputType: 'switch' },\n        // { driverType: 'Guider', label: 'Guider Pixel size', value: '', inputType: 'text'},\n        { driverType: 'Guider', label: 'Guider Gain', value: '', inputType: 'slider', inputMin: 0, inputMax: 100, inputStep: 1 },\n        { driverType: 'Guider', label: 'Calibration step (ms)', value: '', inputType: 'text' },\n        { driverType: 'Guider', label: 'Ra Aggression', value: '', inputType: 'slider', inputMin: 0, inputMax: 100, inputStep: 1 },\n        { driverType: 'Guider', label: 'Dec Aggression', value: '', inputType: 'slider', inputMin: 0, inputMax: 100, inputStep: 1 },\n\n      ],\n\n      MainCameraConfigItems: [\n        // vue\n        { driverType: 'MainCamera', label: 'ImageCFA', value: '', inputType: 'select', selectValue: ['GR', 'GB', 'BG', 'RGGB', 'null'] },\n        // \n        { driverType: 'MainCamera', label: 'Binning', value: '', inputType: 'slider', inputMin: 1, inputMax: 16, inputStep: 1 },\n        { driverType: 'MainCamera', label: 'Temperature', value: '', inputType: 'select', selectValue: [5, 0, -5, -10, -15, -20, -25] },\n        { driverType: 'MainCamera', label: 'Gain', value: '', inputType: 'slider', inputMin: 0, inputMax: 0, inputStep: 1 },\n        { driverType: 'MainCamera', label: 'Offset', value: '', inputType: 'slider', inputMin: 0, inputMax: 0, inputStep: 1 },\n      ],\n\n      MountConfigItems: [\n        { driverType: 'Mount', label: 'Flip ETA', value: '00:00:00', displayValue: '00:00:00', inputType: 'tip' },\n        { driverType: 'Mount', label: 'GotoThenSolve', value: false, inputType: 'switch' },\n\n        // { driverType: 'Mount', label: 'isAutoFlip', value: false, inputType: 'switch' },\n      ],\n\n      TelescopesConfigItems: [\n        { driverType: 'Telescopes', num: 1, label: 'Focal Length (mm)', value: '', inputType: 'number' },\n      ],\n\n      FocuserConfigItems: [\n        { driverType: 'Focuser', num: 2, label: 'Sync Focuser Step', value: '', inputType: 'text' },\n        { driverType: 'Focuser', num: 2, label: 'Min Limit', value: '', inputType: 'number' },\n        { driverType: 'Focuser', num: 2, label: 'Max Limit', value: '', inputType: 'number' },\n      ],\n\n      PoleCameraConfigItems: [\n\n      ],\n\n      CFWConfigItems: [\n\n      ],\n\n      BeforeChangeConfigItems: [],\n\n\n\n      imageData: null,\n\n      histogramImage: null,\n      histogram_min: 0,    // \n      histogram_max: 255,  // \n\n      currentHistogramMin: 0,\n      currentHistogramMax: 255,\n\n      ImageGainR: 1,\n      ImageGainB: 1,\n\n      ImageOffset: 0,\n\n      ImageCFA: 'BG',\n\n      cameraBin: 1,   // binning\n\n      CanvasWidth: 1920,  // \n      CanvasHeight: 1080, // \n\n      scale: 1, // \n      translateX: 0, // x\n      translateY: 0, // y\n      bufferCanvas: null, // \n      bufferCtx: null, // \n      tempCanvas: null, // \n      tempCtx: null, // \n\n      visibleWidth: 0, // \n      visibleHeight: 0, // \n      visibleX: 0, // x\n      visibleY: 0, // y\n      isDragging: false, // \n      pendingScaleChange: false, // \n\n      touchStartX: 0, // x\n      touchStartY: 0, // y\n      startDistance: 0, // \n\n      moveIntervalId: null, // \n      zoomIntervalId: null, // \n\n\n      imageWidth: 0, // \n      imageHeight: 0, // \n      drawImgData: null,\n      OriginalImage: null,\n      detectStarsImg: null,\n\n      isNotDrawStars: true,\n\n      mainCameraSizeX: 0,\n      mainCameraSizeY: 0,\n\n      ImageProportion: 0,\n\n      DetectedStarsList: [],\n      DetectedStarsFinish: false,\n\n      CartesianList: [],\n\n      PolarPoint_Altitude: 0,\n\n      LastPoint_AzAlt: null,\n\n      MarkCircleNum: 0,\n\n      LastCircle_RaDec: null,\n      LastCircle_AzAlt: null,\n\n      Circles: [],\n\n      // \n      calibrationCircles: [],  // \n      adjustmentCircles: [],   // \n      targetPointCircle: null, // \n      fakePolarAxisCircle: null, // \n      lastPosition: null,      // \n      fieldUpdateTimer: null,  // \n      fieldOfViewPolygons: [], // \n\n      drawer_2: null,    // \n\n      drivers: [], // \n      selectedDriver: null, // \n\n      devicesList: [], // \n      selectedDevice: null, // \n      ToBeConnectDevice: [],\n\n      loadingSelectDriver: false,\n      loadingConnectAllDevice: false,\n\n      CurrentLocationLng: 0,\n      CurrentLocationLat: 0,\n\n      histogramData: [],\n\n      ImageArrayBuffer: null,\n\n      isOpenDevicePage: false, // \n      isOpenPowerPage: false, // \n\n      OutPutPower_1_ON: true,\n      OutPutPower_2_ON: false,\n\n      isPolarAxisMode: false,\n\n      isTouching: false, // \n      ConnectBtnPressTimer: null,\n      ConnectBtnlongPressThreshold: 1000,\n      isConnectBtnLongPress: false, // \n      ConnectBtnCanClick: true,\n\n\n      haveDeviceConnect: false,\n      isConnecting: false, // \n\n      disconnectTimeoutTriggered: false,\n      disconnectTimeout: null,\n\n      isDownloadingImage: false,\n      isDownloadingImageName: '',\n      isWaitingLogged: false, // \n\n      showDisconnectDialog: false,\n      currentDisconnectDriverName: '',\n\n      enableMainCanvasClick: false, // \n\n      lastImageProcessParams: { // \n        blackLevel: 0,\n        whiteLevel: 65535,\n        CFA: 'null',\n        analysis: null,\n        isColorCamera: false,\n      },\n      focuserPictureFileName: '',  // \n      isProcessingImage: false,   // \n      isFocusLoopShooting: false,  // ROi\n      focuserROIStarsList: [],  // ROIx,y,HFR\n      selectStarX: -1,\n      selectStarY: -1,\n      DrawSelectStarX: -1,\n      DrawSelectStarY: -1,\n      DrawSelectStarHFR: -1,\n      ROI_x: -1,    // ROIx,vue\n      ROI_y: -1,    // ROIy,vue\n      ROI_x_qt: -1,    // ROIx,qt\n      ROI_y_qt: -1,    // ROIy,qt\n      ROI_length: 300, // ROI\n      showSelectStar: false,\n\n      isOneTouch: false,\n      currentTouchX: [0, 0],\n      currentTouchY: [0, 0],\n      startTouchX: [0, 0],\n      startTouchY: [0, 0],\n      startTouchDistance: 0,\n\n      // \n      BaudRateItems: [\n        { label: '9600', value: 9600 },\n        { label: '19200', value: 19200 },\n        { label: '38400', value: 38400 },\n        { label: '57600', value: 57600 },\n        { label: '115200', value: 115200 },\n        { label: '230400', value: 230400 },\n      ],\n      BaudRateSelected: 9600, // \n      cpuTemp: null,  // CPU\n      cpuUsage: null, // CPU\n\n      progressValue: 0,// \n      progressDescription: '', // \n\n      calculateGain: true, // \n      lutCache: {\n        lastParams: null, // \n        lutR: null,\n        lutG: null,\n        lutB: null\n      },\n    }\n  },\n  components: {\n    Gui,\n    GuiLoader,\n    ProgressBar,\n    // MessageBox,\n  },\n  created() {\n    this.$bus.$on('AppSendMessage', this.sendMessage);\n    this.$bus.$on('AppUpdateDevices', this.updateDevices);\n    this.$bus.$on('Switch-MainPage', this.handleButtonTestClick);\n    this.$bus.$on('HandleHistogramNum', this.applyHistStretch);\n    this.$bus.$on('ImageGainR', this.ImageGainSet);\n    this.$bus.$on('ImageGainB', this.ImageGainSet);\n    this.$bus.$on('Offset', this.ImageOffsetSet);\n    this.$bus.$on('Binning', this.BinningSet);\n    this.$bus.$on('Gain', this.GainSet);\n    this.$bus.$on('Offset', this.OffsetSet);\n    this.$bus.$on('ImageCFA', this.ImageCFASet);\n    // this.$bus.$on('MainCameraCFA', this.ImageCFASet);\n    this.$bus.$on('Temperature', this.CameraTemperatureSet);\n    this.$bus.$on('Focal Length (mm)', this.FocalLengthSet);\n    this.$bus.$on('Guider Focal Length (mm)', this.GuiderFocalLengthSet);\n    this.$bus.$on('Multi Star Guider', this.MultiStarGuiderSet);\n    this.$bus.$on('Guider Pixel size', this.GuiderPixelSizeSet);\n    this.$bus.$on('Guider Gain', this.GuiderGainSet);\n    this.$bus.$on('Calibration step (ms)', this.CalibrationDurationSet);\n    this.$bus.$on('Ra Aggression', this.RaAggressionSet);\n    this.$bus.$on('Dec Aggression', this.DecAggressionSet);\n    this.$bus.$on('Sync Focuser Step', this.SyncFocuserStep);\n    this.$bus.$on('GotoThenSolve', this.GotoThenSolve);\n    this.$bus.$on('AutoFlip', this.AutoFlipSet);\n    this.$bus.$on('WestMinutesPastMeridian', this.WestMinutesPastMeridianSet);\n    this.$bus.$on('EastMinutesPastMeridian', this.EastMinutesPastMeridianSet);\n    this.$bus.$on('ImageProportion', this.setImageProportion);\n    this.$bus.$on('MountGoto', this.lookatcircle);\n    this.$bus.$on('SwitchImageToShow', this.SwitchImageToShow);\n    this.$bus.$on('PolarPointAltitude', this.setPolarPointAltitude);\n    this.$bus.$on('showStelCanvas', this.showStelCanvas);\n    this.$bus.$on('RecalibratePolarAxis', this.RecalibratePolarAxis);\n    this.$bus.$on('CurrentExpTimeList', this.CurrentExpTimeList);\n    this.$bus.$on('disconnectAllDevice', this.disconnectAllDevice);\n    this.$bus.$on('GetConnectedDevices', this.ReturnConnectedDevices);\n    this.$bus.$on('CurrentCFWList', this.CurrentCFWList);\n    this.$bus.$on('calcWhiteBalanceGains', this.calcWhiteBalanceGains);\n    this.$bus.$on('SwitchOutPutPower', this.SwitchOutPutPower);\n    this.$bus.$on('PolarAxisMode', this.PolarAxisMode);\n    this.$bus.$on('SendConsoleLogMsg', this.SendConsoleLogMsg);\n    // this.$bus.$on('DisconnectDriverSuccess', this.disconnectDriversuccess);\n    this.$bus.$on('UnBindingDevice', this.UnBindingDevice);\n    this.$bus.$on('CloseWebView', this.QuitToMainApp)\n    this.$bus.$on('RedBoxSizeChange', this.RedBoxSizeChange);\n    this.$bus.$on('setFocuserState', this.setFocuserState);  // \n    this.$bus.$on('setShowSelectStar', this.setShowSelectStar);  // \n    this.$bus.$on('ScaleChange', this.ScaleChange);\n    this.$bus.$on('showCanvas', this.showCanvas);\n\n    // \n    this.$bus.$on('DrawCalibrationPointPolygon', this.drawCalibrationPointPolygon);\n    this.$bus.$on('ClearCalibrationPoints', this.clearCalibrationPoints);\n    this.$bus.$on('DrawAdjustmentPointsPolygon', this.drawAdjustmentPointsPolygon);\n    this.$bus.$on('DrawTargetPointCircle', this.drawTargetPointCircle);\n    this.$bus.$on('DrawFakePolarAxisCircle', this.DrawFakePolarAxisCircle)\n\n    // \n    this.$bus.$on('StartCalibration', this.startCalibrationProcess);\n    this.$bus.$on('UpdateCalibrationInfo', this.updateCalibrationInfo);\n    this.$bus.$on('EndCalibration', this.endCalibration);\n\n    this.memoryCheckInterval = setInterval(this.checkMemoryUsage, 30000);\n\n\n  },\n  methods: {\n    // step \n    allowsDecimal(item) {\n      const step = item.step ?? 1;\n      return item.allowDecimal === true || !Number.isInteger(step) || String(step).includes('.');\n    },\n    //  min<0 \n    allowsNegative(item) {\n      return item.allowNegative === true || (typeof item.min === 'number' && item.min < 0);\n    },\n    // \n    getInputMode(item) {\n      // \n      if (!this.isMobile) return undefined;\n      //  decimal/\n      return this.allowsDecimal(item) || this.allowsNegative(item) ? 'decimal' : 'numeric';\n    },\n    //  iOSpattern \n    getPattern(item) {\n      const neg = this.allowsNegative(item);\n      if (this.allowsDecimal(item)) {\n        //  .  , \n        return neg ? '^[-]?[0-9]*([.,][0-9]*)?$' : '^[0-9]*([.,][0-9]*)?$';\n      }\n      // \n      return neg ? '^[-]?[0-9]*$' : '^[0-9]*$';\n    },\n\n    numberRules(item) {\n      return [\n        v => v === '' || v === null || !isNaN(this._toNumber(v)) || '',\n        v => item.min === undefined || this._toNumber(v) >= item.min || ` ${item.min}`,\n        v => item.max === undefined || this._toNumber(v) <= item.max || ` ${item.max}`,\n      ];\n    },\n\n    // \n    _toNumber(v) {\n      if (v === '' || v === null || v === undefined) return NaN;\n      if (typeof v === 'number') return v;\n      const s = String(v).trim().replace(',', '.');\n      return Number(s);\n    },\n\n    onNumberCommit(item) {\n      let v = this._toNumber(item.value);\n      if (!Number.isFinite(v)) return;\n\n      // 1)  min/max\n      if (item.min !== undefined && v < item.min) v = item.min;\n      if (item.max !== undefined && v > item.max) v = item.max;\n\n      // 2)  step  min  0 \n      const step = item.step ?? 1;\n      if (step > 0) {\n        const base = (item.min !== undefined ? item.min : 0);\n        v = base + Math.round((v - base) / step) * step;\n        if (item.min !== undefined && v < item.min) v = item.min;\n        if (item.max !== undefined && v > item.max) v = item.max;\n        v = Number(v.toFixed(12)); // \n      }\n\n      // \n      item.value = v;\n      this.handleConfigChange(item.label, v);\n    },\n    checkMemoryUsage() {\n      if (window.performance && window.performance.memory) {\n        const memoryInfo = window.performance.memory;\n        const used = Math.round(memoryInfo.usedJSHeapSize / 1048576);\n        const limit = Math.round(memoryInfo.jsHeapSizeLimit / 1048576);\n\n        // console.log(`: ${used}MB / ${limit}MB`);\n\n        if (memoryInfo.usedJSHeapSize > memoryInfo.jsHeapSizeLimit * 0.7) {\n          this.$bus.$emit('showWarning', this.$i18n.locale === 'cn' ?\n            '' :\n            'Memory usage is approaching limit. Please save your work and refresh the page.');\n\n          // \n          if (window.gc) {\n            try { window.gc(); } catch (e) { }\n          }\n        }\n      }\n    },\n\n    formatTipValue(item) {\n      return (item && item.displayValue != null)\n        ? String(item.displayValue)\n        : (item && item.value != null ? String(item.value) : '-');\n    },\n    formatTipTitle(item) {\n      if (item && item.tooltip != null) return String(item.tooltip);\n      if (item && item.value != null) return String(item.value);\n      return '';\n    },\n    copyTip(item) {\n      const text = (item && item.value != null) ? String(item.value) : '';\n      if (!text) return;\n      if (navigator && navigator.clipboard && navigator.clipboard.writeText) {\n        navigator.clipboard.writeText(text);\n      }\n    },\n\n    preventDefault(event) {\n      event.preventDefault();\n    },\n    getLocationHostName() {\n      const hostname = window.location.hostname;\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const port = window.location.protocol === 'https:' ? '8601' : '8600';\n      this.SendConsoleLogMsg('location hostname:' + hostname, 'info');\n      this.WebSocketUrl = `${protocol}//${hostname}:${port}`;\n      console.log('WebSocketUrl:', this.WebSocketUrl);\n    },\n    getQTClientVersion() {\n      this.sendMessage('Vue_Command', 'getQTClientVersion');\n    },\n    connect() {\n      //  WebSocket \n      // this.websocket = new WebSocket('ws://192.168.2.31:8600');  // process.env.VUE_APP_WEBSOCKET\n      // this.websocket = new WebSocket(process.env.VUE_APP_WEBSOCKET);\n      const wsOptions = {\n        rejectUnauthorized: false  // \n      };\n      this.websocket = new WebSocket(this.WebSocketUrl, [], wsOptions);\n\n      this.websocket.onopen = () => {\n        this.websocketState = 'connected';\n        this.networkDisconnected = false; // WebSocket\n        if (this.disconnectTimeoutTriggered) {\n          this.callShowMessageBox('WebSocket connected', 'success');\n        }\n        this.$bus.$emit('ShowNetStatus', 'true');\n        this.StatusRecovery();\n        console.log('process.env.NODE_ENV:', process.env.NODE_ENV);\n      };\n\n      this.websocket.onmessage = (message) => {\n        // console.log('QHYCCD | Received message:', message.data);\n\n        const data = JSON.parse(message.data);\n\n        if (data.type === 'QT_Return') {\n          const parts = data.message.split(':');\n          let messageType;\n          if (parts.length > 0) {\n            messageType = parts[0];\n            // console.log('QHYCCD | ('+messageType+'):', parts);\n          }\n          else {\n            console.error(':', data.message);\n            return;\n          }\n          let acceptMessage = false;\n          if (data.message.startsWith('StagingScheduleData:')) {\n            console.log('------------------------------');\n            acceptMessage = true;\n            const parts = data.message.split('[');\n\n            if (parts.length > 0) {\n              console.log('parts.length: ', parts.length);\n              this.$bus.$emit('StagingScheduleData', data.message);\n            }\n            console.log('------------------------------');\n          }\n\n          if (data.message.startsWith('SendDebugMessage|')) {\n            acceptMessage = true;\n            const parts = data.message.split('|');\n            if (parts.length === 3) {\n              const type = parts[1];\n              const message = parts[2];\n              this.$bus.$emit('SendDebugMessage', type, message);\n            }\n          }\n\n          if (!acceptMessage) {\n            switch (messageType) {\n              case 'AddDriver':\n                if (parts.length === 3) {\n                  const label = parts[1];\n                  const value = parts[2];\n                  const type = this.CurrentDriverType;\n                  // \n                  const driver = { type, label, value };\n\n                  // if (type === 'MainCamera' && label === \"QHY CCD2\") {\n                  //   break;\n                  // }\n                  // if (type === 'Guider' && label === \"QHY CCD\") {\n                  //   break;\n                  // }\n\n                  // label\"QHY CCD\"\"QFocuser\"\n                  if (label === \"QHY CCD\" || label === \"QFocuser\" || label === \"QHY CCD2\") {\n                    this.drivers.unshift(driver); // \n                  } else {\n                    this.drivers.push(driver); // \n                  }\n                }\n                break;\n\n              case 'AddDevice':\n                if (parts.length === 2) {\n                  const label = parts[1];\n                  console.log('QHYCCD | AddDevice: ', label);\n                  // const value = parts[2];\n                  const type = this.confirmDriverType;\n                  // \n                  const device = { type, label, label };\n                  console.log('QHYCCD | AddDevice: ', device);\n                  // this.$bus.$emit('add-device', device);\n                  this.devicesList.push(device);\n\n                  this.ToBeConnectDevice = [];\n                  this.devicesList.forEach(devicesList => {\n                    if (devicesList.type === this.CurrentDriverType) {\n                      this.ToBeConnectDevice.push(devicesList);\n                    }\n                  });\n\n                  this.loadingSelectDriver = false;\n                }\n                break;\n\n              case 'updateDevices_':\n                if (parts.length === 3) {\n                  const ListNum = parts[1];\n                  const name = parts[2];\n                  this.updateDevices_(ListNum, name);\n                }\n                break;\n\n              case 'ConnectSuccess':\n                if (parts.length === 4) {\n                  const type = parts[1];\n                  const deviceName = parts[2];\n                  const driverName = parts[3];\n\n                  if (deviceName != '') {\n                    this.updateDevicesConnect(type, deviceName, driverName, true);\n                  } else {\n                    this.updateDevicesConnect(type, deviceName, driverName, false);\n                  }\n                }\n                break;\n\n              case 'ConnectFailed':\n                if (parts.length === 2) {\n                  const reason = parts[1];\n                  this.callShowMessageBox(reason, 'error');\n                  this.loadingConnectAllDevice = false;\n                }\n                break;\n\n              case 'ScanFailed':\n                if (parts.length === 2) {\n                  const reason = parts[1];\n                  this.callShowMessageBox(reason, 'error');\n                  this.loadingSelectDriver = false;\n                }\n                break;\n\n              case 'AddDeviceType':\n                if (parts.length === 2) {\n                  const DeviceType = parts[1];\n                  this.$bus.$emit('AddDeviceType', DeviceType);\n                }\n                break;\n\n              case 'DeviceToBeAllocated':\n                if (parts.length === 4) {\n                  const DeviceType = parts[1];\n                  const DeviceIndex = parts[2];\n                  const DeviceName = parts[3];\n                  this.$bus.$emit('DeviceToBeAllocated', DeviceIndex, DeviceName);\n                }\n                break;\n\n              case 'ShowDeviceAllocationWindow':\n                this.$bus.$emit('toggleDeviceAllocationPanel');\n                this.nav = false;\n                break;\n\n              case 'ExposureCompleted':\n                this.$bus.$emit('ExposureCompleted');\n                break;\n\n              case 'SaveJpgSuccess':\n                if (parts.length === 4) {\n                  const fileName = parts[1];\n                  const roi_x = parseInt(parts[2]);\n                  const roi_y = parseInt(parts[3]);\n                  this.ROI_x = roi_x;\n                  this.ROI_y = roi_y;\n\n                  // this.$bus.$emit('showRoiImage', fileName);\n                  this.showRoiImage(fileName, roi_x, roi_y);\n                }\n                break;\n\n              case 'SaveBinSuccess':\n                if (parts.length === 2) {\n                  const fileName = parts[1];\n                  this.readBinFile('img/' + fileName);\n                  this.DetectedStarsFinish = false;\n                }\n                break;\n\n\n              case 'SaveGuiderImageSuccess':\n                if (parts.length === 2) {\n                  const fileName = parts[1];\n                  this.loadAndDisplayImage('img/' + fileName);\n                }\n                break;\n              case 'GuideSize':\n                if (parts.length === 3) {\n                  const col = parts[1];\n                  const row = parts[2];\n                  this.$bus.$emit(\"GuideSize\", col, row);\n                }\n\n              case 'AddScatterChartData':\n                if (parts.length === 3) {\n                  const Data_x = parts[1];\n                  const Data_y = parts[2];\n                  const newDataPoint = [Data_x, Data_y];\n                  this.$bus.$emit('AddScatterChartData', newDataPoint);\n                }\n                break;\n\n              case 'AddLineChartData':\n                if (parts.length === 4) {\n                  const Data_x = parts[1];\n                  const Data_Ra = parts[2];\n                  const Data_Dec = parts[3];\n                  const newDataPoint_Ra = [Data_x, Data_Ra];\n                  const newDataPoint_Dec = [Data_x, Data_Dec];\n                  this.$bus.$emit('AddLineChartData', newDataPoint_Ra, newDataPoint_Dec);\n                }\n                break;\n\n              case 'SetLineChartRange':\n                if (parts.length === 3) {\n                  const min = parts[1];\n                  const max = parts[2];\n                  this.$bus.$emit('SetLineChartRange', min, max);\n                }\n                break;\n\n              case 'GuiderStatus':\n                if (parts.length === 2) {\n                  const status = parts[1];\n                  this.$bus.$emit('GuiderStatus', status);\n                }\n                break;\n\n              case 'FocusChangeSpeedSuccess':\n                if (parts.length === 2) {\n                  const Speed = parts[1];\n                  this.$bus.$emit('FocusChangeSpeedSuccess', Speed);\n                }\n                break;\n\n\n              case 'FocusPosition':\n                if (parts.length === 3) {\n                  const CurrentPosition = parts[1];\n                  const TargetPosition = parts[2];\n                  this.$bus.$emit('FocusPosition', CurrentPosition, TargetPosition);\n                }\n                break;\n\n              case 'FocusMoveDone':\n                if (parts.length === 3) {\n                  const CurrentPosition = parts[1];\n                  const FWHM = parts[2];\n                  this.$bus.$emit('UpdateFWHM', CurrentPosition, FWHM);\n                  this.$bus.$emit('addData_Point', CurrentPosition, FWHM);\n                }\n                break;\n\n              case 'addMinPointData_Point':\n                if (parts.length === 3) {\n                  const x = parseInt(parts[1]);\n                  const y = parseFloat(parts[2]);\n                  this.$bus.$emit('addMinPointData_Point', x, y);\n                }\n                break;\n              case 'addLineData_Point':\n                if (parts.length === 4) {\n                  const a = parseFloat(parts[1]);\n                  const b = parseFloat(parts[2]);\n                  const c = parseFloat(parts[3]);\n                  console.log('addLineData_Point:', a, b, c);\n                  this.$bus.$emit('addLineData_Point', a, b, c);\n                }\n                break;\n              case 'MainCameraSize':\n                if (parts.length === 3) {\n                  const SizeX = parts[1];\n                  const SizeY = parts[2];\n                  this.$bus.$emit('MainCameraSize', SizeX, SizeY);\n                  this.mainCameraSizeX = SizeX;\n                  this.mainCameraSizeY = SizeY;\n                }\n                break;\n\n              case 'MainCameraBinning':\n                if (parts.length === 2) {\n                  this.cameraBin = parseInt(parts[1]);\n                  this.MainCameraConfigItems.find(item => item.label === 'Binning').value = this.cameraBin;\n                  this.$bus.$emit('MainCameraBinning', this.cameraBin);\n                }\n                break;\n\n              case 'fitQuadraticCurve':\n                this.$bus.$emit('ClearfitQuadraticCurve');\n                for (let x = 0; x <= 601; x += 1) {\n                  const a = parts[x];\n                  const b = a.split('|');\n                  if (b.length === 2) {\n                    const x = b[0];\n                    const y = b[1];\n                    this.$bus.$emit('fitQuadraticCurve', x, y);\n                  }\n                }\n                break;\n\n              case 'fitQuadraticCurve_minPoint':\n                const x = parts[1];\n                const y = parts[2];\n                this.$bus.$emit('fitQuadraticCurve_minPoint', x, y);\n                break;\n\n\n              case 'TelescopePark':\n                if (parts.length === 2) {\n                  const Switch = parts[1];\n                  this.$bus.$emit('MountParkSwitch', Switch);\n                }\n                break;\n\n              case 'TelescopeTrack':\n                if (parts.length === 2) {\n                  const Switch = parts[1];\n                  this.$bus.$emit('MountTrackSwitch', Switch);\n                }\n                break;\n\n              case 'MountSetSpeedSuccess':\n                if (parts.length === 2) {\n                  const num = parts[1];\n                  this.$bus.$emit('newMountSlewRate', num);\n                }\n                break;\n\n\n              case 'TelescopePierSide':\n                if (parts.length === 2) {\n                  const Side = parts[1];\n                  this.$bus.$emit('updateMountPierSide', Side);\n                }\n                break;\n\n              case 'TelescopeTotalSlewRate':\n                if (parts.length === 2) {\n                  const num = parts[1];\n                  this.$bus.$emit('MountTotalSlewRate', num);\n                }\n                break;\n\n\n              case 'UpdateScheduleProcess':\n                if (parts.length === 3) {\n                  const RowNum = parts[1];\n                  const Process = parts[2];\n                  this.$bus.$emit('UpdateScheduleProcess', RowNum, Process);\n                }\n                break;\n\n              case 'ExpTimeList':\n                if (parts.length === 2) {\n                  this.$bus.$emit('initExpTimeList', parts[1]);\n                }\n                break;\n\n\n              case 'CameraInExposuring':\n                if (parts.length === 2) {\n                  const status = parts[1];\n                  this.$bus.$emit('CameraInExposuring', status);\n                }\n                break;\n\n              case 'AutoFocusOver':\n                this.$bus.$emit('AutoFocusOver');\n                break;\n\n              case 'CFWPositionMax':\n                if (parts.length === 2) {\n                  this.$bus.$emit('SetCFWPositionMax', parts[1]);\n\n                  for (let i = 1; i <= parts[1]; i++) {\n                    this.CFWConfigItems.push({ driverType: 'CFW', label: `CFW [${i}]`, value: '', inputType: 'text' });\n                  }\n\n                  this.$bus.$emit('AppSendMessage', 'Vue_Command', 'getCFWList');\n                }\n                break;\n\n\n              case 'SetCFWPositionSuccess':\n                if (parts.length === 2) {\n                  this.$bus.$emit('SetCFWPositionSuccess', parts[1]);\n                }\n                break;\n\n              case 'getCFWList':\n                if (parts.length === 2) {\n                  this.$bus.$emit('initCFWList', parts[1]);\n                }\n                break;\n\n              case 'GuiderSwitchStatus':\n                if (parts.length === 2) {\n                  this.$bus.$emit('GuiderSwitchStatus', parts[1]);\n                }\n                break;\n\n              case 'GuiderLoopExpStatus':\n                if (parts.length === 2) {\n                  this.$bus.$emit('GuiderLoopExpStatus', parts[1]);\n                }\n                break;\n\n              case 'TelescopeRADEC':\n                if (parts.length === 3) {\n                  this.UpdateCirclePos(parts[1], parts[2]);\n                  this.$bus.$emit('updateCurrentLocation', parts[1], parts[2]);\n                }\n                break;\n\n\n              case 'TelescopeStatus':\n                if (parts.length === 2) {\n                  this.UpdateTelescopeStatus(parts[1]);\n                }\n                break;\n\n              case 'MainCameraStatus':\n                if (parts.length === 2) {\n                  this.UpdateMainCameraStatus(parts[1]);\n                }\n                break;\n\n\n              case 'MainCameraTemperature':\n                if (parts.length === 2) {\n                  this.UpdateMainCameraTemperature(parts[1]);\n                }\n                break;\n\n\n              case 'ShowAllImageFolder':\n                if (parts.length === 3) {\n                  this.$bus.$emit('ShowAllImageFolder', parts[1], parts[2]);\n                }\n                break;\n\n\n              case 'ImageFilesName':\n                if (parts.length === 2) {\n                  this.$bus.$emit('ImageFilesName', parts[1]);\n                }\n                break;\n\n\n              case 'USBCheck':\n                if (parts.length === 2) {\n                  const USBdata = parts[1].split(',');\n                  console.log('USB name: ', USBdata[0]);\n                  console.log('USB space: ', USBdata[1]);\n                  this.SendConsoleLogMsg('USB name:' + USBdata[0], 'info');\n                  this.SendConsoleLogMsg('USB space:' + USBdata[1], 'info');\n\n                  this.$bus.$emit('USB_Name_Sapce', USBdata[0], USBdata[1]);\n                }\n                break;\n\n              case 'ImageSaveErroe':\n                if (parts.length === 2) {\n                  const Erroe = parts[1];\n                  if (Erroe === 'USB-Null') {\n                    this.callShowMessageBox('No USB Drive Detected.', 'error');\n                  } else if (Erroe === 'USB-Multiple') {\n                    this.callShowMessageBox('Multiple USB drives detected, please remove excess USB drives.', 'error');\n                  }\n                }\n                break;\n\n              case 'DetectedStars':\n                console.log('Detected', parts.length, 'stars.');\n                this.SendConsoleLogMsg('Detected ' + parts.length + ' stars.', 'info');\n                this.DetectedStarsList = [];\n                for (let i = 0; i < parts.length; i++) {\n                  const a = parts[i];\n                  const b = a.split('|');\n                  if (b.length === 3) {\n                    const x = b[0];\n                    const y = b[1];\n                    const hfr = b[2];\n                    // console.log('Stars at(', x, ',', y, ') with HFR:', hfr);\n                    this.DetectedStarsList.push({ x: x, y: y, hfr: hfr });\n                  }\n                }\n                this.DetectedStarsFinish = true;\n                break;\n\n              case 'SolveImageResult':\n                if (parts.length === 5) {\n                  // this.UpdateCirclePos(parts[1], parts[2]);\n                  console.log('Solve Image Result(RA_Degree, DEC_Degree, Azimuth, Altitude):', parts[1], ',', parts[2], ',', parts[3], ',', parts[4]);\n                  this.SendConsoleLogMsg('Solve Image Result(RA_Degree, DEC_Degree, Azimuth, Altitude):' + parts[1] + ',' + parts[2] + ',' + parts[3] + ',' + parts[4], 'info');\n                  this.SolveResultMark(parts[1], parts[2], parts[3], parts[4]);\n                  this.$bus.$emit(\"ImageSolveFinished\", true);\n                  this.$bus.$emit('setParsingProgress', false);\n                }\n                break;\n\n              case 'SolveFovResult':\n                if (parts.length === 9) {\n                  const RaDec = [\n                    { Ra: parts[1], Dec: parts[2] },\n                    { Ra: parts[3], Dec: parts[4] },\n                    { Ra: parts[5], Dec: parts[6] },\n                    { Ra: parts[7], Dec: parts[8] },\n                  ];\n                  this.SolveFovMark(RaDec);\n                }\n                break;\n\n              case 'RealTimeSolveImageResult':\n                if (parts.length === 5) {\n                  console.log('Solve Image Result(RA_Degree, DEC_Degree, Azimuth, Altitude):', parts[1], ',', parts[2], ',', parts[3], ',', parts[4]);\n                  this.SendConsoleLogMsg('Solve Image Result(RA_Degree, DEC_Degree, Azimuth, Altitude):' + parts[1] + ',' + parts[2] + ',' + parts[3] + ',' + parts[4], 'info');\n                  const result = this.SolveResultMark_RealTime(parts[1], parts[2], parts[3], parts[4])\n                }\n                break;\n\n              case 'SolveImageSucceeded':\n                console.log('');\n                this.$bus.$emit(\"handleOperationComplete\", \"solve\");\n                this.$bus.$emit('showMsgBox', 'Solve image succeed!', 'success');\n                break;\n\n              case 'SolveImagefailed':\n                this.callShowMessageBox('Solve image faild...', 'error');\n                this.$bus.$emit(\"ImageSolveFinished\", false);\n                this.$bus.$emit('setParsingProgress', false);\n                this.$bus.$emit('MountOperationComplete', 'solve');\n                break;\n\n              case 'MainCameraOffsetRange':\n                if (parts.length === 3) {\n                  console.log('MainCameraOffsetRange:', parts[1], ',', parts[2]);\n                  this.SendConsoleLogMsg('MainCameraOffsetRange:' + parts[1] + ',' + parts[2], 'info');\n                  this.MainCameraOffsetMin = parts[1];\n                  this.MainCameraOffsetMax = parts[2];\n\n                  const OffsetItem = this.MainCameraConfigItems.find(item => item.label === 'Offset');\n                  if (OffsetItem) {\n                    console.log('MainCameraOffsetRange:', parseInt(this.MainCameraOffsetMin, 10), ',', parseInt(this.MainCameraOffsetMax, 10));\n                    OffsetItem.inputMin = parseInt(this.MainCameraOffsetMin, 10);\n                    OffsetItem.inputMax = parseInt(this.MainCameraOffsetMax, 10);\n                  }\n                }\n                break;\n\n              case 'MainCameraGainRange':\n                if (parts.length === 3) {\n                  console.log('MainCameraGainRange:', parts[1], ',', parts[2]);\n                  this.SendConsoleLogMsg('MainCameraGainRange:' + parts[1] + ',' + parts[2], 'info');\n                  this.MainCameraGainMin = parts[1];\n                  this.MainCameraGainMax = parts[2];\n\n                  const gainItem = this.MainCameraConfigItems.find(item => item.label === 'Gain');\n                  if (gainItem) {\n                    console.log('MainCameraGainRange:', parseInt(this.MainCameraGainMin, 10), ',', parseInt(this.MainCameraGainMax, 10));\n                    gainItem.inputMin = parseInt(this.MainCameraGainMin, 10);\n                    gainItem.inputMax = parseInt(this.MainCameraGainMax, 10);\n                  }\n                }\n                break;\n\n              case 'OutputPowerStatus':\n                if (parts.length === 3) {\n                  const index = parseInt(parts[1], 10);\n                  const value = parseInt(parts[2], 10);\n\n                  if (index === 1) {\n                    this.OutPutPower_1_ON = value === 1;\n                  } else if (index === 2) {\n                    this.OutPutPower_2_ON = value === 1;\n                  }\n                }\n                break;\n\n              case 'PHD2StarBoxView':\n                if (parts.length === 2) {\n                  const view = parts[1];\n                  this.$bus.$emit('PHD2StarBoxView', view);\n                }\n                break;\n\n              case 'PHD2StarCrossView':\n                if (parts.length === 2) {\n                  const view = parts[1];\n                  this.$bus.$emit('PHD2StarCrossView', view);\n                }\n                break;\n\n              case 'PHD2StarBoxPosition':\n                if (parts.length === 5) {\n                  const PHD2ImageSize_X = parseInt(parts[1], 10);\n                  const PHD2ImageSize_Y = parseInt(parts[2], 10);\n                  const Box_X = parseInt(parts[3], 10);\n                  const Box_Y = parseInt(parts[4], 10);\n                  this.DrawPHD2Box(PHD2ImageSize_X, PHD2ImageSize_Y, Box_X, Box_Y);\n                }\n                break;\n\n              case 'PHD2MultiStarsPosition':\n                if (parts.length === 5) {\n                  const PHD2ImageSize_X = parseInt(parts[1], 10);\n                  const PHD2ImageSize_Y = parseInt(parts[2], 10);\n                  const Box_X = parseInt(parts[3], 10);\n                  const Box_Y = parseInt(parts[4], 10);\n                  this.DrawPHD2MultiStars(PHD2ImageSize_X, PHD2ImageSize_Y, Box_X, Box_Y);\n                }\n                break;\n\n              case 'ClearPHD2MultiStars':\n                this.$bus.$emit('ClearPHD2MultiStars');\n                break;\n\n              case 'PHD2StarCrossPosition':\n                if (parts.length === 5) {\n                  const PHD2ImageSize_X = parseInt(parts[1], 10);\n                  const PHD2ImageSize_Y = parseInt(parts[2], 10);\n                  const Cross_X = parseInt(parts[3], 10);\n                  const Cross_Y = parseInt(parts[4], 10);\n                  this.DrawPHD2Cross(PHD2ImageSize_X, PHD2ImageSize_Y, Cross_X, Cross_Y);\n                }\n                break;\n\n              case 'QTClientVersion':\n                if (parts.length === 2) {\n                  this.QTClientVersion = parts[1];\n                }\n                break;\n\n\n              case 'CaptureImageSaveStatus':\n                if (parts.length === 2) {\n                  const status = parts[1];\n                  if (status === 'Repeat') {\n                    this.callShowMessageBox(this.$t('There is no need to save it again'), 'error');\n                  } else if (status === 'Success') {\n                    this.callShowMessageBox(this.$t('Image saved successfully'), 'success');\n                  } else if (status === 'Null') {\n                    this.callShowMessageBox(this.$t('No images to save'), 'error');\n                  }\n                }\n                break;\n\n              case 'INDIServerDebug':\n                if (parts.length === 2) {\n                  const message = parts[1];\n                  this.$bus.$emit('INDIServerDebug', message);\n                }\n                break;\n\n              case 'HotspotName':\n                if (parts.length === 2) {\n                  const Name = parts[1];\n                  this.$bus.$emit('HotspotName', Name);\n                }\n                break;\n              case 'EditHotspotNameSuccess':\n                this.$bus.$emit('EditHotspotNameSuccess');\n                break;\n\n              case 'DSLRsSetup':\n                if (parts.length === 2) {\n                  const Name = parts[1];\n                  this.$bus.$emit('ShowDSLRsSetup', Name);\n                }\n                break;\n\n              case 'ConfigureRecovery':\n                if (parts.length === 3) {\n                  const ConfigName = parts[1];\n                  const ConfigValue = parts[2];\n                  console.log('Configure:', ConfigName, ',', ConfigValue);\n                  this.SendConsoleLogMsg('Configure Recovery:' + parts[1] + ',' + parts[2], 'info');\n                  this.$bus.$emit(ConfigName, ConfigValue);\n\n                  if (parts[1] === 'FocalLength') {\n                    this.TelescopesConfigItems[0].value = parts[2];\n                    for (const device of this.devices) {\n                      if (device.driverType === 'Telescopes') {\n                        if (parts[2] === '' || parts[2] === NaN) {\n                          device.device = '';\n                          device.isConnected = false;\n                        } else {\n                          device.device = parts[2] + ' mm';\n                          device.isConnected = true;\n                        }\n                      }\n                    }\n                  }\n\n                  if (parts[1] === 'GuiderFocalLength') {\n                    this.GuiderConfigItems[0].value = parts[2];\n                    this.$bus.$emit('AppSendMessage', 'Vue_Command', 'GuiderFocalLength:' + parts[2]);\n                  }\n\n                  if (parts[1] === 'Coordinates') {\n                    const [latStr, lngStr, isAutoStr] = parts[2].split(',').map(item => item.trim());\n                    const lat = parseFloat(latStr);\n                    const lng = parseFloat(lngStr);\n                    const isAuto = isAutoStr === 'true' || isAutoStr === '1';\n                    this.SetCurrentLocation(lat, lng, isAuto);\n                  }\n\n                  if (parts[1] === 'MultiStarGuider') {\n                    this.GuiderConfigItems[1].value = (parts[2] === 'true');\n                    this.$bus.$emit('AppSendMessage', 'Vue_Command', 'MultiStarGuider:' + parts[2]);\n                  }\n\n                  if (parts[1] === 'GuiderGain') {\n                    this.GuiderConfigItems[2].value = parts[2];\n                    this.$bus.$emit('AppSendMessage', 'Vue_Command', 'GuiderGain:' + parts[2]);\n                  }\n\n                  if (parts[1] === 'CalibrationDuration') {\n                    this.GuiderConfigItems[3].value = parts[2];\n                    this.$bus.$emit('AppSendMessage', 'Vue_Command', 'CalibrationDuration:' + parts[2]);\n                  }\n\n                  if (parts[1] === 'RaAggression') {\n                    this.GuiderConfigItems[4].value = parts[2];\n                    this.$bus.$emit('AppSendMessage', 'Vue_Command', 'RaAggression:' + parts[2]);\n                  }\n\n                  if (parts[1] === 'DecAggression') {\n                    this.GuiderConfigItems[5].value = parts[2];\n                    this.$bus.$emit('AppSendMessage', 'Vue_Command', 'DecAggression:' + parts[2]);\n                  }\n                }\n                break;\n\n\n              case 'ConnectDriverSuccess':\n                if (parts.length === 2) {\n                  const device = parts[1];\n                  this.connectDriverSuccess(device);\n                }\n                break;\n\n              case 'ConnectDriverFailed':\n                if (parts.length === 2) {\n                  const message = parts[1];\n                  this.connectDriverFailed(message);\n                }\n                break;\n\n              case 'DisconnectDriverSuccess':\n                if (parts.length === 2) {\n                  const device = parts[1];\n                  this.disconnectDriversuccess(device);\n                }\n                break;\n\n              case 'DisconnectDriverFail':\n                if (parts.length === 2) {\n                  const driver = parts[1];\n                  this.disconnectDriverFail(device)\n                }\n\n              case 'SelectedDriverList':\n                if (parts.length >= 3) {\n                  const deviceObjects = parts.slice(1).reduce((acc, part, index, array) => {\n                    if (index % 2 === 0) {\n                      acc.push({ [array[index]]: array[index + 1] });\n                    }\n                    return acc;\n                  }, []);\n                  this.loadSelectedDriverList(deviceObjects);\n                }\n                break;\n\n\n              case 'BindDeviceList':\n                if (parts.length >= 3) {\n                  const deviceObjects = parts.slice(1).reduce((acc, part, index, array) => {\n                    if (index % 2 === 0) {\n                      acc.push({ [array[index]]: array[index + 1] });\n                    }\n                    return acc;\n                  }, []);\n                  this.loadBindDeviceList(deviceObjects);\n                }\n                break;\n\n\n              case 'BindDeviceTypeList':\n                if (parts.length >= 5) { // \n                  const deviceTypeObjects = [];\n                  for (let i = 1; i < parts.length; i += 4) {\n                    const deviceTypeObject = {\n                      Type: parts[i],\n                      DeviceName: parts[i + 1],\n                      DriverName: parts[i + 2],\n                      isbind: parts[i + 3] == \"true\" ? true : false,\n                    };\n                    deviceTypeObjects.push(deviceTypeObject);\n                  }\n                  this.loadBindDeviceTypeList(deviceTypeObjects);\n                }\n                break;\n\n              case 'deleteDeviceAllocationList':\n                if (parts.length === 2) {\n                  const deviceName = parts[1];\n                  this.deleteDeviceAllocationList(deviceName);\n                }\n                break;\n\n              case 'deleteDeviceTypeAllocationList':\n                if (parts.length === 2) {\n                  const deviceType = parts[1];\n                  if (deviceType != '') {\n                    this.$bus.$emit('deleteDeviceTypeAllocationList', deviceType);\n                  }\n                  if (deviceType == 'CFW') {\n                    for (let i = 0; i < this.devices.length; i++) {\n                      if (this.devices[i].driverType == 'CFW') {\n                        this.devices[i].isConnected = false;\n                        this.devices[i].device = '';\n                        this.devices[i].driverName = '';\n                        this.devices[i].BaudRate = 9600;\n                        this.$bus.$emit('CFWConnected', 0);\n                      }\n                    }\n                  }\n                }\n                break;\n\n              case 'ParseInfoEmitted':\n                if (parts.length === 2) {\n                  const progress = parts[1];\n                  this.$bus.$emit('ParseInfoEmitted', progress);\n                }\n                break;\n\n              case 'GuiderUpdateStatus':\n                if (parts.length === 2) {\n                  const status = parts[1];\n                  this.$bus.$emit('GuiderUpdateStatus', parseInt(status, 10));\n                }\n                break;\n\n              case 'LoopSolveImageFinished':\n                this.$bus.$emit('LoopSolveImageFinished');\n                break;\n\n              case 'disconnectDevicehasortherdevice':\n                if (parts.length === 2) {\n                  const drivername = parts[1];\n                  this.showSelectdisconnectDriver(drivername);\n                }\n                break;\n\n              case 'getFocuserMoveState':\n                this.$bus.$emit('getFocuserMoveState');\n                break;\n\n              case 'FocusMoveToLimit':\n                if (parts.length === 2) {\n                  const errorlog = parts[1];\n                  this.callShowMessageBox(errorlog, 'error');\n                }\n                break;\n\n              case 'startFocusLoopFailed':\n                if (parts.length === 2) {\n                  const message = parts[1];\n                  this.$bus.$emit('startFocusLoopFailed', message);\n                }\n                break;\n\n              case 'setFocuserLoopingState':\n                if (parts.length === 2) {\n                  const message = parts[1];\n                  this.$bus.$emit('setFocuserLoopingState', message);\n                  if (message == 'true') {\n                    this.isFocusLoopShooting = true;\n                  } else {\n                    this.isFocusLoopShooting = false;\n                  }\n                }\n                break;\n\n              case 'focuserROIStarsList':\n                if (parts.length === 4) {\n                  const x = parts[1];\n                  const y = parts[2];\n                  const HFR = parts[3];\n                  this.focuserROIStarsList.push({ x, y, HFR });\n                }\n                break;\n\n              // case 'clearFocuserROIStarsList':\n              //   this.focuserROIStarsList = [];\n              //   break;\n\n              case 'setSelectStarPosition':\n                if (parts.length === 4) {\n                  this.DrawSelectStarX = parseFloat(parts[1]);\n                  this.DrawSelectStarY = parseFloat(parts[2]);\n                  this.DrawSelectStarHFR = parseFloat(parts[3]);\n                }\n                break;\n\n              case 'SetRedBoxState':\n                if (parts.length === 4) {\n                  const length = parseInt(parts[1]);\n                  this.ROI_x = parseFloat(parts[2]);\n                  this.ROI_y = parseFloat(parts[3]);\n\n                  this.setRedBoxState(length, this.ROI_x, this.ROI_y);\n                  console.log('ROI: ', length, this.ROI_x, this.ROI_y);\n                }\n                break;\n\n              case 'SetVisibleArea':\n                if (parts.length === 4) {\n                  this.visibleX = parseFloat(parts[1]);\n                  this.visibleY = parseFloat(parts[2]);\n                  this.scale = parseFloat(parts[3]);\n                  this.$bus.$emit('setScale', this.scale);\n                  console.log(': ', this.visibleX, this.visibleY, this.scale);\n                  this.SendConsoleLogMsg('update VisibleArea x=' + this.visibleX + ', y=' + this.visibleY + ', scale=' + this.scale, 'info');\n                }\n                break;\n\n              case 'SetSelectStars':\n                if (parts.length === 3) {\n                  this.selectStarX = parseFloat(parts[1]);\n                  this.selectStarY = parseFloat(parts[2]);\n                  this.SendConsoleLogMsg('update SelectStars x=' + this.selectStarX + ', y=' + this.selectStarY, 'info');\n                }\n                break;\n\n              case 'updateCPUInfo':\n                if (parts.length === 3) {\n                  let cpuTemp = parseFloat(parts[1]);\n                  let cpuUsage = parseFloat(parts[2]);\n                  this.cpuTemp = isNaN(cpuTemp) ? null : (cpuTemp % 1 === 0 ? cpuTemp : cpuTemp.toFixed(1));  //  cpuTemp  NaN null cpuTemp \n                  this.cpuUsage = isNaN(cpuUsage) ? null : (cpuUsage % 1 === 0 ? cpuUsage : cpuUsage.toFixed(1));  //  cpuUsage  NaN null cpuUsage \n                  this.$bus.$emit('updateCPUInfo', this.cpuTemp, this.cpuUsage);\n                }\n                break;\n\n              case 'TianWen':\n                if (parts.length === 4) {\n                  const notice_type = parts[1];\n                  const ra = parts[2];\n                  const dec = parts[3];\n                  this.$bus.$emit('TianWen', notice_type, ra, dec);\n                }\n                break;\n\n              case 'setMainCameraParameters':\n                if (parts.length >= 3) {\n                  let parameters = {};\n                  for (let i = 1; i < parts.length; i += 2) {\n                    const parameter = parts[i];\n                    const value = parts[i + 1];\n                    parameters[parameter] = value;\n                  }\n                  this.setMainCameraParameters(parameters);\n                }\n                break;\n\n              case 'localMessage':\n                if (parts.length === 4) {\n                  const lat = parts[1];\n                  const lon = parts[2];\n                  const language = parts[3];\n                  this.SendConsoleLogMsg('2------------localMessage: ' + lat + ',' + lon + ',' + language, 'info');\n                  if (language == 'zh') {\n                    this.$bus.$emit('ClientLanguage', 'cn');\n                  } else {\n                    this.$bus.$emit('ClientLanguage', 'en');\n                  }\n                  this.$bus.$emit('setLocationLatAndLon', lat, lon);\n                }\n                break;\n\n              case 'isAutoLocation':\n                if (parts.length === 2) {\n                  const isAutoLocation = parts[1];\n                  this.$bus.$emit('isAutoLocation', isAutoLocation);\n                }\n                break;\n\n              case 'sendGetLocation':\n                if (parts.length === 3) {\n                  const lat = parts[1];\n                  const lon = parts[2];\n                  this.SendConsoleLogMsg('sendGetLocation: ' + lat + ',' + lon, 'info');\n                  this.$bus.$emit('sendGetLocation', lat, lon);\n                }\n                break;\n\n              case 'MainCameraCFA':\n                if (parts.length === 2) {\n                  let value = parts[1];\n                  if (value === '') {\n                    value = 'null';\n                  } else if (value === 'GRBG') {\n                    value = 'GR';\n                  } else if (value === 'GBRG') {\n                    value = 'GB';\n                  } else if (value === 'BGGR') {\n                    value = 'BG';\n                  } else if (value === 'RG') {\n                    value = 'RGGB';\n                  }\n                  this.ImageCFA = value;\n                  console.log(\"  MainCameraCFA: \", this.ImageCFA);\n                  this.MainCameraConfigItems.find(item => item.label === 'ImageCFA').value = this.ImageCFA;\n                }\n                break;\n\n              case 'CameraNotIdle':\n                this.callShowMessageBox('Camera is not idle', 'error');\n                this.$bus.$emit('MountOperationComplete', 'solve');\n                break;\n\n              case 'MainCameraNotConnect':\n                this.callShowMessageBox('Main Camera is not connect', 'error');\n                this.$bus.$emit('MountOperationComplete', 'solve');\n                break;\n              case 'ServerInitSuccess':\n                this.callShowMessageBox('Server init success', 'success');\n                window.location.reload();\n                break;\n              case 'PolarAlignmentState':\n                if (parts.length === 4) {\n                  const state = parts[1];\n                  const message = parts[2];\n                  const percentage = parts[3];\n                  this.$bus.$emit('PolarAlignmentState', state, message, percentage);\n                }\n                break;\n              case 'PolarAlignmentAdjustmentGuideData':\n                if (parts.length === 21) {  // 1721\n                  const ra = parseFloat(parts[1]);\n                  const dec = parseFloat(parts[2]);\n                  // \n                  const ra0 = parseFloat(parts[3]);\n                  const dec0 = parseFloat(parts[4]);\n                  const ra1 = parseFloat(parts[5]);\n                  const dec1 = parseFloat(parts[6]);\n                  const ra2 = parseFloat(parts[7]);\n                  const dec2 = parseFloat(parts[8]);\n                  const ra3 = parseFloat(parts[9]);\n                  const dec3 = parseFloat(parts[10]);\n\n                  const targetra = parseFloat(parts[11]);\n                  const targetdec = parseFloat(parts[12]);\n                  const offsetra = parseFloat(parts[13]);\n                  const offsetdec = parseFloat(parts[14]);\n                  const adjustmentra = parts[15];\n                  const adjustmentdec = parts[16];\n                  const fakePolarRA = parseFloat(parts[17]);\n                  const fakePolarDEC = parseFloat(parts[18]);\n                  const realPolarRA = parseFloat(parts[19]);\n                  const realPolarDEC = parseFloat(parts[20]);\n\n\n                  // console.log(': ', ra, dec, targetra, targetdec, fakePolarRA, fakePolarDEC, realPolarRA, realPolarDEC);\n                  console.log(': ', ra0, dec0, ra1, dec1, ra2, dec2, ra3, dec3);\n\n                  // max/min\n                  this.$bus.$emit('FieldDataUpdate', [ra, dec, ra0, dec0, ra1, dec1, ra2, dec2, ra3, dec3, targetra, targetdec, fakePolarRA, fakePolarDEC, realPolarRA, realPolarDEC]);\n\n                  // console.log(': ', offsetra, offsetdec, adjustmentra, adjustmentdec);\n                  this.$bus.$emit('updateCardInfo', ra, dec, targetra, targetdec, offsetra, offsetdec, adjustmentra, adjustmentdec, \"deg\");\n\n                }\n                break;\n\n              case 'focusMoveFailed':\n                if (parts.length === 2) {\n                  const message = parts[1];\n                  this.callShowMessageBox(message, 'error');\n                  this.$bus.$emit('focusMoveFailed', message);\n                }\n\n              case 'focusMoveFailed':\n                if (parts.length === 2) {\n                  const message = parts[1];\n                  this.callShowMessageBox(message, 'error');\n                  this.$bus.$emit('focusMoveFailed', message);\n                }\n                break;\n\n              case 'MeridianETA_hms': {\n                if (parts.length >= 4) {\n                  const h = parts[1];\n                  const m = parts[2];\n                  const s = parts[3];\n\n                  const hms = `${h}:${m}:${s}`;\n                  const item = this.MountConfigItems.find(i => i.label === 'Flip ETA');\n                  if (item) {\n                    item.value = hms;\n                    item.displayValue = hms;\n                  }\n                }\n                break;\n              }\n\n              case 'AutoFlip':\n                if (parts.length >= 2) {\n                  const isAutoFlip = parts[1];\n                  //  \"AutoFlip\" \n                  let item = this.MountConfigItems.find(i => i.label === 'AutoFlip');\n                  if (item) {\n                    //   \n                    item.value = isAutoFlip == 'true';\n                  } else {\n                    //   \n                    this.MountConfigItems.push({ driverType: 'Mount', label: 'AutoFlip', value: isAutoFlip == 'true', inputType: 'switch' },);\n                  }\n                }\n                break;\n\n              // case 'MinutesPastMeridian':\n              //   if (parts.length >= 3) {\n              //     const EastMinutesPastMeridian = parts[1];\n              //     const WestMinutesPastMeridian = parts[2];\n              //     let item = this.MountConfigItems.find(i => i.label === 'EastMinutesPastMeridian');\n              //     if (item) {\n              //       item.value = EastMinutesPastMeridian;\n              //     } else {\n              //       this.MountConfigItems.push({ driverType: 'Mount', label: 'EastMinutesPastMeridian', value: EastMinutesPastMeridian,min:-180,max:180, inputType: 'number' },);\n              //     }\n              //     item = this.MountConfigItems.find(i => i.label === 'WestMinutesPastMeridian');\n              //     if (item) {\n              //       item.value = WestMinutesPastMeridian;\n              //     } else {\n              //       this.MountConfigItems.push({ driverType: 'Mount', label: 'WestMinutesPastMeridian', value: WestMinutesPastMeridian,min:-180,max:180, inputType: 'number' },);\n              //     }\n              //   }\n              //   break;\n              case 'EastMinutesPastMeridian':\n                if (parts.length === 2) {\n                  const EastMinutesPastMeridian = parts[1];\n                  let item = this.MountConfigItems.find(i => i.label === 'EastMinutesPastMeridian');\n                  if (item) {\n                    item.value = EastMinutesPastMeridian;\n                  } else {\n                    this.MountConfigItems.push({ driverType: 'Mount', label: 'EastMinutesPastMeridian', value: EastMinutesPastMeridian, min: -180, max: 180, inputType: 'number' },);\n                  }\n                }\n                break;\n              case 'WestMinutesPastMeridian':\n                if (parts.length === 2) {\n                  const WestMinutesPastMeridian = parts[1];\n                  let item = this.MountConfigItems.find(i => i.label === 'WestMinutesPastMeridian');\n                  if (item) {\n                    item.value = WestMinutesPastMeridian;\n                  } else {\n                    this.MountConfigItems.push({ driverType: 'Mount', label: 'WestMinutesPastMeridian', value: WestMinutesPastMeridian, min: -180, max: 180, inputType: 'number' },);\n                  }\n                }\n                break;\n              case 'GotoThenSolve':\n                if (parts.length === 2) {\n                  const GotoThenSolve = parts[1];\n                  let item = this.MountConfigItems.find(i => i.label === 'GotoThenSolve');\n                  if (item) {\n                    item.value = GotoThenSolve;\n                  }\n                }\n                break;\n\n              case 'addFwhmNow':\n                if (parts.length >= 2) {\n                  const fwhm = parseFloat(parts[1]);\n                  console.log('Received addFwhmNow:', fwhm);\n                  this.$bus.$emit('addFwhmNow', fwhm);\n                }\n                break;\n\n              default:\n                console.warn(': ', data.message);\n                break;\n            }\n          }\n        }\n        else if (data.type === 'QT_Confirm') {\n          // \n          const messageId = data.msgid;\n          this.handleMessageResponse(messageId);\n        } else if (data.type === 'Process_Command') {\n          console.log('Process_Command: ', data.message);\n          // \n          const parts = data.message.split(':');\n          if (parts[0] === 'qtServerIsOver') {\n            this.callShowMessageBox('QT Server is over', 'error');\n            this.ShowConfirmDialog('restart', 'QT server encountered a segmentation fault or is frozen, please restart or exit!', 'restartQtServer');\n          }\n          else if (parts[0] === 'checkHasNewUpdatePack') {\n            if (parts.length === 2) {\n              const version = parts[1];\n              this.SendConsoleLogMsg(': ' + version, 'info');\n\n              this.ShowConfirmDialog('ForceUpdate', this.$t('checkHasNewUpdatePack') + ': ' + version + '' + this.$t('updateConfirm'), 'updateCurrentClient:' + version);\n            }\n          }\n          else if (parts[0] === 'No_update_pack_found') {\n            this.callShowMessageBox(this.$t('No_update_pack_found'), 'error');\n          } else if (parts[0] === 'update_progress') {\n            this.$bus.$emit('update_progress', data.message);\n          } else if (parts[0] === 'update_error') {\n            this.$bus.$emit('update_error', data.message);\n          } else if (parts[0] === 'update_success') {\n            this.$bus.$emit('update_success', data.message);\n          } else if (parts[0] === 'testQtServerProcess') {\n\n          }\n          else {\n            console.warn(': ', data.message);\n          }\n        }\n\n        this.receivedMessages.push(data.message); // \n      };\n\n      this.websocket.onerror = (error) => {\n        const errorDetails = {\n          type: error.type,\n          timestamp: new Date().toISOString(),\n          url: this.WebSocketUrl,\n          readyState: this.websocket.readyState,\n          protocol: this.websocket.protocol,\n          extensions: this.websocket.extensions\n        };\n        console.error('WebSocket Error Details:', errorDetails);\n        this.SendConsoleLogMsg('WebSocket Error: ' + JSON.stringify(errorDetails), 'error');\n        this.websocketState = 'error';\n        this.networkDisconnected = true;\n      };\n\n      this.websocket.onclose = () => {\n        console.log('QHYCCD | WebSocket disconnected');\n        this.websocketState = 'disconnected';\n        this.networkDisconnected = true; // WebSocket\n        console.log('QHYCCD | WebSocket disconnected');\n        this.$bus.$emit('ShowNetStatus', 'false');\n\n        // 1\n        this.disconnectTimeout = setTimeout(() => {\n          if (this.networkDisconnected) { // 1\n            this.callShowMessageBox('WebSocket disconnected', 'error');\n            this.disconnectTimeoutTriggered = true;\n          }\n        }, 1000); // 1\n\n        // \n        this.reconnectWebSocket();\n      };\n    },\n\n    // \n    reconnectWebSocket() {\n      setTimeout(() => {\n        console.log('QHYCCD | WebSocket reconnected');\n        this.SendConsoleLogMsg('WebSocket reconnected.', 'info');\n        this.connect();\n      }, 2000); // 2\n    },\n    // \n\n    //\n    setupNetworkStatusListener() {\n      window.addEventListener('online', () => {\n        // \n        if (this.disconnectTimeoutTriggered) {\n          this.callShowMessageBox('WebSocket connected', 'success');\n        }\n        clearTimeout(this.disconnectTimeout); // \n        this.networkDisconnected = false; // \n        this.$bus.$emit('ShowNetStatus', 'true');\n        this.StatusRecovery();\n        this.reconnectWebSocket(); // WebSocket\n      });\n\n      window.addEventListener('offline', () => {\n        this.networkDisconnected = true; // \n        this.$bus.$emit('ShowNetStatus', 'false');\n        this.disconnectTimeoutTriggered = false; // \n        // 1\n        this.disconnectTimeout = setTimeout(() => {\n          if (this.networkDisconnected) { // 1\n            this.disconnectTimeoutTriggered = true; // \n            this.callShowMessageBox('WebSocket disconnected', 'error');\n          }\n        }, 1000); // 1\n      });\n    },\n    //\n\n    sendMessage(type, message) {\n      console.log(\"QHYCCD | sendMessage: \", message);\n\n      const messageId = this.generateMessageId(); // ID\n      const messageObj = { type: type, msgid: messageId, message: message }; // \n      const messageJson = JSON.stringify(messageObj); //  JSON \n      const messageState = { msgid: messageId, text: messageJson, success: false }; // \n\n      if (this.websocket.readyState === WebSocket.OPEN) {\n        this.websocket.send(messageJson);\n        // messageState.success = true; // \n      }\n      this.sentMessages.push(messageState); // \n    },\n\n    generateMessageId() {\n      // ID\n      return Date.now() + \"-\" + (this.messageCounter++);\n    },\n\n    handleMessageResponse(messageId) {\n      // ID\n      const lastMessage = this.sentMessages[this.sentMessages.length - 1];\n      if (lastMessage && lastMessage.msgid === messageId) {\n        lastMessage.success = true;\n      }\n    },\n\n    // \n    callShowMessageBox(msg, type) {\n      console.log('QHYCCD | callShowMessageBox:', msg, type);\n      this.SendConsoleLogMsg(msg, type);\n      this.$bus.$emit('showMsgBox', msg, type);\n    },\n    // \n\n    locationClicked: function () {\n      this.$bus.$emit('Vue_Command', 'localMessage'); // \n      this.$store.commit('toggleBool', 'showLocationDialog');\n\n      this.$bus.$emit('ResetTime');\n    },\n\n    SetCurrentLocation(lat, lng, isAuto) {\n      console.log('SetCurrentLocation:', lat, ',', lng);\n      this.$bus.$emit('SendConsoleLogMsg', 'Set Current Location:' + lat + ',' + lng, 'info');\n      this.$bus.$emit('PolarPointAltitude', lat);\n      this.$bus.$emit('resetLocation', lat, lng, isAuto);\n      const loc = {\n        short_name: 'Unknown',\n        country: 'Unknown',\n        lng: lng,\n        lat: lat,\n        alt: 0,\n        accuracy: 0,\n        street_address: ''\n      }\n      this.$store.commit('setCurrentLocation', loc);\n\n      this.$bus.$emit('ShowPositionInfo', lat, lng);\n\n      setTimeout(() => {\n        this.$bus.$emit('ResetTime');\n      }, 1000);\n    },\n    // \n    StatusRecovery() {\n      // this.sendMessage('SendConsoleLogMsg', '!', 'warning');\n      this.getQTClientVersion();                // QTClient\n      this.sendMessage('Vue_Command', 'getROIInfo'); // ROI\n      this.sendMessage('Vue_Command', 'localMessage'); // \n      this.sendMessage('Vue_Command', 'getLastSelectDevice'); // \n      this.sendMessage('Vue_Command', 'getMainCameraParameters'); // \n      this.sendMessage('Vue_Command', 'getMountParameters'); // UI\n      this.RecalibratePolarAxis(); // \n      this.sendMessage('Vue_Command', 'getStagingSolveResult'); // \n      this.sendMessage('Vue_Command', 'getFocuserLoopingState'); // \n      this.sendMessage('Vue_Command', 'getStagingScheduleData'); // \n      this.sendMessage('Vue_Command', 'getStagingSolveResult'); // \n      this.sendMessage('Vue_Command', 'getGPIOsStatus'); // GPIO\n      // this.sendMessage('Vue_Command', 'getStagingImage'); // \n      this.sendMessage('Vue_Command', 'getPolarAlignmentState'); // \n\n\n      this.disconnectTimeoutTriggered = false;\n    },\n\n    openPowerManagerPage() {\n      this.isOpenDevicePage = false;\n      this.isOpenPowerPage = true;\n\n      this.drawer_2 = true;\n    },\n\n    QuitToMainApp() {\n      this.sendMessage('Broadcast_Msg', 'CloseWebView');\n    },\n\n    selectDevice(device) {\n      if (!this.haveDeviceConnect || (this.haveDeviceConnect) || device.driverType === 'Telescopes') {\n        this.isOpenDevicePage = true;\n        this.isOpenPowerPage = false;\n\n        if (device.isget === false) {\n          // device.isget = true;\n          this.sendMessage('Vue_Command', 'SelectIndiDriver:' + device.type + \":\" + device.ListNum);\n          this.drivers = [];\n        }\n\n        this.CurrentDriverType = device.driverType;\n        this.DeviceIsConnected = device.isConnected;\n        this.BaudRateSelected = device.BaudRate;\n        if (device.driverType === 'Telescopes') {\n          this.DeviceIsConnected = true;\n        }\n\n        this.drawer_2 = true;\n\n        this.ToBeConnectDevice = [];\n        this.devicesList.forEach(devicesList => {\n          if (devicesList.type === this.CurrentDriverType) {\n            this.ToBeConnectDevice.push(devicesList);\n          }\n        });\n      } else {\n        this.callShowMessageBox('The device is not connected.', 'error');\n      }\n\n    },\n\n    CurrentConfigItems() {\n      console.log('CurrentConfigItems: ', this.CurrentDriverType + 'ConfigItems');\n      switch (this.CurrentDriverType) {\n        case 'Guider':\n          return this.GuiderConfigItems;\n        case 'MainCamera':\n          return this.MainCameraConfigItems;\n        case 'Mount':\n          return this.MountConfigItems;\n        case 'Telescopes':\n          return this.TelescopesConfigItems;\n        case 'Focuser':\n          return this.FocuserConfigItems;\n        case 'PoleCamera':\n          return this.PoleCameraConfigItems;\n        case 'CFW':\n          return this.CFWConfigItems;\n        default:\n          return [];\n      }\n    },\n\n    confirmDriver() {\n      // \n      console.log(\"QHYCCD | confirmDriver: \", this.selectedDriver);\n      this.SendConsoleLogMsg('Confirm Indi Driver:' + this.selectedDriver, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'ConfirmIndiDriver:' + this.selectedDriver + ':' + this.BaudRateSelected);\n      this.confirmDriverType = this.CurrentDriverType;\n      this.loadingSelectDriver = true;\n\n      this.devices.forEach(device => {\n        if (device.driverType === this.CurrentDriverType) {\n          device.device = this.selectedDriver;\n          device.driverName = this.selectedDriver;\n          device.BaudRate = this.BaudRateSelected;\n        }\n      });\n    },\n    clearDriver() {\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'ClearIndiDriver');\n      this.SendConsoleLogMsg('Clear Indi Driver', 'info');\n      this.devices.forEach(device => {\n        if (device.driverType === this.CurrentDriverType) {\n          device.device = '';\n          device.driverName = '';\n          device.BaudRate = 9600;\n        }\n      });\n      this.selectedDriver = '';\n    },\n    confirmDevice() {\n      // \n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'ConfirmIndiDevice:' + this.selectedDevice + ':' + this.selectedDriver);\n      // this.$bus.$emit('AppUpdateDevices', this.CurrentDriverType, this.selectedDevice);\n      this.updateDevices(this.CurrentDriverType, this.selectedDevice);\n    },\n\n    updateDevices(driverType, newDevice) {    // \n      this.devices.forEach(device => {\n        if (device.driverType === driverType) {\n          device.device = newDevice;\n        }\n      });\n    },\n\n    updateDevices_(ListNum, newDevice) {    // \n      this.devices.forEach(device => {\n        if (device.ListNum === ListNum) {\n          device.device = newDevice;\n        }\n      });\n      this.loadingConnectAllDevice = false;\n    },\n\n    updateDevicesConnect(type, DeviceName, DriverName, isBind = true) {    // \n      this.SendConsoleLogMsg('updateDevicesConnect' + type + ' ' + DeviceName + ' ' + DriverName + ' ' + isBind, 'info');\n      this.devices.forEach(device => {\n        if (device.driverType === type) {\n          if (isBind == true) {\n            device.device = DeviceName;\n          } else {\n            device.device = \"Not Bind Device\";\n          }\n          device.driverName = DriverName;\n          device.isConnected = true;\n        }\n      });\n      this.callShowMessageBox(DeviceName + ' success connected', 'success');\n      this.haveDeviceConnect = true;\n      this.loadingConnectAllDevice = false;\n\n      if (type === 'MainCamera') {\n        this.$bus.$emit('MainCameraConnected', 1);\n        console.log('MainCamera is Connected.');\n      } else if (type === 'Mount') {\n        this.$bus.$emit('MountConnected', 1);\n        console.log('Mount is Connected.');\n      } else if (type === 'CFW') {\n        this.$bus.$emit('CFWConnected', 1);\n        console.log('Mount is Connected.');\n      } else if (type === 'Focuser') {\n        this.$bus.$emit('FocuserConnected', 1);\n        console.log('Focuser is Connected.');\n      } else if (type === 'Guider') {\n        this.$bus.$emit('GuiderConnected', 1);\n        console.log('Guider is Connected.');\n      }\n      console.log('updateDevicesConnect: ', type, DeviceName, DriverName, isBind);\n\n      this.$bus.$emit('DeviceConnectSuccess', type, DeviceName, DriverName, isBind);\n    },\n    startConnectBtnPress(event) {\n      // \n      if (event.type === 'touchstart') {\n        this.isTouching = true;\n        this.isConnectBtnLongPress = false; // \n        // this.ConnectBtnPressTimer = setTimeout(() => {\n        //   this.isConnectBtnLongPress = true; // \n        //   this.handleConnectBtnLongPress();\n        // }, this.ConnectBtnlongPressThreshold);\n        this.handleConnectBtnClick();\n      }\n      // \n      else if (event.type === 'mousedown' && !this.isTouching) {\n        this.isConnectBtnLongPress = false; // \n        // this.ConnectBtnPressTimer = setTimeout(() => {\n        //   this.isConnectBtnLongPress = true; // \n        //   this.handleConnectBtnLongPress();\n        // }, this.ConnectBtnlongPressThreshold);\n        this.handleConnectBtnClick();\n      }\n    },\n    endConnectBtnPress(event) {\n      // \n      if (event.type === 'touchend') {\n        clearTimeout(this.ConnectBtnPressTimer); // \n        // if (!this.isConnectBtnLongPress) {\n        //   this.handleConnectBtnClick(); // \n        // }\n        this.handleConnectBtnClick();\n        this.ConnectBtnPressTimer = null; // \n        this.isTouching = false; // \n      }\n      // \n      else if (event.type === 'mouseup' && !this.isTouching) {\n        clearTimeout(this.ConnectBtnPressTimer); // \n        // if (!this.isConnectBtnLongPress) {\n        //   this.handleConnectBtnClick(); // \n        // }\n        this.handleConnectBtnClick();\n        this.ConnectBtnPressTimer = null; // \n      }\n    },\n    handleConnectBtnClick() {\n      if (this.haveDeviceConnect) {\n        this.callShowMessageBox('Please disconnect all devices first.', 'error');\n        return;\n      }\n      if (!this.ConnectBtnCanClick) return; // \n      this.ConnectBtnCanClick = false; // \n      console.log(\"Connect Button clicked\");\n\n      this.connectAllDevice();\n\n      // \n      setTimeout(() => {\n        this.ConnectBtnCanClick = true;\n      }, 1000); // 1\n    },\n    handleConnectBtnLongPress() {\n      if (this.haveDeviceConnect) {\n        this.callShowMessageBox('Please disconnect all devices first.', 'error');\n        return;\n      }\n      // \n      console.log(\"Connect Button long pressed\");\n\n      this.autoConnectAllDevice();\n    },\n    connectAllDevice() {\n      console.log(\"QHYCCD | connectAllDevice.\");\n      this.SendConsoleLogMsg('Connect All Device', 'info');\n      this.sendMessage('Vue_Command', 'connectAllDevice');\n      this.loadingConnectAllDevice = true;\n    },\n    autoConnectAllDevice() {\n      console.log(\"QHYCCD | autoConnectAllDevice.\");\n      this.SendConsoleLogMsg('Auto Connect All Device', 'info');\n      this.sendMessage('Vue_Command', 'autoConnectAllDevice');\n      this.loadingConnectAllDevice = true;\n    },\n\n    disconnectAllDevice(confirm) {\n      //  isConnected  true\n      // const hasConnectedDevices = this.devices.some(device => device.isConnected);\n\n      if (this.haveDeviceConnect) {\n        if (confirm === false) {\n          this.ShowConfirmDialog('Confirm', 'Are you sure you want to disconnect all devices?', 'disconnectAllDevice');\n        } else {\n          this.sendMessage('Vue_Command', 'disconnectAllDevice');\n          this.SendConsoleLogMsg('Disconnect All Device', 'info');\n          this.haveDeviceConnect = false;\n          // this.devices.forEach(device => {\n          //   device.isConnected = false;\n          //   // device.device = '';\n          // });\n\n          this.$bus.$emit('MainCameraConnected', 0);\n          this.$bus.$emit('MountConnected', 0);\n          this.$bus.$emit('CFWConnected', 0);\n          this.$bus.$emit('FocuserConnected', 0);\n          this.$bus.$emit('GuiderConnected', 0);\n          this.clearDeviceList();\n        }\n      } else {\n        this.callShowMessageBox('No devices have been connected.', 'error');\n      }\n      this.selectedDriver = '';\n    },\n\n    clearDeviceList() {\n      this.devices.forEach(device => {\n        device.device = device.driverName;\n        device.isConnected = false;\n        device.isget = false;\n        device.BaudRate = 9600;\n      });\n      this.ToBeConnectDevice = [];\n      this.devicesList = [];\n      this.drivers = [];\n      this.$bus.$emit('clearDeviceAllocationList');\n    },\n\n    SwitchOutPutPower(index, isPowerON) {\n      if (isPowerON) {\n        this.drawer_2 = false;\n        this.ShowConfirmDialog('Output Power:' + index, 'Are you sure you want to turn off this output power?', 'SwitchOutPutPower');\n      } else {\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'SwitchOutPutPower:' + index);\n        this.SendConsoleLogMsg('Switch OutPutPower' + index, 'info');\n      }\n    },\n\n    RestartRaspberryPi() {\n      this.drawer_2 = false;\n      this.ShowConfirmDialog('Restart', 'Are you sure you want to restart the Raspberry Pi?', 'RestartRaspberryPi');\n    },\n\n    ShutdownRaspberryPi() {\n      this.drawer_2 = false;\n      this.ShowConfirmDialog('Shut Down', 'Are you sure you want to shut down the Raspberry Pi?', 'ShutdownRaspberryPi');\n    },\n\n    ForceUpdate() {\n      this.drawer_2 = false;\n      this.ShowConfirmDialog('Force Update', 'Are you sure you want to force update the Raspberry Pi?', 'ForceUpdate');\n    },\n\n    ReturnConnectedDevices() {\n      this.devices.forEach(device => {\n        if (device.driverType === 'MainCamera') {\n          if (device.isConnected === true) {\n            this.$bus.$emit('MainCameraConnected', 1);\n            console.log('MainCamera is Connected.');\n            this.SendConsoleLogMsg('MainCamera is Connected.', 'info');\n          }\n        } else if (device.driverType === 'Mount') {\n          if (device.isConnected === true) {\n            this.$bus.$emit('MountConnected', 1);\n            console.log('Mount is Connected.');\n            this.SendConsoleLogMsg('Mount is Connected.', 'info');\n          }\n        }\n      });\n      this.sendMessage('Vue_Command', 'loadSelectedDriverList');\n      this.sendMessage('Vue_Command', 'loadBindDeviceList');\n      this.sendMessage('Vue_Command', 'loadBindDeviceTypeList');\n    },\n\n    OpenIamgeFolder() {\n      this.$bus.$emit('ImageManagerPanelOpen');\n      this.nav = false;\n    },\n\n    OpenDebugLog() {\n      this.$bus.$emit('toggleINDIDebugDialog');\n      this.nav = false;\n    },\n\n    SendConsoleLogMsg(message, type) {\n      if (type == 'error') {\n        console.error('Error: ' + message);\n        this.$bus.$emit('SendConsoleLog', type, message);\n      } else if (type == 'info') {\n        console.log('Info: ' + message);\n        this.$bus.$emit('SendConsoleLog', type, message);\n      } else if (type == 'warning') {\n        console.warn('Warning: ' + message);\n        this.$bus.$emit('SendConsoleLog', type, message);\n      } else {\n        console.log('Debug: ' + message);\n      }\n    },\n\n    DeviceAllocation() {\n      this.$bus.$emit('toggleDeviceAllocationPanel');\n      this.nav = false;\n    },\n\n    // CurrentExpTimeList(index, value) {\n    //   const expTimeIndex = this.MainCameraConfigItems.findIndex(item => item.label === 'ExpTime [' + (index + 1) + ']');\n    //   if (expTimeIndex !== -1) { // \n    //     //  ExpTime1 \n    //     this.MainCameraConfigItems[expTimeIndex].value = value;\n    //   } else {\n    //     console.error('ExpTime [' + index + '] configuration item not found.');\n    //   }\n    // },\n\n    CurrentCFWList(index, value) {\n      const expTimeIndex = this.CFWConfigItems.findIndex(item => item.label === 'CFW [' + (index + 1) + ']');\n      if (expTimeIndex !== -1) { // \n        //  ExpTime1 \n        this.CFWConfigItems[expTimeIndex].value = value;\n      } else {\n        console.error('CFW [' + index + '] configuration item not found.');\n      }\n    },\n\n    confirmConfiguration(List) {\n      List.forEach(item => {\n        if (item.value !== '') {\n          // console.log(item.label, item.value);\n          this.SendConsoleLogMsg(item.label + ':' + item.value, 'info');\n          this.$bus.$emit(item.label, item.label + ':' + item.value);\n        } else if (item.value == '' && item.label === 'Focal Length (mm)') {\n          this.SendConsoleLogMsg(item.label + 'is NULL', 'info');\n          this.$bus.$emit(item.label, item.label + ':');\n        }\n      });\n      this.callShowMessageBox('Configuration has been modified!', 'success');\n    },\n\n    loadAndDisplayImage(imagePath) {\n      const canvas = document.getElementById('guiderCamera-canvas');\n      // const canvas = document.getElementById('mainCamera-canvas');\n      if (canvas.getContext) {\n        const ctx = canvas.getContext('2d');\n        const img = new Image();\n\n        img.onload = () => {\n          canvas.width = img.width;\n          canvas.height = img.height;\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.drawImage(img, 0, 0);\n          // this.$bus.$emit('showSolveImage', img);\n        };\n\n        // \n        img.onerror = (error) => {\n          console.log(`: ${imagePath}`);\n          this.SendConsoleLogMsg(`: ${imagePath}`, 'error');\n        };\n\n        img.src = imagePath;\n      }\n    },\n\n    ImageGainSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const doubleValue = parseFloat(value); //  double \n\n      if (signal === 'ImageGainR') {\n        //  ImageGainR \n        this.ImageGainR = doubleValue;\n        this.SendConsoleLogMsg('ImageGainR is set to:' + doubleValue, 'info');\n        this.sendMessage('Vue_Command', 'ImageGainR:' + doubleValue);\n      } else if (signal === 'ImageGainB') {\n        //  ImageGainB \n        this.ImageGainB = doubleValue;\n        this.SendConsoleLogMsg('ImageGainB is set to:' + doubleValue, 'info');\n        this.sendMessage('Vue_Command', 'ImageGainB:' + doubleValue);\n      }\n    },\n\n    ImageOffsetSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const doubleValue = parseFloat(value); //  double \n\n      this.ImageOffset = doubleValue;\n      console.log('Image Offset is set to:', doubleValue);\n      this.SendConsoleLogMsg('Image Offset is set to:' + doubleValue, 'info');\n      this.sendMessage('Vue_Command', 'ImageOffset:' + doubleValue);\n    },\n\n    BinningSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value); //  Int \n      this.cameraBin = IntValue;\n      console.log('Image Binning is set to:', IntValue);\n      this.SendConsoleLogMsg('Image Binning is set to:' + IntValue, 'info');\n      this.sendMessage('Vue_Command', 'SetBinning:' + IntValue);\n      this.$bus.$emit('SetBinningNum', IntValue);\n    },\n\n    GainSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value); //  Int \n\n      console.log('Camera Gain is set to:', IntValue);\n      this.SendConsoleLogMsg('Camera Gain is set to:' + IntValue, 'info');\n      this.sendMessage('Vue_Command', 'SetCameraGain:' + IntValue);\n    },\n\n    OffsetSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value); //  Int \n\n      console.log('Camera Offset is set to:', IntValue);\n      this.SendConsoleLogMsg('Camera Offset is set to:' + IntValue, 'info');\n      this.sendMessage('Vue_Command', 'SetCameraOffset:' + IntValue);\n    },\n\n    ImageCFASet(payload) {\n      const [signal, value] = payload.split(':'); // \n\n      // if (['GR', 'GB', 'BG', 'RGGB','null'].includes(value)) {\n      if (['GR', 'GB', 'BG', 'RG', 'GRBG', 'GBRG', 'BGGR', 'RGGB', 'null', ''].includes(value)) {\n        if (value === '') {\n          value = 'null';\n        } else if (value === 'GRBG') {\n          value = 'GR';\n        } else if (value === 'GBRG') {\n          value = 'GB';\n        } else if (value === 'BGGR') {\n          value = 'BG';\n        } else if (value === 'RG') {\n          value = 'RGGB';\n        }\n        this.ImageCFA = value;\n        // console.log('ImageCFA is set to:', value);\n        this.SendConsoleLogMsg('ImageCFA is set to:' + value, 'info');\n        this.sendMessage('Vue_Command', 'ImageCFA:' + value);\n      } else {\n        // console.log(`Invalid value for ImageCFA: '${value}'. Please set it to one of 'GR', 'GB', 'BG', 'RGGB'.`);\n        this.callShowMessageBox(`Invalid value for ImageCFA: '${value}'. Please set it to one of 'GR', 'GB', 'BG', 'RGGB'.`, 'error');\n      }\n    },\n\n    CameraTemperatureSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value); //  Int \n\n      console.log('Camera Temperature is set to:', IntValue);\n      this.SendConsoleLogMsg('Camera Temperature is set to:' + IntValue, 'info');\n      this.sendMessage('Vue_Command', 'SetCameraTemperature:' + IntValue);\n    },\n\n    FocalLengthSet(payload) {\n      const [signal, value] = payload.split(':'); // \n\n      for (const device of this.devices) {\n        if (device.driverType === 'Telescopes') {\n\n          if (value === '' || value === NaN) {\n            device.device = '';\n            this.SendConsoleLogMsg('Focal Length is set to:' + 0, 'info');\n            this.$bus.$emit('SetFocalLengthNum', '');\n          } else {\n            const IntValue = parseInt(value); //  Int \n            device.device = value + ' mm';\n            this.SendConsoleLogMsg('Focal Length is set to:' + IntValue, 'info');\n            this.$bus.$emit('SetFocalLengthNum', IntValue);\n          }\n        }\n      }\n\n\n    },\n\n    GuiderFocalLengthSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value); //  Int \n\n\n      this.SendConsoleLogMsg('Guider Focal Length is set to:' + IntValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'GuiderFocalLength:' + IntValue);\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'saveToConfigFile:GuiderFocalLength:' + IntValue);\n    },\n\n    MultiStarGuiderSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      this.SendConsoleLogMsg('Multi Star Guider is set to:' + value, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'MultiStarGuider:' + value);\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'saveToConfigFile:MultiStarGuider:' + value);\n    },\n\n    GuiderPixelSizeSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const doubleValue = parseFloat(value);\n      this.SendConsoleLogMsg('Guider Pixel size is set to:' + doubleValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'GuiderPixelSize:' + doubleValue);\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'saveToConfigFile:GuiderPixelSize:' + doubleValue);\n    },\n\n    GuiderGainSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value);\n      this.SendConsoleLogMsg('Guider Gain is set to:' + IntValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'GuiderGain:' + IntValue);\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'saveToConfigFile:GuiderGain:' + IntValue);\n    },\n\n    CalibrationDurationSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value);\n      this.SendConsoleLogMsg('Guider Calibration step is set to:' + IntValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'CalibrationDuration:' + IntValue);\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'saveToConfigFile:CalibrationDuration:' + IntValue);\n    },\n\n    RaAggressionSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value);\n      this.SendConsoleLogMsg('Ra Aggression is set to:' + IntValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'RaAggression:' + IntValue);\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'saveToConfigFile:RaAggression:' + IntValue);\n    },\n\n    DecAggressionSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value);\n      this.SendConsoleLogMsg('Dec Aggression is set to:' + IntValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'DecAggression:' + IntValue);\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'saveToConfigFile:DecAggression:' + IntValue);\n    },\n\n    SyncFocuserStep(payload) {\n      const [signal, value] = payload.split(':'); // \n      const IntValue = parseInt(value);\n      this.SendConsoleLogMsg('Sync Focuser Step:' + IntValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'SyncFocuserStep:' + IntValue);\n    },\n\n    GotoThenSolve(payload) {\n      const [signal, value] = payload.split(':'); // \n      const BooleanValue = Boolean(value);\n      this.SendConsoleLogMsg('Goto Then Solve:' + BooleanValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'GotoThenSolve:' + BooleanValue);\n    },\n\n    AutoFlipSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const BooleanValue = Boolean(value);\n      this.SendConsoleLogMsg('Auto Flip:' + BooleanValue, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'AutoFlip:' + BooleanValue);\n    },\n\n    WestMinutesPastMeridianSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const WestMinutesPastMeridian = parseFloat(value);\n      this.SendConsoleLogMsg('Minutes Past Meridian:' + WestMinutesPastMeridian, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'WestMinutesPastMeridian:' + WestMinutesPastMeridian);\n    },\n\n    EastMinutesPastMeridianSet(payload) {\n      const [signal, value] = payload.split(':'); // \n      const EastMinutesPastMeridian = parseFloat(value);\n      this.SendConsoleLogMsg('Minutes Past Meridian:' + EastMinutesPastMeridian, 'info');\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'EastMinutesPastMeridian:' + EastMinutesPastMeridian);\n    },\n\n    async readBinFile(fileName, retryCount = 1) {\n      while (this.isDownloadingImage) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        if (!this.isWaitingLogged) {\n          this.SendConsoleLogMsg('The image is already being processed. Please wait for the previous process to complete.', 'warning');\n          this.isWaitingLogged = true; // \n        }\n      }\n\n      if (this.isDownloadingImageName === fileName) {\n        this.SendConsoleLogMsg('The image(' + fileName + ') is already processed.', 'info');\n        return;\n      }\n\n      this.isDownloadingImage = true;\n      this.isWaitingLogged = false; // \n      this.SendConsoleLogMsg('CaptureTestTime | Read image(' + fileName + ') data start.', 'info');\n\n      const startTime = new Date();\n      try {\n        // Check if the fileName is valid\n        if (!fileName || typeof fileName !== 'string') {\n          throw new Error('Invalid file name provided');\n        }\n\n        // Fetch with progress tracking\n        const response = await fetch(fileName, { cache: 'no-store' });\n        if (!response.ok) {\n          throw new Error(`Network response was not ok. Status: ${response.status}`);\n        }\n\n        const contentLength = response.headers.get('content-length');\n        if (!contentLength) {\n          throw new Error('Content-Length header is missing');\n        }\n\n        const total = parseInt(contentLength, 10);\n        if (isNaN(total) || total <= 0) {\n          throw new Error('Invalid content-length value');\n        }\n\n        let loaded = 0;\n\n        const reader = response.body.getReader();\n        const stream = new ReadableStream({\n          start: (controller) => {\n            const push = () => {\n              reader.read().then(({ done, value }) => {\n                if (done) {\n                  controller.close();\n                  return;\n                }\n                loaded += value.byteLength;\n                const percent = (loaded / total) * 100;\n                if (Math.round(percent) % 10 === 0) {\n                  // this.SendConsoleLogMsg(`Progress: ${Math.round(percent)}%`, 'info');\n                  this.updateCaptureImageProgress(Math.round(percent));\n                }\n                // this.SendConsoleLogMsg(`: ${Math.round(percent)}%`, 'info');\n                controller.enqueue(value);\n                push();\n              }).catch(error => {\n                console.error('Stream reading error:', error);\n                this.SendConsoleLogMsg('Stream reading error: ' + error.message, 'error');\n                controller.error(error);\n              });\n            };\n            push();\n          }\n        });\n\n        const newResponse = new Response(stream);\n        const blob = await newResponse.blob();\n\n        // FileReader with progress tracking\n        const fileReader = new FileReader();\n        fileReader.onload = () => {\n          this.ImageArrayBuffer = fileReader.result;\n\n          const endTime = new Date();\n          const elapsedTime = endTime.getTime() - startTime.getTime();\n          this.SendConsoleLogMsg('CaptureTestTime | Read image data end: ' + elapsedTime + ' ms', 'info');\n          if (!this.isPolarAxisMode) {\n            this.callShowMessageBox(`Read image data end: '${elapsedTime}' ms.`, 'info');\n          }\n          this.isDownloadingImageName = fileName;\n          this.processImage(this.ImageArrayBuffer);\n        };\n\n        fileReader.onerror = (error) => {\n          console.error('FileReader error:', error);\n          this.SendConsoleLogMsg('FileReader error: ' + error.message, 'error');\n        };\n\n        fileReader.readAsArrayBuffer(blob);\n      } catch (error) {\n        console.error('There was a problem with the fetch operation:', error);\n        this.SendConsoleLogMsg('There was a problem with the fetch operation: ' + error.message, 'error');\n\n        // \n        if (retryCount > 0) {\n          console.log('Retrying download...');\n          this.SendConsoleLogMsg('Retrying download...', 'warning');\n          this.isDownloadingImage = false;\n          this.updateCaptureImageProgress(100);\n          await this.readBinFile(fileName, retryCount - 1);\n        } else {\n          this.SendConsoleLogMsg('Max retries reached. Download failed.', 'error');\n        }\n      } finally {\n        this.isDownloadingImage = false; // \n      }\n    },\n\n\n    // async readBinFile(fileName, retryCount = 1) {\n    //   while (this.isDownloadingImage) {\n    //     await new Promise(resolve => setTimeout(resolve, 1000));\n    //     if (!this.isWaitingLogged) {\n    //       this.SendConsoleLogMsg('The image is already being processed. Please wait for the previous process to complete.', 'warning');\n    //       this.isWaitingLogged = true; // \n    //     }\n    //   }\n\n    //   if (this.isDownloadingImageName === fileName) {\n    //     this.SendConsoleLogMsg('The image(' + fileName + ') is already processed.', 'info');\n    //     return;\n    //   }\n\n    //   this.isDownloadingImage = true;\n    //   this.isWaitingLogged = false; // \n    //   this.SendConsoleLogMsg('CaptureTestTime | Read image(' + fileName + ') data start.', 'info');\n\n    //   const startTime = new Date();\n    //   try {\n    //     // Fetch with progress tracking\n    //     const response = await fetch(fileName);\n    //     if (!response.ok) {\n    //       throw new Error('Network response was not ok');\n    //     }\n\n    //     const contentLength = response.headers.get('content-length');\n    //     if (!contentLength) {\n    //       throw new Error('Content-Length header is missing');\n    //     }\n\n    //     const total = parseInt(contentLength, 10);\n    //     let loaded = 0;\n\n    //     const reader = response.body.getReader();\n    //     const stream = new ReadableStream({\n    //       start: (controller) => {\n    //         const push = () => {\n    //           reader.read().then(({ done, value }) => {\n    //             if (done) {\n    //               controller.close();\n    //               return;\n    //             }\n    //             loaded += value.byteLength;\n    //             const percent = (loaded / total) * 100;\n    //             if (Math.round(percent) % 10 === 0) {\n    //               this.SendConsoleLogMsg(`Progress: ${Math.round(percent)}%`,'info');\n    //               this.updateCaptureImageProgress(Math.round(percent));\n    //             }\n    //             controller.enqueue(value);\n    //             push();\n    //           }).catch(error => {\n    //             console.error('Stream reading error:', error);\n    //             controller.error(error);\n    //           });\n    //         };\n    //         push();\n    //       }\n    //     });\n\n    //     const newResponse = new Response(stream);\n    //     const blob = await newResponse.blob();\n\n    //     // FileReader with progress tracking\n    //     const fileReader = new FileReader();\n    //     fileReader.onload = () => {\n    //       this.ImageArrayBuffer = fileReader.result;\n\n    //       const endTime = new Date();\n    //       const elapsedTime = endTime.getTime() - startTime.getTime();\n    //       this.SendConsoleLogMsg('CaptureTestTime | Read image data end: ' + elapsedTime + ' ms', 'info');\n    //       if (!this.isPolarAxisMode) {\n    //         this.callShowMessageBox(`Read image data end: '${elapsedTime}' ms.`, 'info');\n    //       }\n    //       this.isDownloadingImageName = fileName;\n    //       this.processImage(this.ImageArrayBuffer);\n    //     };\n\n    //     fileReader.onerror = (error) => {\n    //       console.error('FileReader error:', error);\n    //       this.SendConsoleLogMsg('FileReader error:' + error, 'error');\n    //     };\n\n    //     fileReader.readAsArrayBuffer(blob);\n    //   } catch (error) {\n    //     console.error('There was a problem with the fetch operation:', error);\n    //     this.SendConsoleLogMsg('There was a problem with the fetch operation:' + error, 'error');\n\n    //     // \n    //     if (retryCount > 0) {\n    //       console.log('Retrying download...');\n    //       this.SendConsoleLogMsg('Retrying download...', 'warning');\n    //       this.isDownloadingImage = false;\n    //       this.updateCaptureImageProgress(100);\n    //       await this.readBinFile(fileName, retryCount - 1);\n    //     }\n    //   } finally {\n    //     this.isDownloadingImage = false; // \n    //   }\n    // },\n\n    updateCaptureImageProgress(num) {\n      this.$bus.$emit('ShowCaptureImageProgress', num);\n    },\n\n    setImageProportion(value) {\n      this.ImageProportion = value;\n    },\n\n    async processImage(imgArray, histogramMin = -1, histogramMax = -1, options = {}) {\n      let { calculateHistogram = true } = options;\n      this.progressValue = 0;\n      this.progressDescription = this.$i18n.locale === 'cn' ? '...' : 'Processing image...';\n      let mat = null;\n      let targetImg8 = null;\n      let resizeImg = null;\n\n      // setTimeoutPromise\n      const processAsync = (fn) => {\n        return new Promise(resolve => {\n          setTimeout(() => {\n            const result = fn();\n            resolve(result);\n          }, 0);\n        });\n      };\n\n      try {\n        if (!(imgArray instanceof ArrayBuffer) && !ArrayBuffer.isView(imgArray)) {\n          throw new Error(\"Input must be ArrayBuffer or TypedArray\");\n        }\n        let uintArray = new Uint16Array(imgArray);\n\n        if (uintArray.length != parseInt(this.mainCameraSizeY) * parseInt(this.mainCameraSizeX)) {\n          throw new Error(\"Image size mismatch\");\n        }\n        // Mat\n        await processAsync(() => {\n          mat = new cv.Mat(parseInt(this.mainCameraSizeY), parseInt(this.mainCameraSizeX), cv.CV_16UC1);\n          mat.data16U.set(uintArray);\n          this.progressValue = 10;\n          this.progressDescription = this.$i18n.locale === 'cn' ? 'Mat...' : 'Creating Mat object...';\n          return true;\n        });\n\n        // \n        let CFA = this.ImageCFA;\n        let isColorCamera = false;\n        let mode = 1;\n        let blackLevel, whiteLevel;\n\n        if (histogramMin == -1 && histogramMax == -1) {\n          // \n          const result = await processAsync(() => {\n            const res = this.GetAutoStretch(mat, mode);\n            this.progressValue = 20;\n            this.progressDescription = this.$i18n.locale === 'cn' ? '...' : 'Getting auto stretch parameters...';\n            return res;\n          });\n\n          calculateHistogram = true;\n          // \n          blackLevel = result.blackLevel;\n          whiteLevel = result.whiteLevel;\n        } else {\n          blackLevel = histogramMin;  // \n          whiteLevel = histogramMax;  // \n        }\n\n        // CFA\n        if (CFA === 'GR') {\n          isColorCamera = true;\n        } else if (CFA === 'GB') {\n          isColorCamera = true;\n        } else if (CFA === 'BG') {\n          isColorCamera = true;\n        } else if (CFA === 'RGGB') {\n          isColorCamera = true;\n        } else {\n          isColorCamera = false;\n        }\n        console.log(\":isColorCamera:\", isColorCamera, \"CFA:\", CFA);\n        // \n        const analysis = await processAsync(() => {\n          const result = isColorCamera\n            ? this.analyzeImageStatistics(mat, 'bayer', CFA, { calculateGain: this.calculateGain, calculateHistogram: calculateHistogram })\n            : this.analyzeImageStatistics(mat, 'gray', { calculateGain: this.calculateGain, calculateHistogram: calculateHistogram });\n\n          if (this.ImageGainR != 1 || this.ImageGainB != 1 || this.ImageOffset != 0) {\n            result.gainR = this.ImageGainR;\n            result.gainB = this.ImageGainB;\n            result.offset = this.ImageOffset;\n          }\n\n          this.progressValue = 40;\n          this.progressDescription = this.$i18n.locale === 'cn' ? '...' : 'Calculating histogram...';\n          return result;\n        });\n\n        if (analysis.histogram) {\n          this.$bus.$emit('showHistogram', analysis.histogram);  //  \n          this.$bus.$emit('ChangeDialPosition', blackLevel, whiteLevel);  // \n          this.$bus.$emit('AutoHistogramNum', blackLevel, whiteLevel);\n        }\n\n        this.lastImageProcessParams = {\n          blackLevel: blackLevel,\n          whiteLevel: whiteLevel,\n          CFA: CFA,\n          analysis: analysis,\n          isColorCamera: isColorCamera,\n        };\n\n        // 8\n        targetImg8 = await processAsync(() => {\n          const result = isColorCamera\n            ? this.applyStretchAndGain(mat, analysis, 'bayer', CFA, blackLevel, whiteLevel)\n            : this.applyStretchAndGain(mat, analysis, 'gray', CFA, blackLevel, whiteLevel);\n\n          // mat\n          if (mat) {\n            mat.delete();\n            mat = null;\n          }\n\n          this.progressValue = 60;\n          this.progressDescription = this.$i18n.locale === 'cn' ? '...' : 'Processing with parameters...';\n          return result;\n        });\n\n        // \n        if (this.isPolarAxisMode) {\n          await processAsync(() => {\n            resizeImg = new cv.Mat();\n            cv.resize(targetImg8, resizeImg, new cv.Size(this.CanvasWidth, this.CanvasHeight), 0, 0, cv.INTER_LINEAR);\n\n            if (targetImg8) {\n              targetImg8.delete();\n              targetImg8 = null;\n            }\n            this.progressValue = 0;\n            return true;\n          });\n\n          this.$bus.$emit('showSolveImage', resizeImg);\n\n          if (resizeImg) {\n            resizeImg.delete();\n            resizeImg = null;\n          }\n        } else {\n          // ImageData\n          const colorData = await processAsync(() => {\n            const data = new ImageData(\n              new Uint8ClampedArray(targetImg8.data),\n              targetImg8.cols,\n              targetImg8.rows\n            );\n\n            if (targetImg8) {\n              targetImg8.delete();\n              targetImg8 = null;\n            }\n            if (resizeImg) {\n              resizeImg.delete();\n              resizeImg = null;\n            }\n            this.progressValue = 80;\n            this.progressDescription = this.$i18n.locale === 'cn' ? 'ImageData...' : 'Converting to ImageData object...';\n            return data;\n          });\n\n          this.drawImgData = true;\n\n          // \n          await processAsync(() => {\n            this.bufferCanvas.width = colorData.width;\n            this.bufferCanvas.height = colorData.height;\n            this.bufferCtx.putImageData(colorData, 0, 0);\n            this.progressValue = 90;\n            this.progressDescription = this.$i18n.locale === 'cn' ? '...' : 'Drawing buffer canvas image...';\n            return true;\n          });\n\n          // \n          this.progressValue = 100;\n          this.progressDescription = this.$i18n.locale === 'cn' ? '...' : 'Drawing main canvas image...';\n          this.drawImageData();\n        }\n      } catch (error) {\n        this.handleError('Process image data error', 'processImage', error);\n        this.progressValue = 0;\n        this.progressDescription = '';\n      } finally {\n        this.progressValue = 0;\n        // Mat\n        if (mat) {\n          mat.delete();\n          mat = null;\n        }\n        if (targetImg8) {\n          targetImg8.delete();\n          targetImg8 = null;\n        }\n        if (resizeImg) {\n          resizeImg.delete();\n          resizeImg = null;\n        }\n        // \n        this.checkMemoryUsage();\n        // \n        if (window.gc) {\n          try { window.gc(); } catch (e) { }\n        }\n      }\n    },\n\n\n    /**\n     * \n     * @param {cv.Mat} imgMat Mat\n     * @param {int} mode \n     * @returns {intint} \n     */\n    GetAutoStretch(imgMat, mode) {\n      //  Mat 16\n      //  OpenCV  meanStdDev \n      const means = new cv.Mat();\n      const stdDevs = new cv.Mat();\n\n      // \n      cv.meanStdDev(imgMat, means, stdDevs);\n\n      // \n      const mean = means.doubleAt(0, 0);\n      const stdDev = stdDevs.doubleAt(0, 0);\n\n      //  Mat \n      means.delete();\n      stdDevs.delete();\n\n      // \n      let a, b;\n      switch (mode) {\n        case 0: a = 3; b = 5; break;\n        case 1: a = 2; b = 5; break;\n        case 2: a = 3; b = 8; break;\n        default: a = 2; b = 8;\n      }\n\n      // 16\n      const maxValue = 65535;\n\n      // \n      let blackLevel = Math.round(Math.max(0, mean - stdDev * a));\n      let whiteLevel = Math.round(Math.min(maxValue, mean + stdDev * b));\n\n      //  blackLevel < whiteLevel\n      if (blackLevel >= whiteLevel) {\n        blackLevel = whiteLevel - 1;\n      }\n\n      return { blackLevel, whiteLevel };\n    },\n\n    /**\n     * 16\n     * @param {cv.Mat} img16 - 16Mat\n     * @param {string} imageType - : 'gray'()  'bayer'(Bayer)\n     * @param {string} bayerPattern - BayerimageType'bayer': 'RGGB', 'GR', 'GB', 'BG'\n     * @param {Object} options - \n     * @param {number} options.bins - 256\n     * @param {boolean} options.calculateGain - true\n     * @param {boolean} options.usePercentile - true\n     * @param {number} options.lowPercentile - 1\n     * @param {number} options.highPercentile - 99\n     * @returns {Object} \n     */\n    analyzeImageStatistics(img16, imageType, bayerPattern = 'RGGB', options = {}) {\n      // Mat\n      if (!img16 || img16.rows <= 0 || img16.cols <= 0) {\n        console.error('');\n        return {};\n      }\n\n      const { calculateGain = true, calculateHistogram = true } = options;\n      const result = {};\n\n\n      // \n      const step = 4;\n\n      // \n      const safeUshortAt = (mat, y, x) => {\n        if (y >= 0 && y < mat.rows && x >= 0 && x < mat.cols) {\n          try {\n            return mat.ushortAt(y, x);\n          } catch (e) {\n            console.error(`: (${y},${x})`);\n            return 0;\n          }\n        }\n        return 0;\n      };\n\n      // setterOpenCV.js  ucharPtr \n      const safeSetMask = (mask, y, x, value) => {\n        if (y >= 0 && y < mask.rows && x >= 0 && x < mask.cols) {\n          try {\n            const ptr = mask.ucharPtr(y, x);\n            if (ptr && ptr.length > 0) ptr[0] = value;\n          } catch (e) {\n            console.error(`: (${y},${x})`);\n          }\n        }\n      };\n\n      if (imageType === 'gray') {\n        if (calculateHistogram) {\n          // \n          const histData = Array(65536).fill(0);\n          for (let i = 0; i < img16.rows; i += step) {\n            for (let j = 0; j < img16.cols; j += step) {\n              try {\n                histData[safeUshortAt(img16, i, j)]++;\n              } catch (e) {\n                // \n              }\n            }\n          }\n          result.histogram = histData;\n        }\n      } else if (imageType === 'bayer') {\n        // Bayer\n        if (img16.rows < 2 || img16.cols < 2) {\n          console.error('Bayer');\n          return {};\n        }\n\n        const rows = img16.rows;\n        const cols = img16.cols;\n\n        //  - \n        const maskR = new cv.Mat(rows, cols, cv.CV_8UC1, new cv.Scalar(0));\n        const maskG = new cv.Mat(rows, cols, cv.CV_8UC1, new cv.Scalar(0));\n        const maskB = new cv.Mat(rows, cols, cv.CV_8UC1, new cv.Scalar(0));\n\n        //  - \n        const sampleStep = Math.max(2, Math.floor(Math.min(rows, cols) / 200) * 2);\n\n        // Bayer\n        let rOffsets, gOffsets, bOffsets;\n        switch (bayerPattern) {\n          case 'RGGB':\n            rOffsets = [{ y: 0, x: 0 }];\n            gOffsets = [{ y: 0, x: 1 }, { y: 1, x: 0 }];\n            bOffsets = [{ y: 1, x: 1 }];\n            break;\n          case 'GR':\n            gOffsets = [{ y: 0, x: 0 }, { y: 1, x: 1 }];\n            rOffsets = [{ y: 0, x: 1 }];\n            bOffsets = [{ y: 1, x: 0 }];\n            break;\n          case 'GB':\n            gOffsets = [{ y: 0, x: 0 }, { y: 1, x: 1 }];\n            bOffsets = [{ y: 0, x: 1 }];\n            rOffsets = [{ y: 1, x: 0 }];\n            break;\n          case 'BG':\n            bOffsets = [{ y: 0, x: 0 }];\n            gOffsets = [{ y: 0, x: 1 }, { y: 1, x: 0 }];\n            rOffsets = [{ y: 1, x: 1 }];\n            break;\n          default:\n            rOffsets = [{ y: 0, x: 0 }];\n            gOffsets = [{ y: 0, x: 1 }, { y: 1, x: 0 }];\n            bOffsets = [{ y: 1, x: 1 }];\n        }\n\n        // \n        const rValues = [];\n        const gValues = [];\n        const bValues = [];\n\n        // \n        for (let y = 0; y < rows; y += sampleStep) {\n          for (let x = 0; x < cols; x += sampleStep) {\n            // \n            for (const pos of rOffsets) {\n              const py = y + pos.y;\n              const px = x + pos.x;\n              if (py < rows && px < cols && py >= 0 && px >= 0) {\n                try {\n                  safeSetMask(maskR, py, px, 255);\n                  if (calculateGain && y % (sampleStep * 2) === 0 && x % (sampleStep * 2) === 0) {\n                    rValues.push(safeUshortAt(img16, py, px));\n                  }\n                } catch (e) {\n                  console.error(`R(${py},${px})`, e);\n                }\n              }\n            }\n\n            // \n            for (const pos of gOffsets) {\n              const py = y + pos.y;\n              const px = x + pos.x;\n              if (py < rows && px < cols && py >= 0 && px >= 0) {\n                try {\n                  safeSetMask(maskG, py, px, 255);\n                  if (calculateGain && y % (sampleStep * 2) === 0 && x % (sampleStep * 2) === 0) {\n                    gValues.push(safeUshortAt(img16, py, px));\n                  }\n                } catch (e) {\n                  console.error(`G(${py},${px})`, e);\n                }\n              }\n            }\n\n            // \n            for (const pos of bOffsets) {\n              const py = y + pos.y;\n              const px = x + pos.x;\n              if (py < rows && px < cols && py >= 0 && px >= 0) {\n                try {\n                  safeSetMask(maskB, py, px, 255);\n                  if (calculateGain && y % (sampleStep * 2) === 0 && x % (sampleStep * 2) === 0) {\n                    bValues.push(safeUshortAt(img16, py, px));\n                  }\n                } catch (e) {\n                  console.error(`B(${py},${px})`, e);\n                }\n              }\n            }\n          }\n        }\n\n        if (calculateHistogram) {\n          // \n          const histDataR = Array(65536).fill(0);\n          const histDataG = Array(65536).fill(0);\n          const histDataB = Array(65536).fill(0);\n\n          // \n          const maxRows = rows - 1;\n          const maxCols = cols - 1;\n\n          for (let i = 0; i < maxRows; i += 2) {\n            for (let j = 0; j < maxCols; j += 2) {\n              try {\n                if (bayerPattern === 'RGGB') {\n                  histDataR[safeUshortAt(img16, i, j)]++;\n                  const g1 = safeUshortAt(img16, i + 1, j);\n                  const g2 = safeUshortAt(img16, i, j + 1);\n                  histDataG[Math.floor((g1 + g2) / 2)]++;\n                  histDataB[safeUshortAt(img16, i + 1, j + 1)]++;\n                } else if (bayerPattern === 'GR') {\n                  const g1 = safeUshortAt(img16, i, j);\n                  const g2 = safeUshortAt(img16, i + 1, j + 1);\n                  histDataG[Math.floor((g1 + g2) / 2)]++;\n                  histDataR[safeUshortAt(img16, i + 1, j)]++;\n                  histDataB[safeUshortAt(img16, i, j + 1)]++;\n                } else if (bayerPattern === 'GB') {\n                  const g1 = safeUshortAt(img16, i, j);\n                  const g2 = safeUshortAt(img16, i + 1, j + 1);\n                  histDataG[Math.floor((g1 + g2) / 2)]++;\n                  histDataB[safeUshortAt(img16, i + 1, j)]++;\n                  histDataR[safeUshortAt(img16, i, j + 1)]++;\n                } else if (bayerPattern === 'BG') {\n                  histDataB[safeUshortAt(img16, i, j)]++;\n                  const g1 = safeUshortAt(img16, i + 1, j);\n                  const g2 = safeUshortAt(img16, i, j + 1);\n                  histDataG[Math.floor((g1 + g2) / 2)]++;\n                  histDataR[safeUshortAt(img16, i + 1, j + 1)]++;\n                }\n              } catch (e) {\n                console.error(`(${i},${j})`, e);\n              }\n            }\n          }\n          result.histogram = [histDataR, histDataG, histDataB];\n        }\n\n        //  - \n        if (calculateGain && rValues.length > 0 && gValues.length > 0 && bValues.length > 0) {\n          try {\n            // \n            const rMean = this.truncatedMean(rValues);\n            const gMean = this.truncatedMean(gValues);\n            const bMean = this.truncatedMean(bValues);\n\n            // \n            const gainR = Math.min(Math.max(gMean / rMean, 0.1), 2);\n            const gainB = Math.min(Math.max(gMean / bMean, 0.1), 2);\n\n            result.whiteBalance = {\n              gainR: gainR,\n              gainB: gainB\n            };\n          } catch (e) {\n            console.error(\"\", e);\n            result.whiteBalance = { gainR: 1.0, gainB: 1.0 };\n          }\n        }\n\n        // \n        try {\n          maskR.delete();\n          maskG.delete();\n          maskB.delete();\n        } catch (e) {\n          console.error(\"\", e);\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     *  - \n     * @param {Array} arr - \n     * @param {number} lowerPercent - 5%\n     * @param {number} upperPercent - 5%\n     * @returns {number} \n     */\n    truncatedMean(arr, lowerPercent = 5, upperPercent = 5) {\n      if (arr.length === 0) return 0;\n\n      // \n      const filtered = arr.filter(v => v > 100 && v < 65000);\n      if (filtered.length === 0) return arr.length > 0 ? arr[0] : 0;\n\n      // \n      let workingArray = filtered;\n      if (filtered.length > 10000) {\n        workingArray = [];\n        const step = Math.ceil(filtered.length / 5000);\n        for (let i = 0; i < filtered.length; i += step) {\n          workingArray.push(filtered[i]);\n        }\n      }\n\n      // \n      workingArray.sort((a, b) => a - b);\n\n      // \n      const lowerCutoff = Math.floor(workingArray.length * (lowerPercent / 100));\n      const upperCutoff = Math.floor(workingArray.length * (1 - upperPercent / 100));\n\n      // \n      const truncated = workingArray.slice(lowerCutoff, upperCutoff);\n\n      // \n      if (truncated.length === 0) return workingArray[Math.floor(workingArray.length / 2)];\n\n      const sum = truncated.reduce((acc, val) => acc + val, 0);\n      return sum / truncated.length;\n    },\n    /**\n     *  - \n     */\n    quickMedian(arr) {\n      if (arr.length === 0) return 0;\n      if (arr.length < 100) {\n        // \n        const sortedArr = [...arr].sort((a, b) => a - b);\n        return sortedArr[Math.floor(sortedArr.length / 2)];\n      }\n\n      // \n      const samples = [];\n      for (let i = 0; i < 100; i++) {\n        samples.push(arr[Math.floor(Math.random() * arr.length)]);\n      }\n      samples.sort((a, b) => a - b);\n      return samples[50]; // \n    },\n\n    /**\n     * 168\n     * @param {cv.Mat} img16 - 16Mat\n     * @param {Object} analysis - analyzeImageStatistics\n     * @param {string} imageType - : 'gray'()  'bayer'()\n     * @param {string} bayerPattern - BayerimageType'bayer'\n     * @param {Object} stretchParams - \n     * @param {number} stretchParams.blackLevel -  \n     * @param {number} stretchParams.whiteLevel - \n     * @returns {cv.Mat} 8RGBA\n     */\n    applyStretchAndGain(img16, analysis, imageType, bayerPattern = 'RGGB', blackLevel, whiteLevel) {\n      // \n      if (blackLevel >= whiteLevel) {\n        blackLevel = whiteLevel - 1;\n      }\n\n      // \n      const scale = 255.0 / (whiteLevel - blackLevel);\n      const offset = -blackLevel * scale;\n\n      if (imageType === 'gray') {\n        //  - 8RGBA\n        const rgbaImg = new cv.Mat();\n        const gray8 = new cv.Mat();\n\n        img16.convertTo(gray8, cv.CV_8U, scale, offset);\n        cv.cvtColor(gray8, rgbaImg, cv.COLOR_GRAY2RGBA);\n        gray8.delete();\n\n        return rgbaImg;\n      } else {\n        // \n        let gainR = 1.0, gainB = 1.0;\n        if (analysis && analysis.whiteBalance) {\n          gainR = analysis.whiteBalance.gainR;\n          gainB = analysis.whiteBalance.gainB;\n        }\n\n        // LUT\n        // 1. LUT\n        const { lutR, lutG, lutB } = this.getLUT(blackLevel, whiteLevel, gainR, gainB);\n\n        // 3. 8\n        const img8 = new cv.Mat(img16.rows, img16.cols, cv.CV_8UC1);\n\n        // 4. LUT\n        // \n        const rows = img16.rows;\n        const cols = img16.cols;\n        const data8 = img8.data;\n\n        // Bayer\n        let rOffsets, gOffsets, bOffsets;\n        switch (bayerPattern) {\n          case 'RGGB':\n            rOffsets = [{ y: 0, x: 0 }];\n            gOffsets = [{ y: 0, x: 1 }, { y: 1, x: 0 }];\n            bOffsets = [{ y: 1, x: 1 }];\n            break;\n          case 'GR':\n            gOffsets = [{ y: 0, x: 0 }, { y: 1, x: 1 }];\n            rOffsets = [{ y: 0, x: 1 }];\n            bOffsets = [{ y: 1, x: 0 }];\n            break;\n          case 'GB':\n            gOffsets = [{ y: 0, x: 0 }, { y: 1, x: 1 }];\n            bOffsets = [{ y: 0, x: 1 }];\n            rOffsets = [{ y: 1, x: 0 }];\n            break;\n          case 'BG':\n            bOffsets = [{ y: 0, x: 0 }];\n            gOffsets = [{ y: 0, x: 1 }, { y: 1, x: 0 }];\n            rOffsets = [{ y: 1, x: 1 }];\n            break;\n          default:\n            rOffsets = [{ y: 0, x: 0 }];\n            gOffsets = [{ y: 0, x: 1 }, { y: 1, x: 0 }];\n            bOffsets = [{ y: 1, x: 1 }];\n        }\n\n        // TypedArray - \n        const data16U = img16.data16U;\n\n        // BayerLUT\n        for (let y = 0; y < rows; y += 2) {\n          for (let x = 0; x < cols; x += 2) {\n            // 2x2\n            // R\n            for (const pos of rOffsets) {\n              const idx = (y + pos.y) * cols + (x + pos.x);\n              if (idx < data16U.length) {\n                data8[idx] = lutR[data16U[idx]];\n              }\n            }\n\n            // G\n            for (const pos of gOffsets) {\n              const idx = (y + pos.y) * cols + (x + pos.x);\n              if (idx < data16U.length) {\n                data8[idx] = lutG[data16U[idx]];\n              }\n            }\n\n            // B\n            for (const pos of bOffsets) {\n              const idx = (y + pos.y) * cols + (x + pos.x);\n              if (idx < data16U.length) {\n                data8[idx] = lutB[data16U[idx]];\n              }\n            }\n          }\n        }\n\n        // 5. 8RGBA\n        const rgbaImg = new cv.Mat();\n        let cvmode;\n        switch (bayerPattern) {\n          case 'RGGB': cvmode = cv.COLOR_BayerRG2RGBA; break;\n          case 'GR': cvmode = cv.COLOR_BayerGR2RGBA; break;\n          case 'GB': cvmode = cv.COLOR_BayerGB2RGBA; break;\n          case 'BG': cvmode = cv.COLOR_BayerBG2RGBA; break;\n          default: cvmode = cv.COLOR_GRAY2RGBA;\n        }\n\n        cv.cvtColor(img8, rgbaImg, cvmode);\n        img8.delete();\n\n        return rgbaImg;\n      }\n    },\n    /**\n     * LUT\n     * @param {number} blackLevel - \n     * @param {number} whiteLevel - \n     * @param {number} gainR - \n     * @param {number} gainB - \n     * @returns {Object} LUTObject\n     */\n    getLUT(blackLevel, whiteLevel, gainR, gainB) {\n      // \n      const currentParams = `${blackLevel}_${whiteLevel}_${gainR}_${gainB}`;\n\n      // LUT\n      if (this.lutCache.lastParams === currentParams &&\n        this.lutCache.lutR && this.lutCache.lutG && this.lutCache.lutB) {\n        return {\n          lutR: this.lutCache.lutR,\n          lutG: this.lutCache.lutG,\n          lutB: this.lutCache.lutB\n        };\n      }\n\n      // LUT\n      console.log('LUT');\n\n      // \n      const scale = 255.0 / (whiteLevel - blackLevel);\n\n      // LUT\n      const lutR = this.lutCache.lutR || new Uint8Array(65536);\n      const lutG = this.lutCache.lutG || new Uint8Array(65536);\n      const lutB = this.lutCache.lutB || new Uint8Array(65536);\n\n      // LUT\n      for (let i = 0; i < 65536; i++) {\n        lutR[i] = Math.min(255, Math.max(0, Math.round((i * gainR - blackLevel) * scale)));\n        lutG[i] = Math.min(255, Math.max(0, Math.round((i - blackLevel) * scale)));\n        lutB[i] = Math.min(255, Math.max(0, Math.round((i * gainB - blackLevel) * scale)));\n      }\n\n      // \n      this.lutCache.lastParams = currentParams;\n      this.lutCache.lutR = lutR;\n      this.lutCache.lutG = lutG;\n      this.lutCache.lutB = lutB;\n\n      return { lutR, lutG, lutB };\n    },\n    // checkImageData(img) {\n    //   //  cv.Mat \n    //   if (!(img instanceof cv.Mat)) {\n    //     this.SendConsoleLogMsg('The image is not a valid cv.Mat object.', 'error');\n    //     return false;\n    //   }\n\n    //   // \n    //   if (img.empty()) {\n    //     this.SendConsoleLogMsg('The image is empty.', 'error');\n    //     return false;\n    //   }\n\n    //   //  8  16 \n    //   const depth = img.type() & cv.CV_MAT_DEPTH_MASK;\n    //   if (depth !== cv.CV_8U && depth !== cv.CV_16U) {\n    //     this.SendConsoleLogMsg('The image depth is not 8-bit or 16-bit.', 'error');\n    //     return false;\n    //   }\n\n    //   // \n    //   if (img.rows <= 0 || img.cols <= 0) {\n    //     this.SendConsoleLogMsg('The image dimensions are not valid.', 'error');\n    //     return false;\n    //   }\n\n    //   // 0\n    //   const data = img.data;\n    //   let isAllZero = true;\n    //   const maxValue = depth === cv.CV_8U ? 255 : 65535;\n\n    //   for (let i = 0; i < data.length; i++) {\n    //     if (data[i] < 0 || data[i] > maxValue) {\n    //       this.SendConsoleLogMsg('The image data contains out-of-range values.', 'error');\n    //       return false;\n    //     }\n    //     if (data[i] !== 0) {\n    //       isAllZero = false;\n    //     }\n    //   }\n\n    //   if (isAllZero) {\n    //     this.SendConsoleLogMsg('The image data is all zero.', 'error');\n    //     return false;\n    //   }\n    //   return true;\n    // },\n\n\n    // processImage(imgArray) {\n    //   this.progressValue = 0;\n    //   try {\n    //     if (!(imgArray instanceof ArrayBuffer) && !ArrayBuffer.isView(imgArray)) {\n    //       throw new Error(\"Input must be ArrayBuffer or TypedArray\");\n    //     }\n    //     const totalStartTime = new Date(); // \n\n    //     this.SendConsoleLogMsg('CaptureTestTime | Process image data start.', 'info');\n    //     const startTime = new Date();\n    //     let img_bit = -1;\n    //     let uintArray;\n    //     if (imgArray.byteLength === this.mainCameraSizeX * this.mainCameraSizeY * 2 ){\n    //       uintArray = new Uint16Array(imgArray);\n    //       img_bit = 16;\n    //     }else if(imgArray.byteLength === this.mainCameraSizeX * this.mainCameraSizeY){\n    //       uintArray = new Uint8Array(imgArray);\n    //       img_bit = 8;\n    //     }else{\n    //       this.SendConsoleLogMsg(`Image data is underfind bit`, 'error');\n    //       return;\n    //     }\n\n    //     this.SendConsoleLogMsg(`Image data detected as ${img_bit}-bit.`, 'info');\n\n\n\n    //     // \n    //     const canvasWidth = parseInt(this.mainCameraSizeX);\n    //     const canvasHeight = parseInt(this.mainCameraSizeY);\n\n    //     // \n    //     const modifiedCanvas = document.getElementById('mainCamera-canvas');\n    //     const modifiedCtx = modifiedCanvas.getContext('2d');\n\n\n\n    //     modifiedCanvas.width = canvasWidth;\n    //     modifiedCanvas.height = canvasHeight;\n\n    //     let mat;\n    //     if (img_bit === 16){\n    //       mat = new cv.Mat(canvasHeight, canvasWidth, cv.CV_16UC1);\n    //       mat.data16U.set(uintArray);\n    //     }else{\n    //       mat = new cv.Mat(canvasHeight, canvasWidth, cv.CV_8UC1);\n    //       mat.data.set(uintArray);\n    //     }\n    //     this.progressValue = 10;\n\n    //     const matEndTime = new Date(); // mat \n    //     this.SendConsoleLogMsg('CaptureTestTime | Mat creation time: ' + (matEndTime.getTime() - startTime.getTime()) + ' ms', 'info');\n\n    //     // \n    //     let gainR = this.ImageGainR;\n    //     let gainB = this.ImageGainB;\n    //     let offset = this.ImageOffset;\n    //     let CFA = this.ImageCFA;\n    //     let mode = 1;\n\n    //     // \n    //     let B = 0;\n    //     let W = 65535;\n    //     let cvmode = 0;\n\n    //     const { blackLevel, whiteLevel } = this.GetAutoStretch(uintArray, mode, img_bit);\n    //     B = blackLevel;\n    //     W = whiteLevel;\n    //     this.progressValue = 30;\n    //     const GetAutoStretchEndTime = new Date(); // GetAutoStretch \n    //     this.SendConsoleLogMsg('CaptureTestTime | GetAutoStretch time: ' + (GetAutoStretchEndTime.getTime() - matEndTime.getTime()) + ' ms', 'info');\n\n    //     // CFA\n    //     if (CFA === 'GR') {\n    //       cvmode = cv.COLOR_BayerGR2RGBA;\n    //     } else if (CFA === 'GB') {\n    //       cvmode = cv.COLOR_BayerGB2RGBA;\n    //     } else if (CFA === 'BG') {\n    //       cvmode = cv.COLOR_BayerBG2RGBA;\n    //     } else if (CFA === 'RGGB') {\n    //       cvmode = cv.COLOR_BayerRG2RGBA;\n    //     }else{\n    //       cvmode = cv.COLOR_GRAY2RGBA\n    //     }\n\n    //     // \n    //     let dst = new cv.Mat();\n\n    //     try {\n    //       cv.cvtColor(mat, dst, cvmode);\n    //     } catch (error) {\n    //       this.handleError('cvtColor ', 'cvtColor', error);\n    //       mat.delete();\n    //       return;\n    //     }\n\n    //     this.progressValue = 50;\n\n    //     const cvtColorEndTime = new Date(); // cvtColor \n    //     this.SendConsoleLogMsg('CaptureTestTime | cvtColor time: ' + (cvtColorEndTime.getTime() - GetAutoStretchEndTime.getTime()) + ' ms', 'info');\n\n    //     mat.delete();\n\n    //     // \n    //     // cv.resize(dst, resizeImg, new cv.Size(this.CanvasWidth, this.CanvasHeight), 0, 0, cv.INTER_LINEAR);\n    //     // dst.delete();\n\n    //     // let originalImg8 = this.Bit16To8_Stretch(resizeImg, B, W);\n    //     // resizeImg.delete();\n\n    //     let resizeImg = new cv.Mat(); // \n    //     if (this.isPolarAxisMode) {\n    //       this.progressValue = 0;\n    //       // \n    //       cv.resize(dst, resizeImg, new cv.Size(this.CanvasWidth, this.CanvasHeight), 0, 0, cv.INTER_LINEAR);\n    //       dst.delete();\n\n    //       let originalImg8;\n    //       if (img_bit === 16){\n    //         originalImg8 = this.Bit16To8_Stretch(resizeImg, B, W);\n    //       }else{\n    //         originalImg8 = resizeImg;\n    //       }\n\n    //       resizeImg.delete();\n\n    //       const Bit16To8_StretchEndTime = new Date(); // Bit16To8_Stretch \n    //       this.SendConsoleLogMsg('CaptureTestTime | Bit16To8_Stretch time: ' + (Bit16To8_StretchEndTime.getTime() - GetAutoStretchEndTime.getTime()) + ' ms', 'info');\n\n    //       let targetImg8 = this.ImageSoftAWB(originalImg8, gainR, gainB, offset);\n    //       this.$bus.$emit('showSolveImage', targetImg8);\n\n    //       const ImageSoftAWBEndTime = new Date(); // ImageSoftAWB \n    //       this.SendConsoleLogMsg('CaptureTestTime | ImageSoftAWB time: ' + (ImageSoftAWBEndTime.getTime() - Bit16To8_StretchEndTime.getTime()) + ' ms', 'info');\n    //     } else {\n    //       modifiedCtx.clearRect(0, 0, modifiedCanvas.width, modifiedCanvas.height);\n    //       cv.resize(dst, resizeImg, new cv.Size(this.CanvasWidth, this.CanvasHeight), 0, 0, cv.INTER_LINEAR);\n    //       this.progressValue = 70;\n    //       let originalResizeImg8 = this.Bit16To8_Stretch(resizeImg, B, W);\n    //       this.OriginalImage = new ImageData(new Uint8ClampedArray(originalResizeImg8.data), originalResizeImg8.cols, originalResizeImg8.rows);\n    //       resizeImg.delete();\n    //       originalResizeImg8.delete();\n    //       console.log('dst.data.length: ', dst.data.length);\n    //       console.log('dst.cols: ', dst.cols);\n    //       console.log('dst.rows: ', dst.rows);\n    //       let originalImg8 = this.Bit16To8_Stretch(dst, B, W);\n    //       dst.delete();\n    //       this.progressValue = 80;\n\n    //       const Bit16To8_StretchEndTime = new Date(); // Bit16To8_Stretch \n    //       this.SendConsoleLogMsg('CaptureTestTime | Bit16To8_Stretch time: ' + (Bit16To8_StretchEndTime.getTime() - GetAutoStretchEndTime.getTime()) + ' ms', 'info');\n\n    //       // let targetImg8 = this.ImageSoftAWB(originalImg8, gainR, gainB, offset);\n\n    //       // const ImageSoftAWBEndTime = new Date(); // ImageSoftAWB \n    //       // this.SendConsoleLogMsg('CaptureTestTime | ImageSoftAWB time: ' + (ImageSoftAWBEndTime.getTime() - Bit16To8_StretchEndTime.getTime()) + ' ms', 'info');\n\n    //       // originalImg8.delete();\n\n    //       this.lastImageProcessParams = {\n    //         gainR: gainR,\n    //         gainB: gainB,\n    //         offset: offset,\n    //         CFA: CFA,\n    //         mode: mode,\n    //         B: B,\n    //         W: W,\n    //         cvmode: cvmode,\n    //       };\n\n    //       modifiedCanvas.width = this.CanvasWidth;\n    //       modifiedCanvas.height = this.CanvasHeight;\n    //       let colorData = new ImageData(new Uint8ClampedArray(originalImg8.data), originalImg8.cols, originalImg8.rows);\n    //       originalImg8.delete();\n    //       this.drawImgData = colorData;\n    //       this.progressValue = 90;\n    //       // \n    //       this.bufferCanvas.width = colorData.width;\n    //       this.bufferCanvas.height = colorData.height;\n    //       // \n    //       this.bufferCtx.putImageData(colorData, 0, 0);\n    //       // \n    //       this.drawImageData();\n    //       this.progressValue = 100;\n    //       const DrawImageDataEndTime = new Date(); // DrawImageData \n    //       this.SendConsoleLogMsg('CaptureTestTime | DrawImageData time: ' + (DrawImageDataEndTime.getTime() - Bit16To8_StretchEndTime.getTime()) + ' ms', 'info');\n\n    //       const endTime = new Date();\n    //       const elapsedTime = endTime.getTime() - startTime.getTime();\n    //       this.SendConsoleLogMsg('CaptureTestTime | Process image data end:' + elapsedTime + ' milliseconds', 'info');\n\n    //       const totalEndTime = new Date(); // \n    //       this.SendConsoleLogMsg('CaptureTestTime | Total process image data time: ' + (totalEndTime.getTime() - totalStartTime.getTime()) + ' ms', 'info');\n\n    //       this.$bus.$emit('showCaptureImage');\n    //       this.MakeHistogram(colorData);\n    //       this.histogramImage = colorData;\n\n    //       const checkDetectedStarsFinish = () => {\n    //         if (this.DetectedStarsFinish) {\n    //           this.detectStarsImg = this.DrawDetectStars(targetImg8, this.DetectedStarsList);\n    //           targetImg8.delete();\n    //           clearInterval(intervalId);\n    //         }\n    //       };\n\n    //       const intervalId = setInterval(checkDetectedStarsFinish, 1000);\n    //     }\n\n    //     // if (this.isNotDrawStars) {\n    //     //   this.drawImageData(this.drawImgData);\n    //     // } else {\n    //     //   if (this.detectStarsImg != null) {\n    //     //     this.drawImageData(this.detectStarsImg);\n    //     //   } else {\n    //     //     this.drawImageData(this.drawImgData);\n    //     //   }\n    //     // }\n\n    //     // const windowWidth = window.innerWidth;\n    //     // const windowHeight = window.innerHeight;\n\n    //     // const minTranslateX = this.imageWidth - this.CanvasWidth;\n    //     // const minTranslateY = this.imageHeight - this.CanvasHeight;\n\n    //     //  ScaleImageSize_X  ScaleImageSize_Y\n    //     // this.ScaleImageSize_X = Math.floor(minTranslateX / this.CanvasWidth * windowWidth + windowWidth);\n    //     // this.ScaleImageSize_Y = Math.floor(minTranslateY / this.CanvasHeight * windowHeight + windowHeight);\n\n    //     // this.$bus.$emit('ScaleImageSize', this.ScaleImageSize_X, this.ScaleImageSize_Y);\n\n    //   } catch (error) {\n    //     this.handleError('Process image data error', 'processImage', error);\n    //     if (mat) {\n    //       mat.delete();\n    //     }\n    //     if (resizeImg) {\n    //       resizeImg.delete();\n    //     }\n    //     if (originalImg8) {\n    //       originalImg8.delete();\n    //     }\n    //     if (targetImg8) {\n    //       targetImg8.delete();\n    //     }\n    //   }\n    // },\n\n    // histogramStretch(imageData, min, max) {\n    //   const startTime = new Date();\n    //   // Convert ImageData to cv.Mat\n    //   const image = cv.matFromImageData(imageData);\n    //   let Time1 = new Date();\n    //   this.SendConsoleLogMsg('histogramStretch | : ' + (Time1.getTime() - startTime.getTime()) + ' ms', 'info');\n    //   // Perform the histogram stretch\n    //   const channels = new cv.MatVector();\n    //   cv.split(image, channels); // Split channels (BGR) into separate Mat objects\n    //   let Time2 = new Date();\n    //   this.SendConsoleLogMsg('histogramStretch | : ' + (Time2.getTime() - Time1.getTime()) + ' ms', 'info');\n    //   // Calculate alpha and beta for each channel\n    //   let alpha = 255.0 / (max - min);\n    //   let beta = -min * alpha;\n\n    //   if (alpha < 0) {\n    //     alpha = 0;\n    //     beta = 0;\n    //   } else if (alpha > 255) {\n    //     alpha = 255;\n    //     beta = 0;\n    //   }\n    //   Time1 = new Date();\n    //   this.SendConsoleLogMsg('histogramStretch | alphabeta: ' + (Time1.getTime() - Time2.getTime()) + ' ms', 'info');\n    //   // Iterate over each channel and apply histogram stretching\n    //   for (let i = 0; i < channels.size(); i++) {\n    //     let channel = channels.get(i);\n\n\n    //     // Apply histogram stretching to the channel\n    //     channel.convertTo(channel, -1, alpha, beta);\n\n    //     // Release the memory of channel\n    //     channel.delete();\n    //   }\n    //   Time2 = new Date();\n    //   this.SendConsoleLogMsg('histogramStretch | : ' + (Time2.getTime() - Time1.getTime()) + ' ms', 'info');\n    //   // Merge the channels back into a single image\n    //   const stretchImage = new cv.Mat();\n    //   cv.merge(channels, stretchImage);\n    //   Time1 = new Date();\n    //   this.SendConsoleLogMsg('histogramStretch | : ' + (Time1.getTime() - Time2.getTime()) + ' ms', 'info');\n    //   // Release the memory of channels and MatVector\n    //   channels.delete();\n\n    //   // Convert cv.Mat back to ImageData\n    //   const stretchedImageData = new ImageData(new Uint8ClampedArray(stretchImage.data), stretchImage.cols, stretchImage.rows);\n    //   Time2 = new Date();\n    //   this.SendConsoleLogMsg('histogramStretch | : ' + (Time2.getTime() - Time1.getTime()) + ' ms', 'info');\n    //   // Clean up\n    //   image.delete();\n    //   stretchImage.delete();\n    //   Time1 = new Date();\n    //   this.SendConsoleLogMsg('histogramStretch | : ' + (Time1.getTime() - Time2.getTime()) + ' ms', 'info');\n    //   this.SendConsoleLogMsg('histogramStretch | : ' + (Time1.getTime() - startTime.getTime()) + ' ms', 'info');\n    //   return stretchedImageData;\n    // },\n\n    histogramStretch(imageData, min, max) {\n      if (max < min) {\n        this.SendConsoleLogMsg('histogramStretch | max < min, return original imageData', 'warning');\n        max = min;\n      }\n      const startTime = new Date();\n      // Calculate alpha and beta\n      let alpha = 255.0 / (max - min);\n      let beta = -min * alpha;\n\n      if (alpha < 0) {\n        alpha = 0;\n        beta = 0;\n      } else if (alpha > 255) {\n        alpha = 255;\n        beta = 0;\n      }\n\n      // Apply histogram stretching directly on ImageData\n      for (let i = 0; i < imageData.data.length; i += 4) {\n        for (let j = 0; j < 3; j++) { // For each color channel\n          let value = imageData.data[i + j];\n          value = value * alpha + beta;\n          imageData.data[i + j] = Math.max(0, Math.min(255, value));\n        }\n      }\n\n      const endTime = new Date();\n      this.SendConsoleLogMsg('histogramStretch | : ' + (endTime.getTime() - startTime.getTime()) + ' ms', 'info');\n      return imageData;\n    },\n    localWhiteBalanceAdjustment(imageData, gainR, gainB, offset) {\n      // \n      let value;\n      for (let i = 0; i < imageData.data.length; i += 4) {\n        for (let j = 0; j < 3; j++) { // For each color channel\n          if (j == 0) {\n            value = imageData.data[i + j];\n            value = value * gainB + offset;\n          } else if (j == 2) {\n            value = imageData.data[i + j];\n            value = value * gainR + offset;\n          } else {\n            value = imageData.data[i + j];\n            value = value * 1 + offset;\n          }\n          imageData.data[i + j] = Math.max(0, Math.min(255, value));\n        }\n      }\n\n\n      return imageData;\n    },\n\n    initCanvas() {\n      this.bufferCanvas = document.createElement('canvas');\n      this.bufferCtx = this.bufferCanvas.getContext('2d');\n\n      this.tempCanvas = document.createElement('canvas');\n      this.tempCtx = this.tempCanvas.getContext('2d');\n    },\n\n    //*/*/*/*/*/*/*/*/*/*/*/\n    SwitchImageToShow(isOriginal) {\n      // console.log('Show Original Image: ', isOriginal);\n      this.SendConsoleLogMsg('Show Original Image:' + isOriginal, 'info');\n      this.isNotDrawStars = isOriginal;\n      if (isOriginal) {\n        // document.removeEventListener('click', this.handleTouchOrMouseDown);\n        this.enableMainCanvasClick = false;\n        this.drawImageData();\n      } else {\n        // document.addEventListener('click', this.handleTouchOrMouseDown);\n        this.enableMainCanvasClick = true;\n        // this.drawImageData(this.detectStarsImg);\n      }\n    },\n\n\n\n    drawImageData() {\n      if (this.bufferCanvas == null) {\n        this.SendConsoleLogMsg('drawImageData error: bufferCanvas is null or undefined.', 'error');\n        return;\n      }\n      if (!this.drawImgData) return;\n\n      // \n      // window.innerWidth; // \n      // window.innerHeight; // \n      // this.scale \n      // this.translateX x\n      // this.translateY y\n      // this.CanvasWidth  1920\n      // this.CanvasHeight  1080\n      // this.mainCameraSizeX \n      // this.mainCameraSizeY \n      // this.bufferCanvas.width \n      // this.bufferCanvas.height \n      // this.ImageProportion \n      // this.ROI_x ROIx\n      // this.ROI_y ROIy\n      // this.ROI_length ROI\n\n      // console.log(':\\n bufferCanvas.width: ', this.bufferCanvas.width, '\\n bufferCanvas.height: ', this.bufferCanvas.height, '\\n ImageProportion: ', this.ImageProportion, '\\n scale: ', this.scale, '\\n visibleX: ', this.visibleX, '\\n visibleY: ', this.visibleY, '\\n visibleWidth: ', this.visibleWidth, '\\n visibleHeight: ', this.visibleHeight, '\\n ROI_x: ', this.ROI_x, '\\n ROI_y: ', this.ROI_y, '\\n ROI_length: ', this.ROI_length);\n\n\n      // \n      const newVisibleWidth = this.bufferCanvas.width * this.scale;\n      const newVisibleHeight = newVisibleWidth / this.ImageProportion;\n\n      // x\n      let newVisibleX = this.visibleX;\n      // y\n      let newVisibleY = this.visibleY;\n\n      // \n      if (newVisibleX - newVisibleWidth / 2 < 0) {\n        newVisibleX = newVisibleWidth / 2;\n      } else if (newVisibleX + newVisibleWidth / 2 > this.bufferCanvas.width) {\n        newVisibleX = this.bufferCanvas.width - newVisibleWidth / 2;\n      }\n\n      if (newVisibleY - newVisibleHeight / 2 < 0) {\n        newVisibleY = newVisibleHeight / 2;\n      } else if (newVisibleY + newVisibleHeight / 2 > this.bufferCanvas.height) {\n        newVisibleY = this.bufferCanvas.height - newVisibleHeight / 2;\n      }\n\n      // ROI\n      // \n      const visibleLeft = newVisibleX - newVisibleWidth / 2;\n      const visibleRight = newVisibleX + newVisibleWidth / 2;\n      const visibleTop = newVisibleY - newVisibleHeight / 2;\n      const visibleBottom = newVisibleY + newVisibleHeight / 2;\n\n      //  ROI \n      const roiLeft = this.ROI_x;\n      const roiRight = this.ROI_x + this.ROI_length;\n      const roiTop = this.ROI_y;\n      const roiBottom = this.ROI_y + this.ROI_length;\n\n      //  ROI \n      const isRoiInVisible = roiRight >= visibleLeft && roiLeft <= visibleRight && roiBottom >= visibleTop && roiTop <= visibleBottom;\n\n      //  ROI \n      const roiScreenX = (this.ROI_x - visibleLeft) * (window.innerWidth / newVisibleWidth) + this.RedBoxSideLength * window.innerWidth / newVisibleWidth / 2;\n      const roiScreenY = (this.ROI_y - visibleTop) * (window.innerHeight / newVisibleHeight) + this.RedBoxSideLength * window.innerHeight / newVisibleHeight / 2;\n      // this.SendConsoleLogMsg('ROI : ' + roiScreenX + '*' + roiScreenY + ' ' + this.RedBoxSideLength * window.innerWidth / newVisibleWidth + '*' + this.RedBoxSideLength * window.innerHeight / newVisibleHeight, 'info');\n      this.$bus.$emit('setRedBoxLength', this.RedBoxSideLength * window.innerWidth / newVisibleWidth, this.RedBoxSideLength * window.innerHeight / newVisibleHeight);\n      this.$bus.$emit('setRedBoxPosition', roiScreenX, roiScreenY);\n\n\n      const canvas = this.$refs.mainCanvas;\n      const ctx = canvas.getContext('2d');\n      canvas.width = this.CanvasWidth;\n      canvas.height = this.CanvasHeight;\n\n      ctx.drawImage(this.bufferCanvas, visibleLeft, visibleTop, newVisibleWidth, newVisibleHeight, 0, 0, canvas.width, canvas.height);\n\n      this.visibleX = newVisibleX;\n      this.visibleY = newVisibleY;\n      this.visibleWidth = newVisibleWidth;\n      this.visibleHeight = newVisibleHeight;\n\n      this.$bus.$emit('setCurrentMainCanvasHasImage', true); // \n      // QT\n      //  QT  ROI  bin  bin \n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'sendVisibleArea:' + this.visibleX + ':' + this.visibleY + ':' + this.scale);\n\n      // ROI\n      if (this.DrawSelectStarX != -1 && this.DrawSelectStarY != -1 && this.showSelectStar) {\n        let radius, canvasStarX, canvasStarY, color;\n        // \n        if (this.DrawSelectStarHFR != -1) {\n          radius = this.DrawSelectStarHFR / this.scale * 2;\n          if (radius <= 1) radius = 1;\n          canvasStarX = (this.DrawSelectStarX / this.cameraBin + this.ROI_x - visibleLeft) * ctx.canvas.width / newVisibleWidth;\n          canvasStarY = (this.DrawSelectStarY / this.cameraBin + this.ROI_y - visibleTop) * ctx.canvas.height / newVisibleHeight;\n          color = 'green'; // \n        } else {\n          // \n          radius = 10 / this.scale; // \n          canvasStarX = (this.DrawSelectStarX / this.cameraBin + this.ROI_x - visibleLeft) * ctx.canvas.width / newVisibleWidth;\n          canvasStarY = (this.DrawSelectStarY / this.cameraBin + this.ROI_y - visibleTop) * ctx.canvas.height / newVisibleHeight;\n          color = 'red'; // \n        }\n\n        // \n        const imageData = ctx.getImageData(canvasStarX - radius, canvasStarY - radius, 2 * radius, 2 * radius);\n        // \n        this.$bus.$emit('selectStarImage', imageData);\n        console.log(': x =', canvasStarX, 'y =', canvasStarY, 'radius =', radius);\n        // \n        ctx.beginPath();\n        ctx.arc(canvasStarX, canvasStarY, radius, 0, 2 * Math.PI);\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        ctx.closePath();\n      }\n\n    },\n\n    addEventListeners() {\n\n    },\n\n    // \n    throttle(func, delay) {\n      let lastExecuted = 0;\n      return function (...args) {\n        const now = Date.now();\n        if (now - lastExecuted >= delay) {\n          func.apply(this, args);\n          lastExecuted = now;\n        }\n      };\n    },\n\n    Bit16To8_Stretch(img16, B, W) {\n      console.log('Bit16To8_Stretch | B = ' + B + ', W = ' + W);\n      let img8 = new cv.Mat(img16.rows, img16.cols, cv.CV_8UC4);\n      img16.convertTo(img8, cv.CV_8U, 255.0 / (W - B), -B * 255.0 / (W - B));\n      return img8;\n    },\n\n    DrawDetectStars(image, Stars) {\n      console.log('Draw circle on the Capture Image(', image.cols, ',', image.rows, ').');\n      if (!(image instanceof cv.Mat)) {\n        throw new Error('Invalid image data');\n      }\n      Stars.forEach(star => {\n        let centerX = Math.round(star.x / (this.mainCameraSizeX / image.cols));\n        let centerY = Math.round(star.y / (this.mainCameraSizeY / image.rows));\n        let radius = Math.round(star.hfr);\n\n        console.log('Draw circle at(', centerX, ',', centerY, ') with radius:', radius);\n\n        let center = new cv.Point(centerX, centerY);\n        let color = new cv.Scalar(255, 0, 0, 255);\n        let thickness = 2; // \n\n        cv.circle(image, center, radius, color, thickness);\n\n        //  hfr \n        //  star.hfr \n        let hfrValue = parseFloat(star.hfr);\n        if (isNaN(hfrValue)) {\n          hfrValue = 0; //  star.hfr 0\n        }\n\n        // 2\n        let text = hfrValue.toFixed(2);\n        let fontFace = cv.FONT_HERSHEY_SIMPLEX;\n        let fontScale = 1;\n        let textColor = new cv.Scalar(255, 0, 0, 255);\n        let textThickness = 2;\n\n        // 10\n        let textX = centerX - (text.length * 10); // 5\n        let textY = centerY - radius - 3; //  3 \n\n        // \n        cv.putText(image, text, new cv.Point(textX, textY), fontFace, fontScale, textColor, textThickness);\n      });\n\n      const imageData = new ImageData(new Uint8ClampedArray(image.data), image.cols, image.rows);\n\n      return imageData;\n    },\n\n    DrawPHD2Box(PHD2ImageSize_X, PHD2ImageSize_Y, Box_X, Box_Y) {\n      const ratioZoomX = PHD2ImageSize_X / window.innerWidth;\n      const ratioZoomY = PHD2ImageSize_Y / window.innerHeight;\n\n      const BoxWidth = 20 / ratioZoomX;\n      const BoxHeight = 20 / ratioZoomY;\n\n      const BoxStartX = Box_X / ratioZoomX - BoxWidth / 2;\n      const BoxStartY = Box_Y / ratioZoomY - BoxHeight / 2;\n\n      this.$bus.$emit('PHD2BoxPosition', BoxStartX, BoxStartY, BoxWidth, BoxHeight);\n    },\n\n    DrawPHD2Cross(PHD2ImageSize_X, PHD2ImageSize_Y, Cross_X, Cross_Y) {\n      const ratioZoomX = PHD2ImageSize_X / window.innerWidth;\n      const ratioZoomY = PHD2ImageSize_Y / window.innerHeight;\n\n      const CrossStartX = Cross_X / ratioZoomX;\n      const CrossStartY = Cross_Y / ratioZoomY;\n\n      this.$bus.$emit('PHD2CrossPosition', CrossStartX, CrossStartY);\n    },\n\n    DrawPHD2MultiStars(PHD2ImageSize_X, PHD2ImageSize_Y, Star_X, Star_Y) {\n      const ratioZoomX = PHD2ImageSize_X / window.innerWidth;\n      const ratioZoomY = PHD2ImageSize_Y / window.innerHeight;\n\n      const StarStartX = Star_X / ratioZoomX - 12 / 2;\n      const StarStartY = Star_Y / ratioZoomY - 12 / 2;\n\n      this.$bus.$emit('PHD2MultiStarsPosition', StarStartX, StarStartY);\n    },\n\n    calculateHistogram(imageData) {\n      console.log('QHYCCD | calculateHistogram');\n      const histogram = [\n        Array(256).fill(0), // \n        Array(256).fill(0), // \n        Array(256).fill(0)  // \n      ];\n\n      // \n      for (let i = 0; i < imageData.data.length; i += 4) {\n        const r = imageData.data[i];\n        const g = imageData.data[i + 1];\n        const b = imageData.data[i + 2];\n\n        // \n        histogram[0][b]++;\n        histogram[1][g]++;\n        histogram[2][r]++;\n      }\n\n      return histogram;\n    },\n\n    applyHistStretch(Min, Max) {\n      this.currentHistogramMin = Min;\n      this.currentHistogramMax = Max;\n      if (this.ImageArrayBuffer) {\n        this.processImage(this.ImageArrayBuffer, Min, Max, { calculateHistogram: false });\n      }\n      this.$bus.$emit('ChangeDialPosition', Min, Max);\n    },\n\n\n    calcWhiteBalanceGains() {\n      // const Gains = this.calculateWhiteBalanceGains(this.histogramData, this.ImageOffset);\n      this.calculateGain = true;\n      this.processImage(this.ImageArrayBuffer, this.currentHistogramMin, this.currentHistogramMax, { calculateHistogram: false });\n\n      this.ImageGainR = Gains.GainR;\n      this.ImageGainB = Gains.GainB;\n\n      const GainRIndex = this.MainCameraConfigItems.findIndex(item => item.label === 'ImageGainR');\n      if (GainRIndex !== -1) { // \n        //  ExpTime1 \n        this.MainCameraConfigItems[GainRIndex].value = this.ImageGainR;\n      } else {\n        console.error('ImageGainR configuration item not found.');\n      }\n\n      const GainBIndex = this.MainCameraConfigItems.findIndex(item => item.label === 'ImageGainB');\n      if (GainBIndex !== -1) { // \n        //  ExpTime1 \n        this.MainCameraConfigItems[GainBIndex].value = this.ImageGainB;\n      } else {\n        console.error('ImageGainB configuration item not found.');\n      }\n\n    },\n\n\n    calculateWhiteBalanceGains() {\n      if (!(this.OriginalImage instanceof ImageData)) {\n        throw new Error('Invalid image data');\n      }\n\n      //  cv.Mat \n      const img8 = cv.matFromImageData(this.OriginalImage);\n\n      // \n      const channels = new cv.MatVector();\n      cv.split(img8, channels);\n\n      // \n      const b = channels.get(0);\n      const g = channels.get(1);\n      const r = channels.get(2);\n\n      // \n      const medianB = new cv.Mat();\n      const medianG = new cv.Mat();\n      const medianR = new cv.Mat();\n      cv.medianBlur(b, medianB, 5);\n      cv.medianBlur(g, medianG, 5);\n      cv.medianBlur(r, medianR, 5);\n\n      // \n      const avgB = cv.mean(medianB)[0];\n      const avgG = cv.mean(medianG)[0];\n      const avgR = cv.mean(medianR)[0];\n\n      // \n      const gainR = Math.min(Math.max(avgG / avgR, 0.1), 3);\n      const gainB = Math.min(Math.max(avgG / avgB, 0.1), 3);\n\n      // \n      b.delete();\n      g.delete();\n      r.delete();\n      medianB.delete();\n      medianG.delete();\n      medianR.delete();\n      channels.delete();\n      img8.delete();\n\n      return { GainR: gainR, GainB: gainB };\n    },\n\n    loadOpenCv() {\n      return new Promise((resolve, reject) => {\n        if (typeof cv === 'undefined') {\n          //  cv  OpenCV.js\n          const script = document.createElement('script');\n          script.src = '/opencv.js'; //  public \n          script.async = true;\n          script.onload = () => {\n            resolve();\n          };\n          script.onerror = (error) => {\n            reject(error);\n          };\n          document.head.appendChild(script);\n        } else {\n          //  cv \n          resolve();\n        }\n      });\n    },\n\n\n    onCvReady() {\n\n      // Test if some of opencv method can work.\n      if (cv) {\n        console.log(\"QHYCCD | OpenCV.js is ready.\");\n        this.SendConsoleLogMsg('OpenCV.js is ready.', 'info');\n      } else {\n        console.log(\"QHYCCD | Failed to load OpenCV.js\");\n        this.SendConsoleLogMsg('Failed to load OpenCV.js.', 'error');\n      }\n\n      this.cvReady = true;\n    },\n\n\n    loadImageToCanvasMainCamera: function () {\n      const canvas = document.getElementById('mainCamera-canvas');\n      const ctx = canvas.getContext('2d');\n      const image = new Image();\n      image.onload = () => {\n        // \n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        // \n        canvas.width = image.width * devicePixelRatio;\n        canvas.height = image.height * devicePixelRatio;\n        ctx.scale(devicePixelRatio, devicePixelRatio); // ctx\n\n        // \n        ctx.drawImage(image, 0, 0);\n      };\n      image.src = BackgroundImage;\n    },\n    loadImageToCanvasGuiderCamera: function () {\n      const canvas = document.getElementById('guiderCamera-canvas');\n      const ctx = canvas.getContext('2d');\n      const image = new Image();\n      image.onload = () => {\n        // \n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        // \n        canvas.width = image.width * devicePixelRatio;\n        canvas.height = image.height * devicePixelRatio;\n        ctx.scale(devicePixelRatio, devicePixelRatio); // ctx\n\n        // \n        ctx.drawImage(image, 0, 0);\n      };\n      image.src = BackgroundImage;\n    },\n\n\n    showGuiderCameraCanvas() {\n      // z-index\n      this.canvasZIndexStel = -10;\n      this.canvasZIndexMainCamera = -11;\n      this.canvasZIndexGuiderCamera = 0;\n      this.$bus.$emit('setParsingProgress', false);\n\n      // this.convertToGrayscale();\n    },\n\n    showStelCanvas() {\n      if (this.isPolarAxisMode) {\n        this.$bus.$emit('setParsingProgress', true);\n      } else {\n        this.$bus.$emit('setParsingProgress', false);\n      }\n      this.canvasZIndexStel = 0;\n      this.canvasZIndexMainCamera = -10;\n      this.canvasZIndexGuiderCamera = -11;\n    },\n\n    showMainCameraCanvas() {\n      this.canvasZIndexStel = -10;\n      this.canvasZIndexMainCamera = 0;\n      this.canvasZIndexGuiderCamera = -11;\n\n      this.$bus.$emit('setParsingProgress', false);\n    },\n\n\n    handleButtonTestClick() {\n      // this.changeOrder();\n      if (this.currentcanvas === 'Stel') {\n        this.currentcanvas = 'MainCamera';\n        this.showMainCameraCanvas();\n      }\n      else if (this.currentcanvas === 'MainCamera') {\n        this.currentcanvas = 'GuiderCamera';\n        this.showGuiderCameraCanvas();\n      }\n      else if (this.currentcanvas === 'GuiderCamera') {\n        this.currentcanvas = 'Stel';\n        this.showStelCanvas();\n      }\n    },\n\n    getPluginsMenuItems: function () {\n      let res = []\n      for (const i in this.$stellariumWebPlugins()) {\n        const plugin = this.$stellariumWebPlugins()[i]\n        if (plugin.menuItems) {\n          res = res.concat(plugin.menuItems)\n        }\n      }\n      return res\n    },\n    getPluginsMenuComponents: function () {\n      let res = []\n      for (const i in this.$stellariumWebPlugins()) {\n        const plugin = this.$stellariumWebPlugins()[i]\n        if (plugin.menuComponents) {\n          res = res.concat(plugin.menuComponents)\n        }\n      }\n      return res\n    },\n    toggleStoreValue: function (storeVarName) {\n      this.nav = false;\n      this.$store.commit('toggleBool', storeVarName)\n    },\n    getStoreValue: function (storeVarName) {\n      return _.get(this.$store.state, storeVarName)\n    },\n    setStateFromQueryArgs: function () {\n      // Check whether the observing panel must be displayed\n      this.$store.commit('setValue', { varName: 'showSidePanel', newValue: this.$route.path.startsWith('/p/') })\n\n      // Set the core's state from URL query arguments such\n      // as date, location, view direction & fov\n      let that = this\n\n      if (!this.initDone) {\n        this.$stel.core.time_speed = 1\n        let d = new Date()\n        if (this.$route.query.date) {\n          d = new Moment(this.$route.query.date).toDate()\n          this.$stel.core.observer.utc = d.getMJD()\n          this.startTimeIsSet = true\n        }\n\n        if (this.$route.query.lng && this.$route.query.lat) {\n          const pos = { lat: Number(this.$route.query.lat), lng: Number(this.$route.query.lng), alt: this.$route.query.elev ? Number(this.$route.query.elev) : 0, accuracy: 1 }\n          swh.geoCodePosition(pos, that).then((loc) => {\n            that.$store.commit('setCurrentLocation', loc)\n          }, (error) => { console.log(error) })\n        }\n\n        this.$stel.core.observer.yaw = this.$route.query.az ? Number(this.$route.query.az) * Math.PI / 180 : 0\n        this.$stel.core.observer.pitch = this.$route.query.alt ? Number(this.$route.query.alt) * Math.PI / 180 : 30 * Math.PI / 180\n        this.$stel.core.fov = this.$route.query.fov ? Number(this.$route.query.fov) * Math.PI / 180 : 120 * Math.PI / 180\n\n        this.initDone = true\n      }\n\n      if (this.$route.path.startsWith('/skysource/')) {\n        const name = decodeURIComponent(this.$route.path.substring(11))\n        console.log('Will select object: ' + name)\n        this.SendConsoleLogMsg('Will select object: ' + name, 'info');\n        return swh.lookupSkySourceByName(name).then(ss => {\n          if (!ss) {\n            return\n          }\n          let obj = swh.skySource2SweObj(ss)\n          if (!obj) {\n            obj = this.$stel.createObj(ss.model, ss)\n            this.$selectionLayer.add(obj)\n          }\n          if (!obj) {\n            console.warning(\"Can't find object in SWE: \" + ss.names[0])\n          }\n          swh.setSweObjAsSelection(obj)\n        }, err => {\n          console.log(err)\n          console.log(\"Couldn't find skysource for name: \" + name)\n          this.SendConsoleLogMsg(\"Couldn't find skysource for name: \" + name, 'error');\n        })\n      }\n    },\n\n    lookatcircle() {\n      // glStel.core.selection = glTestCircle;\n      glStel.pointAndLock(glTestCircle);\n    },\n\n    setGloabalStel: function (stel) {\n      return stel;\n    },\n\n    setGlobalLayer: function (stel) {\n      return stel.createLayer({ id: 'testLayerStars', z: 7, visible: true });\n    },\n\n    // \n    isValidCoordinate: function (coord) {\n      // \n      if (typeof coord === 'string') {\n        coord = parseFloat(coord);\n      }\n\n      return typeof coord === 'number' &&\n        !isNaN(coord) &&\n        isFinite(coord) &&\n        coord >= -360 &&\n        coord <= 360;\n    },\n\n    vec3_from_sphe: function (ra_degree, dec_degree, out) {\n      // \n      let ra = ra_degree;\n      let dec = dec_degree;\n\n      if (typeof ra === 'string') {\n        ra = parseFloat(ra);\n      }\n      if (typeof dec === 'string') {\n        dec = parseFloat(dec);\n      }\n\n      // \n      if (!this.isValidCoordinate(ra) || !this.isValidCoordinate(dec)) {\n        console.error(':', { ra_degree, dec_degree, converted: { ra, dec } });\n        return;\n      }\n\n      try {\n        const cp = Math.cos(dec * Math.PI / 180);\n        out[0] = Math.cos(ra * Math.PI / 180) * cp;\n        out[1] = Math.sin(ra * Math.PI / 180) * cp;\n        out[2] = Math.sin(dec * Math.PI / 180);\n      } catch (error) {\n        console.error(':', error, { ra_degree, dec_degree, converted: { ra, dec } });\n      }\n    },\n\n    testAddCircle: function (stel, layer) {\n      console.log(\"Add a circle star near polaris\");\n\n      // \n      const circleConfig = {\n        id: 'test_circle_' + Date.now(),\n        model_data: {},\n        names: ['Test Circle'],  // \n        types: ['Temporary'],\n        model: 'temporary'\n      };\n\n      let circle = stel.createObj('circle', circleConfig);\n\n      circle.update();\n      layer.add(circle);\n\n      // \n      stel.core.selection = circle;\n      stel.pointAndLock(circle);\n\n      // Circle Property\n      let mm = circle.pos;\n      this.vec3_from_sphe(2.52971, 89.2641, mm);\n      circle.pos = mm;\n      console.log(\"circle pos:\" + mm);\n      circle.label = \"\";\n      circle.frame = 1;\n      circle.size = [0.05, 0.05];\n      circle.color = [0, 1, 0, 0.25];\n      circle.border_color = [0, 1, 0, 1];\n\n      return circle;\n    },\n\n    UpdateCirclePos(Ra_degree, Dec_degree) {\n      // \n      if (!glTestCircle || !glTestCircle.pos) {\n        console.warn('glTestCircle ');\n        return;\n      }\n      \n      let mm = glTestCircle.pos;\n      this.vec3_from_sphe(Ra_degree, Dec_degree, mm);\n      glTestCircle.pos = mm;\n      // console.log(\":\"+Ra_degree+\"+\"+Dec_degree);\n    },\n\n    UpdateTelescopeStatus(status) {\n      this.$bus.$emit('MountStatus', status);\n      \n      // \n      if (!glTestCircle) {\n        console.warn('glTestCircle ');\n        return;\n      }\n      \n      if (status === 'Moving') {\n        glTestCircle.color = [1, 0, 0, 0.25];\n        glTestCircle.border_color = [1, 0, 0, 1];\n      } else {\n        glTestCircle.color = [0, 1, 0, 0.25];\n        glTestCircle.border_color = [0, 1, 0, 1];\n      }\n    },\n\n    UpdateMainCameraStatus(status) {\n      this.$bus.$emit('MainCameraStatus', status);\n    },\n\n    // RA/DEC\n    AddFieldOfViewPolygon: function (stel, layer, coordinates, color, name) {\n      console.log(`: ${name}`, { coordinates, color });\n\n      try {\n        // \n        if (!coordinates || !Array.isArray(coordinates)) {\n          console.error('');\n          return null;\n        }\n\n        if (coordinates.length !== 5) {\n          console.error(`5${coordinates.length}`);\n          return null;\n        }\n\n        // \n        for (let i = 0; i < coordinates.length; i++) {\n          const coord = coordinates[i];\n          if (!coord || typeof coord.ra === 'undefined' || typeof coord.dec === 'undefined') {\n            console.error(`${i}radec:`, coord);\n            return null;\n          }\n\n          // \n          if (!this.isValidCoordinate(coord.ra) || !this.isValidCoordinate(coord.dec)) {\n            console.error(`${i}:`, coord);\n            return null;\n          }\n        }\n\n        // \n        const defaultColor = {\n          stroke: \"#FFFFFF\",\n          strokeOpacity: 1,\n          fill: \"#1E90FF\",\n          fillOpacity: 0.25\n        };\n\n        const finalColor = { ...defaultColor, ...color };\n        console.log(':', finalColor);\n\n        // \n        const polygonConfig = {\n          id: 'field_of_view_' + Date.now(),\n          model_data: {},\n          names: [name || 'Field of View'],\n          types: ['FieldOfView'],\n          model: 'field_of_view'\n        };\n\n        console.log('GeoJSON');\n        let polygon = stel.createObj('geojson', {\n          data: {\n            \"type\": \"FeatureCollection\",\n            \"features\": [\n              {\n                \"type\": \"Feature\",\n                \"properties\": {\n                  \"stroke\": finalColor.stroke,\n                  \"stroke-opacity\": finalColor.strokeOpacity,\n                  \"fill\": finalColor.fill,\n                  \"fill-opacity\": finalColor.fillOpacity,\n                  \"name\": name || 'Field of View'\n                },\n                \"geometry\": {\n                  \"type\": \"Polygon\",\n                  \"coordinates\": [\n                    [\n                      // \n                      [coordinates[0].ra, coordinates[0].dec],\n                      [coordinates[1].ra, coordinates[1].dec],\n                      [coordinates[2].ra, coordinates[2].dec],\n                      [coordinates[3].ra, coordinates[3].dec],\n                      [coordinates[0].ra, coordinates[0].dec]  // \n                    ]\n                  ]\n                }\n              }\n            ]\n          }\n        });\n\n        if (!polygon) {\n          console.error('GeoJSON');\n          return null;\n        }\n\n        console.log('');\n\n        // \n        polygon.update();\n        layer.add(polygon);\n\n        console.log('');\n\n        // // \n        // if (name) {\n        //   console.log('');\n        //   // \n        //   const centerRa = coordinates.reduce((sum, coord) => sum + coord.ra, 0) / coordinates.length;\n        //   const centerDec = coordinates.reduce((sum, coord) => sum + coord.dec, 0) / coordinates.length;\n\n        //   let labelCircle = this.AddMarkCircle(stel, layer, 4, name);\n        //   if (labelCircle) {\n        //     let labelMm = labelCircle.pos;\n        //     this.vec3_from_sphe(centerRa, centerDec + 0.02, labelMm); // \n        //     labelCircle.pos = labelMm;\n        //     labelCircle.color = [1, 1, 1, 0.8];  // \n        //     labelCircle.border_color = [0, 0, 0, 0.5];  // \n        //     labelCircle.size = [0.01, 0.01];  // \n\n        //     // \n        //     polygon.labelCircle = labelCircle;\n        //     console.log('');\n        //   } else {\n        //     console.warn('');\n        //   }\n        // }\n\n        console.log(`: ${name || 'Field of View'}`, {\n          coordinates: coordinates,\n          color: finalColor,\n          polygon: polygon\n        });\n\n        return polygon;\n\n      } catch (error) {\n        console.error(':', error);\n        console.error(':', error.stack);\n        return null;\n      }\n    },\n\n    // \n    RemoveFieldOfViewPolygon: function (polygon) {\n      try {\n        if (!polygon) {\n          console.warn('');\n          return false;\n        }\n\n        // \n        if (polygon.labelCircle) {\n          glLayer.remove(polygon.labelCircle);\n        }\n\n        // \n        glLayer.remove(polygon);\n\n        console.log(':', polygon);\n        return true;\n\n      } catch (error) {\n        console.error(':', error);\n        return false;\n      }\n    },\n\n    // \n    RemoveAllFieldOfViewPolygons: function () {\n      try {\n        // \n        if (this.fieldOfViewPolygons && Array.isArray(this.fieldOfViewPolygons)) {\n          this.fieldOfViewPolygons.forEach(polygon => {\n            this.RemoveFieldOfViewPolygon(polygon);\n          });\n          this.fieldOfViewPolygons = [];\n        }\n\n        console.log('');\n        return true;\n\n      } catch (error) {\n        console.error(':', error);\n        return false;\n      }\n    },\n\n    // \n    UpdateFieldOfViewPolygonPosition: function (polygon, newCoordinates) {\n      try {\n        if (!polygon || !newCoordinates || !Array.isArray(newCoordinates) || newCoordinates.length !== 5) {\n          console.error('');\n          return false;\n        }\n\n        // \n        for (let i = 0; i < newCoordinates.length; i++) {\n          const coord = newCoordinates[i];\n          if (!this.isValidCoordinate(coord.ra) || !this.isValidCoordinate(coord.dec)) {\n            console.error(`${i}:`, coord);\n            return false;\n          }\n        }\n\n        // \n        polygon.data.features[0].geometry.coordinates[0] = [\n          [newCoordinates[0].ra, newCoordinates[0].dec],\n          [newCoordinates[1].ra, newCoordinates[1].dec],\n          [newCoordinates[2].ra, newCoordinates[2].dec],\n          [newCoordinates[3].ra, newCoordinates[3].dec],\n          [newCoordinates[4].ra, newCoordinates[4].dec],\n          [newCoordinates[0].ra, newCoordinates[0].dec]  // \n        ];\n\n        polygon.update();\n\n        // \n        if (polygon.labelCircle) {\n          const centerRa = newCoordinates.reduce((sum, coord) => sum + coord.ra, 0) / newCoordinates.length;\n          const centerDec = newCoordinates.reduce((sum, coord) => sum + coord.dec, 0) / newCoordinates.length;\n\n          let labelMm = polygon.labelCircle.pos;\n          this.vec3_from_sphe(centerRa, centerDec + 0.02, labelMm);\n          polygon.labelCircle.pos = labelMm;\n        }\n\n        console.log(':', newCoordinates);\n        return true;\n\n      } catch (error) {\n        console.error(':', error);\n        return false;\n      }\n    },\n\n    UpdateMainCameraTemperature(value) {\n      // console.log('Main Camera Temperature:', value + '');\n      this.$bus.$emit('MainCameraTemperature', value);\n    },\n\n    setPolarPointAltitude(Altitude) {\n      this.PolarPoint_Altitude = Altitude;\n      console.log('Polar Point Altitude:', this.PolarPoint_Altitude);\n      this.SendConsoleLogMsg('Polar Point Altitude:' + this.PolarPoint_Altitude, 'info');\n    },\n\n    AddMarkCircle: function (stel, layer, frame, label) {\n      console.log(`: ${label}`);\n\n      try {\n        // \n        const circleConfig = {\n          id: 'temp_circle_' + Date.now(),\n          model_data: {},\n          names: [label || 'Temporary Marker'],  // \n          types: ['Temporary'],\n          model: 'temporary'\n        };\n\n        console.log('');\n        let circle = stel.createObj('circle', circleConfig);\n\n        if (!circle) {\n          console.error('');\n          return null;\n        }\n\n        console.log('');\n        circle.update();\n        layer.add(circle);\n\n        // \n        let mm = circle.pos;\n        this.vec3_from_sphe(2.52971, 89.2641, mm);\n        circle.pos = mm;\n\n        // \n        circle.label = label;\n        circle.frame = frame;\n        circle.size = [0.04, 0.04];\n        circle.color = [1, 1, 1, 0.5];\n        circle.border_color = [1, 1, 1, 1];\n\n        console.log(`: ${label}`, {\n          pos: mm,\n          size: circle.size,\n          color: circle.color,\n          border_color: circle.border_color\n        });\n\n        return circle;\n      } catch (error) {\n        console.error(':', error);\n        console.error(':', error.stack);\n        return null;\n      }\n    },\n\n    AddMarkRectangle: function (stel, layer, RaDec) {\n      let line = stel.createObj('geojson', {\n        data: {\n          \"type\": \"FeatureCollection\",\n          \"features\": [\n            {\n              \"type\": \"Feature\",\n              \"properties\": {\n                \"stroke\": \"#FFFFFF\",\n                \"stroke-opacity\": 1,\n                \"fill\": \"#1E90FF\",\n                \"fill-opacity\": 0.25\n              },\n              \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                  [\n                    // [139.76, 35.52], [139.32, 33.41], [140.92, 33.08], [141.35, 35.19], [139.76, 35.52]\n                    [parseFloat(RaDec[0].Ra), parseFloat(RaDec[0].Dec)], [parseFloat(RaDec[1].Ra), parseFloat(RaDec[1].Dec)],\n                    [parseFloat(RaDec[2].Ra), parseFloat(RaDec[2].Dec)], [parseFloat(RaDec[3].Ra), parseFloat(RaDec[3].Dec)],\n                    [parseFloat(RaDec[0].Ra), parseFloat(RaDec[0].Dec)]\n                  ]\n                ]\n              }\n            },\n          ]\n        }\n      });\n\n      line.update();\n      layer.add(line);\n      return line;\n    },\n\n\n\n    // RGB\n    hexToRgb: function (hex) {\n      // #\n      hex = hex.replace('#', '');\n\n      // RGB\n      const r = parseInt(hex.substr(0, 2), 16);\n      const g = parseInt(hex.substr(2, 2), 16);\n      const b = parseInt(hex.substr(4, 2), 16);\n\n      return { r, g, b };\n    },\n\n    // \n    updateFieldOfView: function (field) {\n      if (!field || !field.fieldInfo) return;\n\n      const info = field.fieldInfo;\n\n      // \n      const corners = [\n        { Ra: info.maxRa, Dec: info.maxDec },\n        { Ra: info.minRa, Dec: info.maxDec },\n        { Ra: info.minRa, Dec: info.minDec },\n        { Ra: info.maxRa, Dec: info.minDec },\n        { Ra: info.maxRa, Dec: info.maxDec }  // \n      ];\n\n      // GeoJSON\n      field.data = {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n          {\n            \"type\": \"Feature\",\n            \"properties\": {\n              \"stroke\": info.color,\n              \"strokeOpacity\": 0.8,\n              \"fill\": info.color,\n              \"fillOpacity\": 0.2\n            },\n            \"geometry\": {\n              \"type\": \"Polygon\",\n              \"coordinates\":\n                [\n                  [parseFloat(corners[0].Ra), parseFloat(corners[0].Dec)],\n                  [parseFloat(corners[1].Ra), parseFloat(corners[1].Dec)],\n                  [parseFloat(corners[2].Ra), parseFloat(corners[2].Dec)],\n                  [parseFloat(corners[3].Ra), parseFloat(corners[3].Dec)],\n                  [parseFloat(corners[4].Ra), parseFloat(corners[4].Dec)]\n                ]\n            }\n          }\n        ]\n      };\n\n      field.update();\n    },\n\n    // \n    startFieldUpdateTimer: function () {\n      if (this.fieldUpdateTimer) {\n        clearInterval(this.fieldUpdateTimer);\n      }\n\n      this.fieldUpdateTimer = setInterval(() => {\n        // \n        if (this.calibrationCircles) {\n          this.calibrationCircles.forEach(field => {\n            if (field.fieldInfo) {\n              this.updateFieldOfView(field);\n            }\n          });\n        }\n\n        // \n        if (this.adjustmentCircles) {\n          this.adjustmentCircles.forEach(field => {\n            if (field.fieldInfo) {\n              this.updateFieldOfView(field);\n            }\n          });\n        }\n      }, 3000); // 3\n    },\n\n    // \n    stopFieldUpdateTimer: function () {\n      if (this.fieldUpdateTimer) {\n        clearInterval(this.fieldUpdateTimer);\n        this.fieldUpdateTimer = null;\n      }\n    },\n\n    getCiecleAzAlt(Circle) {\n      let obs = this.$stel.core.observer;\n      let cirs = this.$stel.convertFrame(obs, 'ICRF', 'CIRS', Circle.getInfo('radec'));\n      let observed = this.$stel.convertFrame(obs, 'CIRS', 'OBSERVED', cirs);\n      // const azalt = this.$stel.c2s(this.$stel.convertFrame(this.$stel.core.observer, 'ICRF', 'OBSERVED', obj.getInfo('radec')))\n      let azalt = this.$stel.c2s(observed);\n      let az = this.$stel.anp(azalt[0]);\n      let alt = this.$stel.anp(azalt[1]);\n\n      const az_raf = this.$stel.a2af(az, 1);\n      const Az_degree = (az_raf.degrees < 0 ? az_raf.degrees + 180 : az_raf.degrees) + az_raf.arcminutes / 60 + az_raf.arcseconds / 3600;\n\n      const alt_raf = this.$stel.a2af(alt, 1);\n      const Alt_degree = alt_raf.degrees + alt_raf.arcminutes / 60 + alt_raf.arcseconds / 3600;\n\n      console.log('AzAlt:', Az_degree, Alt_degree);\n\n      return { Az_degree, Alt_degree };\n    },\n\n    SolveResultMark(RaDegree, DecDegree, Azimuth, Altitude) {\n      let MarkCircle_RaDec = this.AddMarkCircle(this.$stel, glLayer, 1, \"RaDec\");\n      let mm = MarkCircle_RaDec.pos;\n      this.vec3_from_sphe(RaDegree, DecDegree, mm);\n      MarkCircle_RaDec.pos = mm;\n      console.log(\"RaDec circle coordinates:\" + mm);\n\n      const AzAlt = this.getCiecleAzAlt(MarkCircle_RaDec);\n      glLayer.remove(MarkCircle_RaDec);\n\n      this.MarkCircleNum++;\n      let Label = \"AzAlt_Vue_\" + this.MarkCircleNum;\n\n      let MarkCircle_AltAz = this.AddMarkCircle(this.$stel, glLayer, 4, Label);\n      mm = MarkCircle_AltAz.pos;\n      this.vec3_from_sphe(AzAlt.Az_degree, AzAlt.Alt_degree, mm);\n      MarkCircle_AltAz.pos = mm;\n      console.log(\"AzAlt_Vue circle coordinates:\" + mm);\n\n      console.log(\"AzAlt_Vue circle x:\" + mm[0]);\n      console.log(\"AzAlt_Vue circle y:\" + mm[1]);\n      console.log(\"AzAlt_Vue circle z:\" + mm[2]);\n\n      this.LastPoint_AzAlt = this.getCiecleAzAlt(MarkCircle_AltAz);\n\n      this.CalculationPolarPoint(mm);\n\n      // \n      // this.Circles.push(MarkCircle_RaDec);\n      this.Circles.push(MarkCircle_AltAz);\n\n    },\n\n    RemoveAllCircles() {\n      this.Circles.forEach(circle => {\n        glLayer.remove(circle);\n      });\n      this.Circles = [];\n    },\n\n    SolveResultMark_RealTime(RaDegree, DecDegree, Azimuth, Altitude) {\n      this.LastCircle_RaDec = this.AddMarkCircle(this.$stel, glLayer, 1, \"RaDec\");\n      let mm = this.LastCircle_RaDec.pos;\n      this.vec3_from_sphe(RaDegree, DecDegree, mm);\n      this.LastCircle_RaDec.pos = mm;\n      console.log(\"RaDec circle coordinates:\" + mm);\n\n      const AzAlt = this.getCiecleAzAlt(this.LastCircle_RaDec);\n      glLayer.remove(this.LastCircle_RaDec);\n\n      if (this.LastCircle_AzAlt !== null && this.LastCircle_AzAlt !== undefined) {\n        glLayer.remove(this.LastCircle_AzAlt);\n      }\n      this.LastCircle_AzAlt = this.AddMarkCircle(this.$stel, glLayer, 4, 'Current');\n      mm = this.LastCircle_AzAlt.pos;\n      this.vec3_from_sphe(AzAlt.Az_degree, AzAlt.Alt_degree, mm);\n      this.LastCircle_AzAlt.pos = mm;\n      this.LastCircle_AzAlt.color = [0, 1, 1, 0.25];\n      console.log(\"AzAlt_Vue circle coordinates:\" + mm);\n\n      console.log(\"AzAlt_Vue circle x:\" + mm[0]);\n      console.log(\"AzAlt_Vue circle y:\" + mm[1]);\n      console.log(\"AzAlt_Vue circle z:\" + mm[2]);\n\n      this.Current_AzAlt = this.getCiecleAzAlt(this.LastCircle_AzAlt);\n      console.log(\"Current AzAlt:\", this.Current_AzAlt.Az_degree, this.Current_AzAlt.Alt_degree);\n      this.$bus.$emit('ShowCurrentAzAltText', this.Current_AzAlt.Az_degree, this.Current_AzAlt.Alt_degree);\n    },\n\n\n    CalculationPolarPoint(coordinate) {\n      this.CartesianList.push(coordinate);\n\n      if (this.CartesianList.length < 3) {\n        return;\n      }\n\n      this.$bus.$emit('HideSingleSolveBtn');\n\n      // \n      const p1 = this.CartesianList[0];\n      const p2 = this.CartesianList[1];\n      const p3 = this.CartesianList[2];\n\n      // \n      const v1 = [\n        p2[0] - p1[0],\n        p2[1] - p1[1],\n        p2[2] - p1[2]\n      ];\n\n      const v2 = [\n        p3[0] - p1[0],\n        p3[1] - p1[1],\n        p3[2] - p1[2]\n      ];\n\n      // \n      const normal = [\n        v1[1] * v2[2] - v1[2] * v2[1],\n        v1[2] * v2[0] - v1[0] * v2[2],\n        v1[0] * v2[1] - v1[1] * v2[0]\n      ];\n\n      // \n      const normalLength = Math.sqrt(normal[0] ** 2 + normal[1] ** 2 + normal[2] ** 2);\n\n      // \n      const unitNormal = [\n        normal[0] / normalLength,\n        normal[1] / normalLength,\n        normal[2] / normalLength\n      ];\n\n      // r(0, 0, 0)\n      const r = 1; // \n\n      // \n      const intersection1 = [\n        unitNormal[0] * r,\n        unitNormal[1] * r,\n        unitNormal[2] * r\n      ];\n\n      const intersection2 = [\n        -unitNormal[0] * r,\n        -unitNormal[1] * r,\n        -unitNormal[2] * r\n      ];\n\n      console.log('Intersection Points:', intersection1, intersection2);\n\n      // (0,0,1)\n      const closerIntersection = intersection1[2] > 0 ? intersection1 : intersection2;\n\n      let MarkCircle_FakePolarPoint = this.AddMarkCircle(this.$stel, glLayer, 4, \"FakePolarPoint\");\n      let mm = MarkCircle_FakePolarPoint.pos;\n      mm[0] = closerIntersection[0];\n      mm[1] = closerIntersection[1];\n      mm[2] = closerIntersection[2];\n      MarkCircle_FakePolarPoint.pos = mm;\n      console.log(\"FakePolarPoint circle coordinates:\" + mm);\n\n      const AzAlt_FakePolarPoint = this.getCiecleAzAlt(MarkCircle_FakePolarPoint);\n\n      console.log(\"Fake Polar Point AzAlt:\", AzAlt_FakePolarPoint.Az_degree, ',', AzAlt_FakePolarPoint.Alt_degree);\n\n      this.Circles.push(MarkCircle_FakePolarPoint);\n\n      let AzAlt_PolarPoint = {\n        Az_degree: 0,\n        Alt_degree: this.PolarPoint_Altitude\n      };\n\n      // console.log(\"Real Polar Point AzAlt:\", AzAlt_PolarPoint.Az_degree, ',', AzAlt_PolarPoint.Alt_degree);\n      this.SendConsoleLogMsg('Real Polar Point AzAlt:' + AzAlt_PolarPoint.Az_degree + ',' + AzAlt_PolarPoint.Alt_degree, 'info');\n      // console.log(\"Last Point AzAlt:\", this.LastPoint_AzAlt.Az_degree, this.LastPoint_AzAlt.Alt_degree);\n      this.SendConsoleLogMsg('Last Point AzAlt:' + this.LastPoint_AzAlt.Az_degree + ',' + this.LastPoint_AzAlt.Alt_degree, 'info');\n\n      ////////////////////////////////////////////////\n\n      // // \n      // let fakePolarPoint = this.sphericalToCartesian(AzAlt_FakePolarPoint.Az_degree, AzAlt_FakePolarPoint.Alt_degree);\n      // let polarPoint = this.sphericalToCartesian(AzAlt_PolarPoint.Az_degree, AzAlt_PolarPoint.Alt_degree);\n      // let lastPoint = this.sphericalToCartesian(this.LastPoint_AzAlt.Az_degree, this.LastPoint_AzAlt.Alt_degree);\n\n      // // \n      // let quaternion = this.computeQuaternion(fakePolarPoint, polarPoint);\n\n      // // \n      // let fourthPoint = this.applyQuaternion(lastPoint, quaternion);\n\n      // // \n      // let fourthPointAzAlt = this.cartesianToSpherical(fourthPoint);\n      // console.log(\"Fourth Point AzAlt:\", fourthPointAzAlt.Az_degree, ',', fourthPointAzAlt.Alt_degree);\n\n      ////////////////////////////////////////////////\n\n      // \n      function calculateAngleDifference(angle1, angle2) {\n        let difference = angle2 - angle1;\n        while (difference > 180) difference -= 360;\n        while (difference < -180) difference += 360;\n        return difference;\n      }\n\n      let azimuthDifference = calculateAngleDifference(AzAlt_FakePolarPoint.Az_degree, AzAlt_PolarPoint.Az_degree);\n      let altitudeDifference = AzAlt_PolarPoint.Alt_degree - AzAlt_FakePolarPoint.Alt_degree;\n\n      // LastPoint\n      let fourthPointAzAlt = {\n        Az_degree: this.LastPoint_AzAlt.Az_degree + azimuthDifference,\n        Alt_degree: this.LastPoint_AzAlt.Alt_degree + altitudeDifference\n      };\n\n      // 0360\n      fourthPointAzAlt.Az_degree = (fourthPointAzAlt.Az_degree + 360) % 360;\n\n      // -9090\n      fourthPointAzAlt.Alt_degree = Math.max(Math.min(fourthPointAzAlt.Alt_degree, 90), -90);\n\n      console.log(\"Fourth Point AzAlt:\", fourthPointAzAlt.Az_degree, ',', fourthPointAzAlt.Alt_degree);\n\n      this.$bus.$emit('ShowAzAltText', azimuthDifference, altitudeDifference, fourthPointAzAlt.Az_degree, fourthPointAzAlt.Alt_degree);\n\n      ////////////////////////////////////////////////\n\n      // \n      function degreesToRadians(degrees) {\n        return degrees * Math.PI / 180;\n      }\n\n      // \n      function sphericalToCartesian(azimuth, altitude) {\n        let az = degreesToRadians(azimuth);\n        let alt = degreesToRadians(altitude);\n        let x = Math.cos(alt) * Math.cos(az);\n        let y = Math.cos(alt) * Math.sin(az);\n        let z = Math.sin(alt);\n        return { x: x, y: y, z: z };\n      }\n\n      // \n      let fourthPointCartesian = sphericalToCartesian(fourthPointAzAlt.Az_degree, fourthPointAzAlt.Alt_degree);\n      console.log(\"Fourth Point Cartesian:\", fourthPointCartesian.x, ',', fourthPointCartesian.y, ',', fourthPointCartesian.z);\n\n      let MarkCircle_fourthPoint = this.AddMarkCircle(this.$stel, glLayer, 4, \"Target Point\");\n      mm = MarkCircle_fourthPoint.pos;\n      mm[0] = fourthPointCartesian.x;\n      mm[1] = fourthPointCartesian.y;\n      mm[2] = fourthPointCartesian.z;\n      MarkCircle_fourthPoint.pos = mm;\n      MarkCircle_fourthPoint.color = [1, 0, 0, 0.25];\n\n      this.Circles.push(MarkCircle_fourthPoint);\n\n      // \n      this.CartesianList = [];\n      this.MarkCircleNum = 0;\n    },\n\n    // \n    degreesToRadians(degrees) {\n      return degrees * Math.PI / 180;\n    },\n\n    // \n    sphericalToCartesian(azimuth, altitude) {\n      let az = this.degreesToRadians(azimuth);\n      let alt = this.degreesToRadians(altitude);\n      let x = Math.cos(alt) * Math.cos(az);\n      let y = Math.cos(alt) * Math.sin(az);\n      let z = Math.sin(alt);\n      return { x: x, y: y, z: z };\n    },\n\n    // \n    computeQuaternion(from, to) {\n      let w = from.x * to.x + from.y * to.y + from.z * to.z + 1;\n      let x = from.y * to.z - from.z * to.y;\n      let y = from.z * to.x - from.x * to.z;\n      let z = from.x * to.y - from.y * to.x;\n\n      let norm = Math.sqrt(w * w + x * x + y * y + z * z);\n      return { w: w / norm, x: x / norm, y: y / norm, z: z / norm };\n    },\n\n    // \n    applyQuaternion(point, quat) {\n      let x = quat.w * quat.w * point.x + 2 * quat.y * quat.w * point.z - 2 * quat.z * quat.w * point.y + quat.x * quat.x * point.x + 2 * quat.y * quat.x * point.y + 2 * quat.z * quat.x * point.z - quat.z * quat.z * point.x - quat.y * quat.y * point.x;\n      let y = 2 * quat.x * quat.y * point.x + quat.y * quat.y * point.y + 2 * quat.z * quat.y * point.z + 2 * quat.w * quat.z * point.x - quat.z * quat.z * point.y + quat.w * quat.w * point.y - 2 * quat.x * quat.w * point.z - quat.x * quat.x * point.y;\n      let z = 2 * quat.x * quat.z * point.x + 2 * quat.y * quat.z * point.y + quat.z * quat.z * point.z - 2 * quat.w * quat.y * point.x - quat.y * quat.y * point.z + 2 * quat.w * quat.x * point.y - quat.x * quat.x * point.z + quat.w * quat.w * point.z;\n      return { x: x, y: y, z: z };\n    },\n\n    // \n    cartesianToSpherical(cartesian) {\n      let r = Math.sqrt(cartesian.x ** 2 + cartesian.y ** 2 + cartesian.z ** 2);\n      let azimuth = Math.atan2(cartesian.y, cartesian.x);\n      let altitude = Math.asin(cartesian.z / r);\n      return {\n        Az_degree: azimuth * 180 / Math.PI,\n        Alt_degree: altitude * 180 / Math.PI\n      };\n    },\n\n    SolveFovMark(RaDec) {\n      console.log('RaDec[4]:', RaDec);\n\n      // let rectangle = this.AddMarkRectangle(this.$stel, glLayer, RaDec);\n\n      this.Circles.push(rectangle);\n\n    },\n\n    CalibratePolarAxis() {\n      this.$bus.$emit('CalibratePolarAxisMode');\n      // this.$bus.$emit('AppSendMessage', 'Vue_Command', 'StartLoopCapture');\n      this.nav = false;\n    },\n\n    RecalibratePolarAxis() {\n      // \n      this.CartesianList = [];\n      this.MarkCircleNum = 0;\n      this.RemoveAllCircles();\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'ClearSloveResultList');\n    },\n\n\n\n    // \n    drawCalibrationPointPolygon(coordinates, color, name) {\n      console.log(`: ${name}`, coordinates);\n\n      try {\n        // \n        if (!coordinates || !Array.isArray(coordinates)) {\n          console.error('');\n          return;\n        }\n\n        if (coordinates.length !== 5) {\n          console.error(`5${coordinates.length}`);\n          return;\n        }\n\n        // \n        for (let i = 0; i < coordinates.length; i++) {\n          const coord = coordinates[i];\n          if (!coord || typeof coord.ra === 'undefined' || typeof coord.dec === 'undefined') {\n            console.error(`${i}`, coord);\n            return;\n          }\n\n          if (!this.isValidCoordinate(coord.ra) || !this.isValidCoordinate(coord.dec)) {\n            console.error(`${i}`, coord);\n            return;\n          }\n        }\n\n        // \n        let calibrationPolygon = this.AddFieldOfViewPolygon(\n          this.$stel,\n          glLayer,\n          coordinates,\n          color,\n          name\n        );\n\n        if (calibrationPolygon) {\n          // \n          if (!this.calibrationCircles) {\n            this.calibrationCircles = [];\n          }\n          this.calibrationCircles.push(calibrationPolygon);\n\n          console.log(`: ${name}`, calibrationPolygon);\n        } else {\n          console.error(`: ${name}`);\n        }\n\n      } catch (error) {\n        console.error(':', error);\n      }\n    },\n\n    // \n    clearCalibrationPoints() {\n      console.log('');\n\n      // \n      if (!this.calibrationCircles) {\n        this.calibrationCircles = [];\n      }\n      if (!this.adjustmentCircles) {\n        this.adjustmentCircles = [];\n      }\n\n      // \n      if (this.calibrationCircles.length > 0) {\n        console.log(` ${this.calibrationCircles.length} `);\n        this.calibrationCircles.forEach((circle, index) => {\n          try {\n            if (circle && glLayer) {\n              glLayer.remove(circle);\n              console.log(` ${index + 1}`);\n            }\n          } catch (error) {\n            console.warn(` ${index + 1} :`, error);\n          }\n        });\n        this.calibrationCircles = [];\n      }\n\n      // \n      if (this.adjustmentCircles.length > 0) {\n        console.log(` ${this.adjustmentCircles.length} `);\n        this.adjustmentCircles.forEach((circle, index) => {\n          try {\n            if (circle && glLayer) {\n              glLayer.remove(circle);\n              console.log(` ${index + 1}`);\n            }\n          } catch (error) {\n            console.warn(` ${index + 1} :`, error);\n          }\n        });\n        this.adjustmentCircles = [];\n      }\n\n      // \n      this.lastPosition = null;\n\n      // \n      if (this.targetPointCircle) {\n        try {\n          if (glLayer) {\n            glLayer.remove(this.targetPointCircle);\n            console.log('');\n          }\n          this.targetPointCircle = null;\n        } catch (error) {\n          console.warn(':', error);\n        }\n      }\n\n      console.log('');\n    },\n\n\n    // \n    // \n    drawAdjustmentPointsPolygon(currentCoordinates, targetCoordinates, currentColor, targetColor, isTimerUpdate) {\n      if (isTimerUpdate === undefined) isTimerUpdate = false;\n      console.log('', { currentCoordinates, targetCoordinates });\n\n      try {\n        // 1) \n        if (this.adjustmentCircles) {\n          this.adjustmentCircles.forEach(obj => {\n            try { glLayer.remove(obj); } catch (e) { console.warn(':', e); }\n          });\n        }\n        this.adjustmentCircles = [];\n\n        // 2) \n        if (currentCoordinates && Array.isArray(currentCoordinates) && currentCoordinates.length === 5) {\n          console.log('');\n          const currentPolygon = this.AddFieldOfViewPolygon(\n            this.$stel,\n            glLayer,\n            currentCoordinates,\n            currentColor,\n            'Current'\n          );\n          if (currentPolygon) {\n            this.adjustmentCircles.push(currentPolygon);\n            console.log('');\n          } else {\n            console.error('');\n          }\n        } else {\n          console.warn('');\n        }\n\n        // 3) \n        if (!isTimerUpdate && targetCoordinates && Array.isArray(targetCoordinates) && targetCoordinates.length === 5) {\n          try {\n            const centerRa = targetCoordinates.reduce((s, c) => s + c.ra, 0) / targetCoordinates.length;\n            const centerDec = targetCoordinates.reduce((s, c) => s + c.dec, 0) / targetCoordinates.length;\n            console.log(`: RA=${centerRa}, DEC=${centerDec}`);\n\n            //  layer\n            const targetObjConfig = {\n              id: 'temp_target_' + Date.now(),\n              model_data: {},\n              names: ['Target Position'],\n              types: ['Temporary'],\n              model: 'temporary'\n            };\n            const targetObj = this.$stel.createObj('circle', targetObjConfig);\n            let mm = targetObj.pos;\n            this.vec3_from_sphe(centerRa, centerDec, mm);\n            targetObj.pos = mm;\n            if (typeof targetObj.update === 'function') targetObj.update();\n\n            this.$stel.pointAndLock(targetObj, 1.0);\n            console.log('');\n\n            //  layer remove\n            setTimeout(() => { try { /* no-op */ } catch (_) { } }, 0);\n          } catch (error) {\n            console.error(':', error);\n          }\n        }\n\n      } catch (error) {\n        console.error(':', error);\n      }\n    },\n\n\n    // RA/Dec\n    drawTargetPointCircle(targetRa, targetDec, color, name, text, clearlast) {\n      if (clearlast === undefined) clearlast = true; // \n      console.log('', { targetRa, targetDec, color });\n\n      try {\n        // 1) \n        if (!this.isValidCoordinate(targetRa) || !this.isValidCoordinate(targetDec)) {\n          console.error(text + ':', { targetRa, targetDec });\n          return;\n        }\n\n        // 2) \n        if (this.targetPointCircle && clearlast) {\n          try {\n            if (glLayer) {\n              glLayer.remove(this.targetPointCircle);\n              console.log('' + name);\n            }\n          } catch (error) {\n            console.warn('' + text + ':', error);\n          }\n        }\n\n        // 3) \n        const circle = this.AddMarkCircle(this.$stel, glLayer, 4, name); // frame=4\n        if (!circle) {\n          console.error(text + '');\n          return;\n        }\n\n        // 4) RA/Dec   3D \n        const mm = circle.pos;\n        this.vec3_from_sphe(targetRa, targetDec, mm);\n        circle.pos = mm;\n\n        // 5) \n        if (color) {\n          const rgb = this.hexToRgb(color.stroke || color.fill || '#FF8C00');\n          const alpha = (color.fillOpacity || 0.3);\n          const borderAlpha = (color.strokeOpacity || 1.0);\n          circle.color = [rgb.r / 255, rgb.g / 255, rgb.b / 255, alpha];\n          circle.border_color = [rgb.r / 255, rgb.g / 255, rgb.b / 255, borderAlpha];\n        } else {\n          circle.color = [1, 0.55, 0, 0.3];\n          circle.border_color = [1, 0.55, 0, 1];\n        }\n        const size = 0.02;\n        circle.size = [size, size];\n\n        // 6)  & \n        if (typeof circle.update === 'function') circle.update();\n        this.targetPointCircle = circle;\n\n        console.log(text + '', circle);\n      } catch (error) {\n        console.error('' + text + ':', error);\n      }\n    },\n\n\n    // \n    DrawFakePolarAxisCircle(targetRa, targetDec, color, name, text) {\n      console.log('', { targetRa, targetDec, color });\n\n      try {\n        // \n        if (!this.isValidCoordinate(targetRa) || !this.isValidCoordinate(targetDec)) {\n          console.error(text + ':', { targetRa, targetDec });\n          return;\n        }\n\n        // \n        if (this.fakePolarAxisCircle) {\n          try {\n            if (glLayer) {\n              glLayer.remove(this.fakePolarAxisCircle);\n              console.log('' + name);\n            }\n          } catch (error) {\n            console.warn('' + text + ':', error);\n          }\n        }\n\n        // \n        let targetCircle = this.AddMarkCircle(this.$stel, glLayer, 4, name);\n        if (targetCircle) {\n          // \n          let targetMm = targetCircle.pos;\n          this.vec3_from_sphe(targetRa, targetDec, targetMm);\n          targetCircle.pos = targetMm;\n\n          // \n          if (color) {\n            // RGB\n            const rgb = this.hexToRgb(color.stroke || color.fill || '#FF8C00');\n            const alpha = (color.fillOpacity || 0.3);\n            const borderAlpha = (color.strokeOpacity || 1.0);\n\n            targetCircle.color = [rgb.r / 255, rgb.g / 255, rgb.b / 255, alpha];\n            targetCircle.border_color = [rgb.r / 255, rgb.g / 255, rgb.b / 255, borderAlpha];\n          } else {\n            // \n            targetCircle.color = [1, 0.55, 0, 0.3];  // \n            targetCircle.border_color = [1, 0.55, 0, 1];  // \n          }\n\n          // \n          const targetSize = 0.02; // \n          targetCircle.size = [targetSize, targetSize];\n\n          // \n          this.fakePolarAxisCircle = targetCircle;\n\n          console.log(text + '', targetCircle);\n        } else {\n          console.error(text + '');\n        }\n\n      } catch (error) {\n        console.error('' + text + ':', error);\n      }\n    },\n\n    ShowConfirmDialog(Title, Text, ToDo) {\n      // window.location.reload();\n      this.nav = false;\n      this.$bus.$emit('ShowConfirmDialog', Title, Text, ToDo);\n    },\n\n    decrement(item) {\n      console.log('decrement:', item.value);\n      if (item.value > item.inputMin) {\n        item.value -= item.inputStep;\n      }\n    },\n\n    increment(item) {\n      console.log('increment:', item.value);\n      if (item.value < item.inputMax) {\n        item.value += item.inputStep;\n      }\n    },\n\n    PolarAxisMode(bool) {\n      this.isPolarAxisMode = bool;\n    },\n\n    handleGuiderCanvasClick(event) {\n      const canvas = this.$refs.guiderCanvas;\n      const rect = canvas.getBoundingClientRect();\n      const x = event.clientX - rect.left; // X\n      const y = event.clientY - rect.top;  // Y\n      console.log(`Clicked at: (${x}, ${y})`);\n      const CanvasWidth = window.innerWidth;\n      const CanvasHeight = window.innerHeight;\n      this.$bus.$emit('AppSendMessage', 'Vue_Command', 'GuiderCanvasClick:' + CanvasWidth + ':' + CanvasHeight + ':' + x + ':' + y);\n    },\n    connectDriver() {\n      this.isConnecting = true;\n      // this.isOpenDevicePage = false;\n      this.startLoading();\n      const DeviceType = this.CurrentDriverType;\n      for (const device of this.devices) {\n        if (device.driverType === DeviceType && device.isConnected == false) {\n          const DriverName = device.driverName;\n          if (DriverName == '') {\n            this.SendConsoleLogMsg('No driver selected', 'warning');\n            this.isConnecting = false;\n            return;\n          }\n          this.$bus.$emit('AppSendMessage', 'Vue_Command', 'ConnectDriver:' + DriverName + ':' + DeviceType);\n          this.SendConsoleLogMsg('Start Connecting driver:' + DeviceType + ' ' + DriverName, 'info');\n          return;\n        }\n      }\n    },\n    connectDriverSuccess(devicetype) {\n      console.log('connectDriverSuccess:', devicetype);\n      this.SendConsoleLogMsg(\"connectDriverSuccess:\" + devicetype, 'info');\n      this.isConnecting = false;\n      if (this.drawer_2 == true) {\n        this.drawer_2 = false\n      }\n\n      this.stopLoading();\n    },\n    connectDriverFailed(message) {\n      console.log('connectDriverFailed:', message);\n      this.SendConsoleLogMsg(\"connectDriverFailed:\" + message, 'error');\n      this.isConnecting = false;\n      this.stopLoading();\n    },\n    disconnectDriver() {\n      const DeviceType = this.CurrentDriverType;\n      for (const device of this.devices) {\n        if (device.driverType === DeviceType && device.isConnected) {\n          this.$bus.$emit('AppSendMessage', 'Vue_Command', 'DisconnectDevice:' + device.device + \":\" + DeviceType);\n        }\n      }\n    },\n    disconnectDriversuccess(devicetype) {\n      console.log('disconnectDevicesuccess:', devicetype);\n      this.drawer_2 = false\n      if (devicetype == \"all\") {\n        this.sendMessage('Vue_Command', 'disconnectAllDevice');\n        this.SendConsoleLogMsg('Disconnect All Device', 'info');\n        this.haveDeviceConnect = false;\n        this.$bus.$emit('MainCameraConnected', 0);\n        this.$bus.$emit('MountConnected', 0);\n        this.$bus.$emit('CFWConnected', 0);\n        this.$bus.$emit('GuiderConnected', 0);\n        this.clearDeviceList();\n        this.$bus.$emit('deleteDeviceTypeAllocationList', 'all');\n        return;\n      };\n\n      for (const device of this.devices) {\n        if (device.driverType === devicetype && device.isConnected) {\n          device.isConnected = false;\n          device.isget = false;\n          device.device = device.driverName;\n        }\n      }\n      for (const device of this.ToBeConnectDevice) {\n        if (device.driverType === devicetype) {\n          device.isConnected = false;\n          device.isget = false;\n          device.device = device.driverName;\n        }\n      }\n\n      this.$bus.$emit('deleteDeviceTypeAllocationList', devicetype);\n      if (devicetype == \"MainCamera\") {\n        this.$bus.$emit('MainCameraConnected', 0);\n      } else if (devicetype == \"Mount\") {\n        this.$bus.$emit('MountConnected', 0);\n      } else if (devicetype == \"CFW\") {\n        this.$bus.$emit('CFWConnected', 0);\n      } else if (devicetype == \"Guider\") {\n        this.$bus.$emit('GuiderConnected', 0);\n      }\n    },\n\n    disconnectDriverFail(devicetype) {\n      console.log('disconnectDeviceFail:', devicetype);\n      this.drawer_2 = false\n      if (devicetype == \"all\") {\n        this.sendMessage('Vue_Command', 'disconnectAllDevice');\n        this.SendConsoleLogMsg('Disconnect All Device', 'info');\n        this.haveDeviceConnect = false;\n        this.$bus.$emit('MainCameraConnected', 0);\n        this.$bus.$emit('MountConnected', 0);\n        this.$bus.$emit('CFWConnected', 0);\n        this.$bus.$emit('GuiderConnected', 0);\n        this.clearDeviceList();\n        this.$bus.$emit('deleteDeviceTypeAllocationList', 'all');\n        return;\n      };\n\n      for (const device of this.devices) {\n        if (device.driverType === devicetype && device.isConnected) {\n          device.isConnected = false;\n          device.isget = false;\n          device.device = device.driverName;\n        }\n      }\n      for (const device of this.ToBeConnectDevice) {\n        if (device.driverType === devicetype) {\n          device.isConnected = false;\n          device.isget = false;\n          device.device = device.driverName;\n        }\n      }\n\n      this.$bus.$emit('deleteDeviceTypeAllocationList', devicetype);\n      if (devicetype == \"MainCamera\") {\n        this.$bus.$emit('MainCameraConnected', 0);\n      } else if (devicetype == \"Mount\") {\n        this.$bus.$emit('MountConnected', 0);\n      } else if (devicetype == \"CFW\") {\n        this.$bus.$emit('CFWConnected', 0);\n      } else if (devicetype == \"Guider\") {\n        this.$bus.$emit('GuiderConnected', 0);\n      }\n    },\n    loadSelectedDriverList(deviceObject) {\n      console.log('loadSelectedDriverList:', deviceObject);\n      deviceObject.forEach(device => {\n        // \n        for (const [driverType, driverName] of Object.entries(device)) {\n          this.devices.forEach(device => {\n            if (device.driverType === driverType && device.isConnected == false) {\n              device.device = driverName;\n              device.driverName = driverName;\n            }\n          });\n        }\n      });\n    },\n    loadBindDeviceList(deviceObject) {\n      console.log('loadBindDeviceList:', deviceObject);\n      this.$bus.$emit('loadBindDeviceList', deviceObject);\n\n    },\n    loadBindDeviceTypeList(deviceTypeObject) {\n      console.log('loadBindDeviceTypeList:', deviceTypeObject);\n      this.$bus.$emit('loadBindDeviceTypeList', deviceTypeObject);\n      deviceTypeObject.forEach(deviceType => {\n        const { Type, DeviceName, DriverName, isbind } = deviceType;\n        this.updateDevicesConnect(Type, DeviceName, DriverName, isbind);\n      });\n    },\n    updateSelectedDriver(driverType) {\n\n      this.selectedDriver = null;\n      this.devices.forEach(device => {\n        if (device.driverType === driverType) {\n          this.selectedDriver = device.driverName\n        }\n      });\n      console.log('Current drivers:', this.selectedDriver);\n    },\n    startLoading() {\n      this.loadingDeviceSelection = true;\n    },\n    stopLoading() {\n      this.loadingDeviceSelection = false;\n    },\n    deleteDeviceAllocationList(deviceName) {\n      console.log('deleteDeviceAllocationList:', deviceName);\n      this.$bus.$emit('deleteDeviceAllocationList', deviceName);\n    },\n    UnBindingDevice(type, name, driverName) {\n      console.log('UnBindingDevice:', type, name, driverName);\n      this.updateDevicesConnect(type, name, driverName, false);\n    },\n\n    displayErrorImage() {\n      console.error(\"image is error, load errorImage.svg\");\n      const canvas = document.getElementById('mainCamera-canvas');\n      const ctx = canvas.getContext('2d');\n      const image = new Image();\n\n      image.onload = () => {\n        // \n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        // \n        canvas.width = image.width * devicePixelRatio;\n        canvas.height = image.height * devicePixelRatio;\n        ctx.scale(devicePixelRatio, devicePixelRatio); // ctx\n\n        // \n        ctx.drawImage(image, 0, 0);\n      };\n\n      image.onerror = () => {\n        console.error(\"Failed to load image from \" + image.src);\n        // \n      };\n\n      // ErrorImageURL\n      image.src = ErrorImage; // \n    },\n    handleError(message, location, error = null) {\n      const errorMsg = error ? `${message} at ${location}: ${error}` : `${message} at ${location}`;\n      console.error(errorMsg);\n      this.SendConsoleLogMsg(errorMsg, 'error');\n      this.displayErrorImage(); // \n    },\n    showSelectdisconnectDriver(drivername) {\n      this.showDisconnectDialog = true;\n      this.currentDisconnectDriverName = drivername;\n    },\n    confirmDisconnect() {\n      this.sendMessage('Vue_Command', 'disconnectSelectDriver:' + this.currentDisconnectDriverName);\n      this.showDisconnectDialog = false;\n    },\n\n    // \n    handleMainCanvasClick(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      if (!this.enableMainCanvasClick || this.isDragging || this.drawImgData == null) return; // \n      // console.log(':', event);\n      const canvas = this.$refs.mainCanvas;\n      if (!canvas) return; //  canvas \n      const rect = canvas.getBoundingClientRect();//  canvas \n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      console.log('Mouse clicked at:', x, y);\n      if (!this.isFocusLoopShooting) {\n        //   \n        const desiredCenterX = (x / window.innerWidth * this.visibleWidth) + this.visibleX - this.visibleWidth / 2;\n        const desiredCenterY = (y / window.innerHeight * this.visibleHeight) + this.visibleY - this.visibleHeight / 2;\n\n        // ROI  RedBoxSideLength\n        let side = this.RedBoxSideLength / this.cameraBin;\n        side = Math.max(2, Math.floor(side));\n        if (side % 2 !== 0) side += 1; // \n\n        //  ROI \n        const half = side / 2;\n        const imgW = this.mainCameraSizeX;\n        const imgH = this.mainCameraSizeY;\n\n        let roiX = desiredCenterX - half;\n        let roiY = desiredCenterY - half;\n\n        // \n        const maxX = Math.max(0, imgW - side);\n        const maxY = Math.max(0, imgH - side);\n        roiX = Math.min(Math.max(0, roiX), maxX);\n        roiY = Math.min(Math.max(0, roiY), maxY);\n\n        // \n        roiX = Math.floor(roiX);\n        roiY = Math.floor(roiY);\n        if (roiX % 2 !== 0) roiX += 1;\n        if (roiY % 2 !== 0) roiY += 1;\n\n        this.ROI_x = roiX;\n        this.ROI_y = roiY;\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'sendRedBoxState:' + this.RedBoxSideLength + ':' + this.ROI_x + ':' + this.ROI_y);\n      } else {\n        this.selectStarX = ((x / window.innerWidth * this.visibleWidth) + this.visibleX - this.visibleWidth / 2 - this.ROI_x) * this.cameraBin; // x\n        this.selectStarY = ((y / window.innerHeight * this.visibleHeight) + this.visibleY - this.visibleHeight / 2 - this.ROI_y) * this.cameraBin; // y\n\n        if (this.selectStarX >= 0 && this.selectStarX < this.RedBoxSideLength &&\n          this.selectStarY >= 0 && this.selectStarY < this.RedBoxSideLength) {\n          this.SendConsoleLogMsg('Select Star is in ROI', 'info');\n        } else {\n          this.SendConsoleLogMsg('Select Star is not in ROI', 'error');\n          this.selectStarX = -1;\n          this.selectStarY = -1;\n        }\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'sendSelectStars:' + this.selectStarX + ':' + this.selectStarY);\n      }\n      this.drawImageData();\n    },\n\n    // \n    handleMouseDown(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      if (this.isDragging || this.drawImgData == null) return;\n      this.isDragging = true;\n      this.startX = event.clientX;\n      this.startY = event.clientY;\n      this.currentX = event.clientX;\n      this.currentY = event.clientY;\n\n      // 100ms\n      this.moveIntervalId = setInterval(() => {\n        if (!this.isDragging) return;\n\n        const dx = this.startX - this.currentX;\n        const dy = this.startY - this.currentY;\n        if (isNaN(dx) || isNaN(dy)) {\n          return;\n        }\n        let newVisibleX = this.visibleX + dx / window.innerWidth * this.visibleWidth;\n        let newVisibleY = this.visibleY + dy / window.innerHeight * this.visibleHeight;\n        if (newVisibleX < 0) {\n          newVisibleX = 0;\n        }\n        if (newVisibleY < 0) {\n          newVisibleY = 0;\n        }\n        if (newVisibleX > this.mainCameraSizeX) {\n          newVisibleX = this.mainCameraSizeX;\n        }\n        if (newVisibleY > this.mainCameraSizeY) {\n          newVisibleY = this.mainCameraSizeY;\n        }\n\n        this.visibleX = newVisibleX;\n        this.visibleY = newVisibleY;\n\n        this.startX = this.currentX;\n        this.startY = this.currentY;\n        this.drawImageData();\n        // this.SendConsoleLogMsg(',:' + dx + ',' + dy, 'info');\n      }, 100);\n    },\n    handleMouseMove(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      if (!this.isDragging) return;\n      this.currentX = event.clientX;\n      this.currentY = event.clientY;\n    },\n    handleMouseUp(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      this.isDragging = false;\n\n      // \n      clearInterval(this.moveIntervalId);\n      this.moveIntervalId = null;\n    },\n    handleWheel(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      if (this.drawImgData == null) return;\n      const scaleChange = event.deltaY > 0 ? 0.1 : -0.1; // \n      let newScale = this.scale + scaleChange; // \n      if (newScale < 0.1) {\n        newScale = 0.1;\n      }\n      if (newScale > 1) {\n        newScale = 1;\n      }\n\n      // \n      if (this.pendingScaleChange) {\n        return;\n      }\n\n      // \n      this.pendingScaleChange = true;\n\n      //  requestAnimationFrame \n      requestAnimationFrame(() => {\n        if (newScale != this.scale) {\n          this.scale = newScale; // \n          this.$bus.$emit('setScale', this.scale);\n          this.drawImageData();\n          this.SendConsoleLogMsg(',:' + newScale, 'info');\n        } else {\n          this.SendConsoleLogMsg(',:' + this.scale, 'info');\n        }\n        this.pendingScaleChange = false; // \n      });\n    },\n\n    handleMainCanvasTouch(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      if (!this.enableMainCanvasClick || this.isDragging || this.drawImgData == null) return; // \n      // console.log(':', event);\n      if (!this.enableMainCanvasClick || !event.touches || event.touches.length === 0) return;\n      const canvas = this.$refs.mainCanvas;\n      if (!canvas) return; //  canvas \n      const touch = event.touches[0];\n      const rect = canvas.getBoundingClientRect();//  canvas \n      const x = touch.clientX - rect.left;\n      const y = touch.clientY - rect.top;\n      console.log('Touch at:', x, y);\n      event.preventDefault();// \n      if (!this.isFocusLoopShooting) {\n        //   \n        const desiredCenterX = (x / window.innerWidth * this.visibleWidth) + this.visibleX - this.visibleWidth / 2;\n        const desiredCenterY = (y / window.innerHeight * this.visibleHeight) + this.visibleY - this.visibleHeight / 2;\n\n        // ROI  RedBoxSideLength\n        let side = this.RedBoxSideLength / this.cameraBin;\n        side = Math.max(2, Math.floor(side));\n        if (side % 2 !== 0) side += 1; // \n\n        //  ROI \n        const half = side / 2;\n        const imgW = this.mainCameraSizeX;\n        const imgH = this.mainCameraSizeY;\n\n        let roiX = desiredCenterX - half;\n        let roiY = desiredCenterY - half;\n\n        // \n        const maxX = Math.max(0, imgW - side);\n        const maxY = Math.max(0, imgH - side);\n        roiX = Math.min(Math.max(0, roiX), maxX);\n        roiY = Math.min(Math.max(0, roiY), maxY);\n\n        // \n        roiX = Math.floor(roiX);\n        roiY = Math.floor(roiY);\n        if (roiX % 2 !== 0) roiX += 1;\n        if (roiY % 2 !== 0) roiY += 1;\n\n        this.ROI_x = roiX;\n        this.ROI_y = roiY;\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'sendRedBoxState:' + this.RedBoxSideLength + ':' + this.ROI_x + ':' + this.ROI_y);\n      } else {\n        this.selectStarX = ((x / window.innerWidth * this.visibleWidth) + this.visibleX - this.visibleWidth / 2 - this.ROI_x) * this.cameraBin; // x\n        this.selectStarY = ((y / window.innerHeight * this.visibleHeight) + this.visibleY - this.visibleHeight / 2 - this.ROI_y) * this.cameraBin; // y\n\n        if (this.selectStarX >= 0 && this.selectStarX < this.RedBoxSideLength &&\n          this.selectStarY >= 0 && this.selectStarY < this.RedBoxSideLength) {\n          this.SendConsoleLogMsg('Select Star is in ROI', 'info');\n        } else {\n          this.SendConsoleLogMsg('Select Star is not in ROI', 'error');\n          this.selectStarX = -1;\n          this.selectStarY = -1;\n        }\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'sendSelectStars:' + this.selectStarX + ':' + this.selectStarY);\n      }\n      this.drawImageData();\n    },\n    handleTouchStart(event) {\n      if (this.drawImgData == null) return;\n      // this.SendConsoleLogMsg(':', 'info');\n      if (event.touches.length === 1) { // \n        this.isOneTouch = true;\n        // this.SendConsoleLogMsg('', 'info');\n        this.isDragging = true;\n        this.startTouchX[0] = event.touches[0].clientX;\n        this.startTouchY[0] = event.touches[0].clientY;\n        this.currentTouchX[0] = event.touches[0].clientX;\n        this.currentTouchY[0] = event.touches[0].clientY;\n        // \n        if (this.zoomIntervalId) {\n          clearInterval(this.zoomIntervalId);\n          this.zoomIntervalId = null;\n        }\n\n\n        this.handleMainCanvasTouch(event);\n      } else if (event.touches.length >= 2) { // \n        this.isOneTouch = false;\n        // this.SendConsoleLogMsg('', 'info');\n        this.isDragging = true;\n        // \n        const dx = this.currentTouchX[0] - this.currentTouchX[1];\n        const dy = this.currentTouchY[0] - this.currentTouchY[1];\n        this.startTouchDistance = Math.sqrt(dx * dx + dy * dy);\n        // \n        if (this.moveIntervalId) {\n          clearInterval(this.moveIntervalId);\n          this.moveIntervalId = null;\n        }\n\n\n      } else {\n        // this.SendConsoleLogMsg(':' + event.touches.length, 'info');\n      }\n\n    },\n\n    handleTouchMove(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      if (!this.isDragging || this.drawImgData == null) return;\n      if (event.touches.length == 1) {\n        this.currentTouchX[0] = event.touches[0].clientX;\n        this.currentTouchY[0] = event.touches[0].clientY;\n        if (this.zoomIntervalId) {\n          clearInterval(this.zoomIntervalId);\n          this.zoomIntervalId = null;\n        }\n        if (this.moveIntervalId != null) {\n          return;\n        }\n        // 100ms\n        this.moveIntervalId = setInterval(() => {\n          // console.log('!');\n          if (!this.isDragging || !this.isOneTouch) return;\n\n          const dx = this.startTouchX[0] - this.currentTouchX[0];\n          const dy = this.startTouchY[0] - this.currentTouchY[0];\n          if (isNaN(dx) || isNaN(dy)) {\n            return;\n          }\n          if (dx == 0 && dy == 0) {\n            return;\n          }\n\n          let newVisibleX = this.visibleX + dx / window.innerWidth * this.visibleWidth;\n          let newVisibleY = this.visibleY + dy / window.innerHeight * this.visibleHeight;\n          if (newVisibleX < 0) {\n            newVisibleX = 0;\n          }\n          if (newVisibleY < 0) {\n            newVisibleY = 0;\n          }\n          if (newVisibleX > this.mainCameraSizeX) {\n            newVisibleX = this.mainCameraSizeX;\n          }\n          if (newVisibleY > this.mainCameraSizeY) {\n            newVisibleY = this.mainCameraSizeY;\n          }\n\n          this.visibleX = newVisibleX;\n          this.visibleY = newVisibleY;\n\n          this.startTouchX[0] = this.currentTouchX[0];\n          this.startTouchY[0] = this.currentTouchY[0];\n\n          this.drawImageData();\n        }, 100);\n\n      } else if (event.touches.length >= 2) {\n        this.currentTouchX[0] = event.touches[0].clientX;\n        this.currentTouchY[0] = event.touches[0].clientY;\n        this.currentTouchX[1] = event.touches[1].clientX;\n        this.currentTouchY[1] = event.touches[1].clientY;\n\n        // \n        if (this.moveIntervalId) {\n          clearInterval(this.moveIntervalId);\n          this.moveIntervalId = null;\n        }\n        if (this.zoomIntervalId != null) {\n          return;\n        }\n        // 100ms\n        this.zoomIntervalId = setInterval(() => {\n          if (!this.isDragging || !this.isOneTouch) return;\n          const dx = this.currentTouchX[0] - this.currentTouchX[1];\n          const dy = this.currentTouchY[0] - this.currentTouchY[1];\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          this.SendConsoleLogMsg(' distance:' + distance, 'info');\n          if (this.startTouchDistance == 0) {\n            this.startTouchDistance = distance;\n          }\n          // \n          const scaleChange = distance / this.startTouchDistance;\n          this.SendConsoleLogMsg(' scaleChange:' + scaleChange, 'info');\n          let newScale = this.scale * scaleChange; // \n          if (newScale < 0.1) {\n            newScale = 0.1;\n          }\n          if (newScale > 1) {\n            newScale = 1;\n          }\n          if (newScale != this.scale) {\n            this.SendConsoleLogMsg(',:' + newScale, 'info');\n            this.scale = newScale; // \n            this.$bus.$emit('setScale', this.scale);\n            this.drawImageData();\n          } else {\n            this.SendConsoleLogMsg(',:' + this.scale, 'info');\n          }\n          this.startTouchDistance = distance; // \n        }, 100);\n      } else {\n        this.SendConsoleLogMsg(':' + event.touches.length, 'info');\n      }\n    },\n\n    handleTouchEnd(event) {\n      // this.SendConsoleLogMsg(':', 'info');\n      this.isDragging = false; // \n      // \n      if (this.moveIntervalId) {\n        clearInterval(this.moveIntervalId);\n        this.moveIntervalId = null;\n      }\n      if (this.zoomIntervalId) {\n        clearInterval(this.zoomIntervalId);\n        this.zoomIntervalId = null;\n      }\n    },\n\n    ScaleChange(type) {\n      if (this.drawImgData == null) return;\n      if (type == '+') {\n        this.scale -= 0.1;\n      } else if (type == '-') {\n        this.scale += 0.1;\n      }\n      if (this.scale < 0.1) {\n        this.scale = 0.1;\n      }\n      if (this.scale > 1) {\n        this.scale = 1;\n      }\n      this.$bus.$emit('setScale', this.scale);\n      this.drawImageData();\n    },\n\n    // ROI\n    showRoiImage(fileName, destX, destY) {\n      if (this.RedBoxSideLength == 0 || this.RedBoxSideLength == null) {\n        this.SendConsoleLogMsg('RedBoxSideLength is 0 or null', 'error');\n        return;\n      }\n      if (this.isProcessingImage) {\n        this.SendConsoleLogMsg('Image is being transmitted, current processing is slow, skipping one frame.', 'warning');\n        return;\n      }\n      this.isProcessingImage = true;\n      const imagePath = 'img/' + fileName;\n      // AbortControllerfetch\n      const fetchController = new AbortController();\n      const fetchSignal = fetchController.signal;\n\n      // const startDownloadTime = performance.now();\n\n      //  fetch API \n      fetch(imagePath, { cache: 'no-store', signal: fetchSignal })\n        .then(response => response.arrayBuffer())\n        .then(buffer => {\n          // const endDownloadTime = performance.now();\n          // const downloadTime = endDownloadTime - startDownloadTime;\n          if (this.isFocusLoopShooting) this.$bus.$emit('AppSendMessage', 'Vue_Command', 'showRoiImageSuccess:true');\n          else this.$bus.$emit('AppSendMessage', 'Vue_Command', 'showRoiImageSuccess:false');\n          let time1 = performance.now();\n          let src, imgData, targetImg8;\n          try {\n            const uint16Array = new Uint16Array(buffer);\n            let newWidth = parseInt(this.RedBoxSideLength / this.cameraBin);\n            let newHeight = parseInt(this.RedBoxSideLength / this.cameraBin);\n            if (newWidth % 2 != 0) {\n              newWidth = newWidth - 1;\n            }\n            if (newHeight % 2 != 0) {\n              newHeight = newHeight - 1;\n            }\n            if (uint16Array.length !== newWidth * newHeight) {\n              this.SendConsoleLogMsg('uint16Array.length (' + uint16Array.length + ') !== newWidth * newHeight (' + newWidth * newHeight + ')', 'error');\n              return;\n            }\n            //  Mat \n            src = new cv.Mat(newHeight, newWidth, cv.CV_16UC1);\n            src.data16U.set(uint16Array);\n            let time2 = performance.now();\n            this.SendConsoleLogMsg('mat: ' + (time2 - time1).toFixed(0) + 'ms', 'info');\n            if (this.lastImageProcessParams.isColorCamera == 'true' || this.lastImageProcessParams.isColorCamera == 'True' || this.lastImageProcessParams.isColorCamera) {\n              targetImg8 = this.applyStretchAndGain(src, this.lastImageProcessParams.analysis, 'bayer', this.lastImageProcessParams.CFA, this.lastImageProcessParams.blackLevel, this.lastImageProcessParams.whiteLevel);\n\n            } else {\n              targetImg8 = this.applyStretchAndGain(src, this.lastImageProcessParams.analysis, 'gray', this.lastImageProcessParams.CFA, this.lastImageProcessParams.blackLevel, this.lastImageProcessParams.whiteLevel);\n     \n            }\n            time1 = performance.now();\n            this.SendConsoleLogMsg('applyStretchAndGain: ' + (time1 - time2).toFixed(0) + 'ms', 'info');\n            src.delete();\n            src = null;\n\n            //  Mat  ImageData \n            imgData = new ImageData(new Uint8ClampedArray(targetImg8.data), targetImg8.cols, targetImg8.rows);\n            targetImg8.delete();\n            targetImg8 = null;\n            // \n            // this.bufferCtx.clearRect(this.ROI_x, this.ROI_y, targetImg8.cols, targetImg8.rows);\n            this.bufferCtx.putImageData(imgData, this.ROI_x, this.ROI_y);\n            // this.SendConsoleLogMsg('ROI:' + fileName + ':' + this.ROI_x + ':' + this.ROI_y, 'info');\n            // \n            // time2 = performance.now();\n            // this.SendConsoleLogMsg(': ' + (time2 - time1).toFixed(0) + 'ms', 'info');\n            this.drawImageData();\n            // time1 = performance.now();\n            // this.SendConsoleLogMsg('drawImageData: ' + (time1 - time2).toFixed(0) + 'ms', 'info');\n            this.focuserPictureFileName = fileName;\n            // const processTime = performance.now() - downloadTime;\n            // this.SendConsoleLogMsg(`ROI : ${downloadTime.toFixed(0)}ms, : ${processTime.toFixed(0)}ms`, 'info');\n\n          } catch (error) {\n            console.error(`: ${imagePath}`, error);\n          } finally {\n            //  Mat  ImageData \n            if (src && !src.isDeleted()) {\n              src.delete();\n              src = null; //  src \n            }\n            if (targetImg8 && !targetImg8.isDeleted()) {\n              targetImg8.delete();\n              targetImg8 = null; //  originalImg8 \n            }\n            //  buffer \n            buffer = null;\n            this.isProcessingImage = false;\n          }\n        })\n        .catch(error => {\n          if (error.name === 'AbortError') {\n            console.log('Fetch request cancelled');\n          } else {\n            console.error(`: ${imagePath}`, error);\n          }\n          this.isProcessingImage = false;\n        });\n\n      //  fetch \n      this.$once('hook:beforeDestroy', () => {\n        fetchController.abort();\n      });\n    },\n    setRedBoxState(length, x, y) {\n      this.SendConsoleLogMsg('setRedBoxState:' + length + ',' + x + ',' + y, 'info');\n      this.$bus.$emit('setRedBoxPosition', x, y);\n      this.$bus.$emit('setRedBoxSideLength', length);\n    },\n    setFocuserState(state) {\n      if (state === 'selectstars') {\n        this.isFocusLoopShooting = true;\n      } else {\n        this.isFocusLoopShooting = false;\n      }\n    },\n    setShowSelectStar(state) {\n      this.showSelectStar = state;\n    },\n    RedBoxSizeChange(length) {\n      this.RedBoxSideLength = parseInt(length);\n      // this.$bus.$emit('AppSendMessage', 'Vue_Command', 'sendRedBoxState:' + this.RedBoxSideLength + ':' + this.ROI_x + ':' + this.ROI_y);\n    },\n    setMainCameraParameters(parameters) {\n      for (const parameter in parameters) {\n        const item = this.MainCameraConfigItems.find(item => item.label === parameter);\n        if (item) {\n          item.value = parameters[parameter];\n        } else {\n          if (parameter == 'RedBoxSize') {\n            this.$bus.$emit('setRedBoxSideLength', parameters[parameter]);\n            this.RedBoxSideLength = parseInt(parameters[parameter]);\n          } else if (parameter == 'ROI_x') {\n            this.ROI_x = parseFloat(parameters[parameter]);\n          } else if (parameter == 'ROI_y') {\n            this.ROI_y = parseFloat(parameters[parameter]);\n          } \n          else {\n            console.error(`${parameter}`);\n          }\n        }\n      }\n      this.confirmConfiguration(this.MainCameraConfigItems);\n    },\n    showCanvas(canvas) {\n      if (canvas === 'Stel') {\n        this.currentcanvas = 'Stel';\n        this.showStelCanvas();\n      }\n      else if (canvas === 'MainCamera') {\n\n        this.currentcanvas = 'MainCamera';\n        this.showMainCameraCanvas();\n        this.drawImageData()\n      }\n      else if (canvas === 'GuiderCamera') {\n        this.currentcanvas = 'GuiderCamera';\n        this.showGuiderCameraCanvas();\n      } else {\n        this.SendConsoleLogMsg(\"unknown canvas: \" + canvas, 'error');\n      }\n    },\n    // \n    decrementAndNotify(item) {\n      if (item.value > item.inputMin) {\n        item.value -= item.inputStep;\n        this.handleConfigChange(item.label, item.value);\n      }\n    },\n\n    incrementAndNotify(item) {\n      if (item.value < item.inputMax) {\n        item.value += item.inputStep;\n        this.handleConfigChange(item.label, item.value);\n      }\n    },\n\n    // \n    handleConfigChange(label, value) {\n      console.log(`: ${label} = ${value}`);\n      if (value !== '') {\n        // console.log(item.label, item.value);\n        this.SendConsoleLogMsg(label + ':' + value, 'info');\n        this.$bus.$emit(label, label + ':' + value);\n      } else if (value == '' && label === 'Focal Length (mm)') {\n        this.SendConsoleLogMsg(label + 'is NULL', 'info');\n        this.$bus.$emit(item.label, item.label + ':');\n      }\n    },\n    // \n    startCalibrationProcess() {\n      this.calibrationInfo.isCalibrating = true;\n      this.calibrationInfo.calibrationState = 'running';\n      this.calibrationInfo.calibrationStep = 0;\n      this.calibrationInfo.calibrationMessage = this.$t('Preparing to start focuser travel calibration...');\n      console.log('App: Calibration started:', this.calibrationInfo);\n    },\n\n    updateCalibrationInfo(step, message, state) {\n      try {\n        this.calibrationInfo.calibrationStep = step;\n        // \n        if (message && typeof message === 'string') {\n          this.calibrationInfo.calibrationMessage = this.$t(message);\n        } else {\n          this.calibrationInfo.calibrationMessage = message;\n        }\n        if (state) {\n          this.calibrationInfo.calibrationState = state;\n        }\n        if (step === 0) {\n          this.calibrationInfo.isCalibrating = true;\n        }\n        console.log('App: Calibration info updated:', this.calibrationInfo);\n      } catch (error) {\n        console.error('Error in updateCalibrationInfo:', error);\n      }\n    },\n\n    endCalibration() {\n      this.calibrationInfo.isCalibrating = false;\n      this.calibrationInfo.calibrationState = 'idle';\n      this.calibrationInfo.calibrationStep = 0;\n      this.calibrationInfo.calibrationMessage = '';\n      console.log('App: Calibration ended');\n    },\n  },\n  computed: {\n    nav: {\n      get: function () {\n        console.log('nav:', this.$store.state.showNavigationDrawer);\n        return this.$store.state.showNavigationDrawer\n      },\n      set: function (v) {\n        if (this.$store.state.showNavigationDrawer !== v) {\n          console.log('nav:', this.$store.state.showNavigationDrawer);\n          this.$store.commit('toggleBool', 'showNavigationDrawer')\n        }\n      }\n    },\n    storeCurrentLocation: function () {\n      return this.$store.state.currentLocation\n    },\n    getQTClientVersionColor() {\n      if (this.QTClientVersion === 'Not connected') {\n        return 'rgba(255, 0, 0, 0.5)'; //  0.5\n      } else {\n        return 'rgba(255, 255, 255, 0.5)'; //  0.5\n      }\n    },\n    isMobile() {\n      var ua = navigator.userAgent || '';\n      var touch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);\n      var uaDataMobile = null;\n      // \n      if (navigator.userAgentData && typeof navigator.userAgentData.mobile !== 'undefined') {\n        uaDataMobile = navigator.userAgentData.mobile;\n      }\n      var mobileLike = /Android|iPhone|iPad|iPod|Mobile|Tablet/i.test(ua);\n      return (uaDataMobile !== null ? uaDataMobile : mobileLike) && !!touch;\n    },\n    isDesktop() {\n      return !this.isMobile;\n    },\n  },\n  watch: {\n    storeCurrentLocation: function (loc) {\n      const DD2R = Math.PI / 180\n      this.$stel.core.observer.latitude = loc.lat * DD2R\n      this.$stel.core.observer.longitude = loc.lng * DD2R\n      this.$stel.core.observer.elevation = loc.alt\n\n      // At startup, we need to wait for the location to be set before deciding which\n      // startup time to set so that it's night time.\n      if (!this.startTimeIsSet) {\n        this.$stel.core.observer.utc = swh.getTimeAfterSunset(this.$stel)\n        this.startTimeIsSet = true\n      }\n      // Init of time and date is complete\n      this.$store.commit('setValue', { varName: 'initComplete', newValue: true })\n    },\n    $route: function () {\n      // react to route changes...\n      this.setStateFromQueryArgs()\n    },\n    CurrentDriverType(newVal) {\n      //  CurrentDriverType  selectedDriver\n      this.updateSelectedDriver(newVal);\n    }\n  },\n  mounted: function () {\n    // // \n    // document.addEventListener('touchstart', this.preventDefault, { passive: false });\n    // document.addEventListener('touchmove', this.preventDefault, { passive: false });\n    // document.addEventListener('touchend', this.preventDefault, { passive: false });\n\n    // // \n    // document.addEventListener('mousedown', this.preventDefault, { passive: false });\n    // document.addEventListener('mousemove', this.preventDefault, { passive: false });\n    // document.addEventListener('mouseup', this.preventDefault, { passive: false });\n\n    // // \n    // document.addEventListener('wheel', this.preventDefault, { passive: false });\n\n    let that = this\n\n    this.getLocationHostName();\n\n    this.loadImageToCanvasMainCamera();\n    this.loadImageToCanvasGuiderCamera();\n\n    this.initCanvas();\n    this.addEventListeners();\n\n    for (const i in this.$stellariumWebPlugins()) {\n      const plugin = this.$stellariumWebPlugins()[i]\n      if (plugin.onAppMounted) {\n        plugin.onAppMounted(that)\n      }\n    }\n\n    this.connect();\n    this.setupNetworkStatusListener();\n\n    //  Promise  OpenCV.js \n    this.loadOpenCv().then(() => {\n      if (!this._isDestroyed) { // \n        console.log('OpenCV.js is ready');\n        this.onCvReady();  //  OpenCV \n      }\n    }).catch(error => {\n      console.error('Error loading OpenCV.js:', error);\n    });\n\n    // const script = document.createElement('script');\n    // script.src = 'https://docs.opencv.org/4.5.5/opencv.js';\n    // script.async = true;\n    // script.onload = () => this.onCvReady();\n    // document.head.appendChild(script);\n\n    import('@/assets/js/stellarium-web-engine.wasm').then(f => {\n      if (!this._isDestroyed) { // \n        // Initialize the StelWebEngine viewer singleton\n        // After this call, the StelWebEngine state will always be available in vuex store\n        // in the $store.stel object in a reactive way (useful for vue components).\n        // To modify the state of the StelWebEngine, it's enough to call/set values directly on the $stel object\n        try {\n          swh.initStelWebEngine(that.$store, f.default, that.$refs.stelCanvas, function () {\n            // Start auto location detection (even if we don't use it)\n            swh.getGeolocation().then(p => swh.geoCodePosition(p, that)).then((loc) => {\n              that.$store.commit('setAutoDetectedLocation', loc)\n            }, (error) => { console.log(error) })\n\n            that.$stel.setFont('regular', process.env.BASE_URL + 'fonts/Roboto-Regular.ttf', 1.38)\n            that.$stel.setFont('bold', process.env.BASE_URL + 'fonts/Roboto-Bold.ttf', 1.38)\n            that.$stel.core.constellations.show_only_pointed = false\n\n            that.setStateFromQueryArgs()\n            that.guiComponent = 'Gui'\n            for (const i in that.$stellariumWebPlugins()) {\n              const plugin = that.$stellariumWebPlugins()[i]\n              if (plugin.onEngineReady) {\n                plugin.onEngineReady(that)\n              }\n            }\n\n            if (!that.dataSourceInitDone) {\n              // Set all default data sources\n              const core = that.$stel.core\n              core.stars.addDataSource({ url: process.env.BASE_URL + 'skydata/stars' })\n              core.stars.addDataSource({ url: process.env.BASE_URL + 'skydata/stars_base' })\n              core.stars.addDataSource({ url: process.env.BASE_URL + 'skydata/stars_extend' })\n              core.dss.addDataSource({ url: process.env.BASE_URL + 'skydata/dss/v1' })\n              // core.stars.addDataSource({ url: process.env.BASE_URL + 'skydata/stars' })\n\n              // Allow to specify a custom path for sky culture data\n              if (that.$route.query.sc) {\n                const key = that.$route.query.sc.substring(that.$route.query.sc.lastIndexOf('/') + 1)\n                core.skycultures.addDataSource({ url: that.$route.query.sc, key: key })\n                core.skycultures.current_id = key\n              } else {\n                core.skycultures.addDataSource({ url: process.env.BASE_URL + 'skydata/skycultures/western', key: 'western' })\n              }\n\n              core.dsos.addDataSource({ url: process.env.BASE_URL + 'skydata/dso' })\n              core.landscapes.addDataSource({ url: process.env.BASE_URL + 'skydata/landscapes/guereins', key: 'guereins' })\n              core.milkyway.addDataSource({ url: process.env.BASE_URL + 'skydata/surveys/milkyway' })\n              // core.dss.addDataSource({ url: process.env.BASE_URL + 'skydata/surveys/dss' })\n              core.minor_planets.addDataSource({ url: process.env.BASE_URL + 'skydata/mpcorb.dat', key: 'mpc_asteroids' })\n              core.planets.addDataSource({ url: process.env.BASE_URL + 'skydata/surveys/sso/moon', key: 'moon' })\n              core.planets.addDataSource({ url: process.env.BASE_URL + 'skydata/surveys/sso/sun', key: 'sun' })\n              core.planets.addDataSource({ url: process.env.BASE_URL + 'skydata/surveys/sso/moon', key: 'default' })\n              core.comets.addDataSource({ url: process.env.BASE_URL + 'skydata/CometEls.txt', key: 'mpc_comets' })\n              core.satellites.addDataSource({ url: process.env.BASE_URL + 'skydata/tle_satellite.jsonl.gz', key: 'jsonl/sat' })\n\n              // Mount Pointing\n              glStel = that.setGloabalStel(that.$stel);\n              glLayer = that.setGlobalLayer(that.$stel);\n              glTestCircle = that.testAddCircle(that.$stel, glLayer);\n\n            }\n          })\n        } catch (e) {\n          this.$store.commit('setValue', { varName: 'wasmSupport', newValue: false })\n        }\n      }\n    });\n\n    window.addEventListener('load', () => {\n      // \n      this.SendConsoleLogMsg('', 'info');\n      this.$bus.$emit('AppSendMessage', 'Process_Command_Return', 'VueClientVersion:' + process.env.VUE_APP_VERSION);\n    })\n\n    document.addEventListener('DOMContentLoaded', () => {\n      // DOM\n      this.SendConsoleLogMsg('DOM', 'info');\n    })\n\n  },\n  // \n  beforeDestroy() {\n    document.removeEventListener('touchstart', this.preventDefault);\n    document.removeEventListener('touchmove', this.preventDefault);\n    document.removeEventListener('touchend', this.preventDefault);\n\n    document.removeEventListener('mousedown', this.preventDefault);\n    document.removeEventListener('mousemove', this.preventDefault);\n    document.removeEventListener('mouseup', this.preventDefault);\n\n    document.removeEventListener('wheel', this.preventDefault);\n\n    // \n    if (this.calibrationCircles) {\n      this.calibrationCircles.forEach(circle => {\n        if (glLayer && circle) {\n          glLayer.remove(circle);\n        }\n      });\n      this.calibrationCircles = [];\n    }\n\n    if (this.adjustmentCircles) {\n      this.adjustmentCircles.forEach(circle => {\n        if (glLayer && circle) {\n          glLayer.remove(circle);\n        }\n      });\n      this.adjustmentCircles = [];\n    }\n\n    // \n    this.stopFieldUpdateTimer();\n  },\n\n\n}\n</script>\n\n<style>\nbody {\n  background-color: black;\n  /*  */\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n\n  /*  */\n  /* touch-action: none;\n  -ms-touch-action: none; */\n\n  /*  */\n  -webkit-tap-highlight-color: transparent;\n\n  /*  */\n  overscroll-behavior: none;\n  -webkit-overflow-scrolling: touch;\n\n  /*  */\n  -webkit-touch-callout: none;\n\n  /*  */\n  -webkit-user-drag: none;\n  -khtml-user-drag: none;\n  -moz-user-drag: none;\n  -o-user-drag: none;\n}\n\n/*  */\ncanvas {\n  /* touch-action: none;\n  -ms-touch-action: none; */\n  -webkit-tap-highlight-color: transparent;\n  -webkit-user-drag: none;\n}\n\n/*  */\n/* * {\n  touch-action: none;\n  -ms-touch-action: none;\n} */\n\na {\n  color: #82b1ff;\n}\n\na:link {\n  text-decoration-line: none;\n}\n\n.divider_menu {\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n\nhtml {\n  overflow-y: visible;\n}\n\nhtml,\nbody,\n#app {\n  overflow-y: visible !important;\n  overflow-x: visible;\n  position: fixed !important;\n  width: 100%;\n  height: 100%;\n  padding: 0 !important;\n  font-size: 10px;\n}\n\n.fullscreen {\n  overflow-y: hidden;\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  padding: 0 !important;\n}\n\n.click-through {\n  pointer-events: none;\n}\n\n.get-click {\n  pointer-events: all;\n}\n\n.dialog {\n  background: transparent;\n}\n\n.menu__content {\n  background-color: transparent !important;\n}\n\n#stel {\n  height: 100%;\n  width: 100%;\n  position: absolute;\n}\n\n#stel-canvas {\n  width: 100%;\n  height: 100%;\n}\n\n#mainCamera-canvas {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n#guiderCamera-canvas {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.right_panel {\n  padding-right: 400px;\n}\n\n.v-btn {\n  margin-left: 8px;\n  margin-right: 8px;\n  margin-top: 6px;\n  margin-bottom: 6px;\n}\n\n.v-application--wrap {\n  min-height: 100% !important;\n}\n\n\n.my-custom-button {\n  background-color: #4CAF50;\n  /*  */\n  color: white;\n  /*  */\n  padding: 15px 32px;\n  /*  */\n  text-align: center;\n  /*  */\n  text-decoration: none;\n  /*  */\n  display: inline-block;\n  /*  */\n  font-size: 16px;\n  /*  */\n  margin: 4px 2px;\n  /*  */\n  cursor: pointer;\n  /*  */\n  border: none;\n  /*  */\n}\n\n.connected-device {\n  color: #4dc251;\n}\n\n.btn-confirm {\n  width: 60px;\n  height: 30px;\n  background-color: rgba(255, 255, 255, 0.1);\n  border-radius: 10px;\n}\n\n.btn-slider {\n  width: 20px;\n  height: 20px;\n  background-color: rgba(255, 255, 255, 0.1);\n  border-radius: 10px;\n}\n\n.btn-confirm:active,\n.btn-slider:active {\n  transform: scale(0.95);\n  background-color: rgba(255, 255, 255, 0.5);\n}\n\n\n/*  */\n.config-item {\n  text-align: center;\n  width: 100%;\n  margin-bottom: 5px;\n}\n\n/*  */\n.config-title {\n  display: inline-block;\n  font-size: 15px;\n  color: rgba(255, 255, 255, 0.5);\n  user-select: none;\n  margin-top: 10px;\n  margin-bottom: 5px;\n}\n\n/*  */\n.config-input {\n  width: 150px;\n  display: inline-block;\n  margin: 5px 0;\n}\n\n/*  */\n.slider-container {\n  text-align: left;\n  height: 30px;\n  width: 150px;\n  display: inline-block;\n  margin-bottom: 20px;\n  position: relative;\n}\n\n/*  */\n.slider-label {\n  display: inline-block;\n  font-size: 15px;\n  color: rgba(255, 255, 255, 0.5);\n  user-select: none;\n  margin-bottom: 5px;\n}\n\n/*  */\n.slider-control {\n  position: absolute;\n  left: 30px;\n  width: calc(100% - 60px);\n}\n\n/*  */\n.tip-field {\n  display: grid;\n  grid-template-columns: auto 1fr auto;\n  /*  |  |  */\n  align-items: center;\n  gap: 8px;\n  padding: 8px 4px 4px;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.2);\n  /*  */\n}\n\n.tip-label {\n  color: var(--v-theme-primary, #42a5f5);\n  font-size: 0.9rem;\n  line-height: 1.2;\n  white-space: nowrap;\n}\n\n.tip-value {\n  font-size: 1.25rem;\n  font-weight: 600;\n  letter-spacing: 0.02em;\n  user-select: text;\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace;\n}\n\n.tip-copy {\n  margin-left: 4px;\n  opacity: 0.9;\n}\n\n/*  */\n.btn-minus {\n  position: absolute;\n  left: 5px;\n  transform: translateY(5px);\n}\n\n/*  */\n.btn-plus {\n  position: absolute;\n  right: 5px;\n  transform: translateY(5px);\n}\n\n/*  */\n.btn-content {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n}\n\n/*  */\n.btn-icon {\n  min-height: 10px;\n  pointer-events: none;\n}\n\n/*  */\n.config-switch {\n  width: 150px;\n  display: inline-block;\n  margin-bottom: 0;\n  margin-top: 0;\n}\n\n/*  */\n.config-items-container::-webkit-scrollbar {\n  width: 6px;\n}\n\n.config-items-container::-webkit-scrollbar-track {\n  background: rgba(0, 0, 0, 0.1);\n  border-radius: 3px;\n}\n\n.config-items-container::-webkit-scrollbar-thumb {\n  background: rgba(255, 255, 255, 0.3);\n  border-radius: 3px;\n}\n\n.config-items-container::-webkit-scrollbar-thumb:hover {\n  background: rgba(255, 255, 255, 0.5);\n}\n\n/* Firefox */\n.config-items-container {\n  scrollbar-width: thin;\n  scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.1);\n}\n\n/*  */\n.params-container {\n  overflow-y: auto;\n  height: 100%;\n}\n\n.params-container::-webkit-scrollbar {\n  width: 6px;\n}\n\n.params-container::-webkit-scrollbar-track {\n  background: rgba(0, 0, 0, 0.1);\n  border-radius: 3px;\n}\n\n.params-container::-webkit-scrollbar-thumb {\n  background: white;\n  border-radius: 3px;\n}\n\n.params-container::-webkit-scrollbar-thumb:hover {\n  background: rgba(255, 255, 255, 0.8);\n}\n\n/* Firefox */\n.params-container {\n  scrollbar-width: thin;\n  scrollbar-color: white rgba(0, 0, 0, 0.1);\n}\n\n/*  */\n.calibration-info-box {\n  position: fixed;\n  top: 50vh;\n  left: 50vw;\n  transform: translate(-50%, -50%);\n  background-color: rgba(0, 0, 0, 0.9);\n  backdrop-filter: blur(15px);\n  border: 2px solid rgba(255, 165, 0, 0.8);\n  border-radius: 15px;\n  padding: 25px;\n  z-index: 10001;\n  min-width: 350px;\n  max-width: 450px;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);\n}\n\n.calibration-content {\n  text-align: center;\n  color: white;\n}\n\n.calibration-title {\n  font-size: 20px;\n  font-weight: bold;\n  margin-bottom: 20px;\n  color: #FFA500;\n  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);\n}\n\n.calibration-message {\n  font-size: 16px;\n  line-height: 1.6;\n  margin-bottom: 20px;\n  color: #FFFFFF;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);\n}\n\n.calibration-progress {\n  font-size: 14px;\n  color: #FFA500;\n  font-weight: bold;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);\n}\n</style>"]}]}