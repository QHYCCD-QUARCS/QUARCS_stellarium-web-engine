{"remainingRequest":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Focus.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Focus.vue","mtime":1760075043417},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1756885033541},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/thread-loader/dist/cjs.js","mtime":1756885034172},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/babel-loader/lib/index.js","mtime":1756885033526},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1756885033541},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js","mtime":1756885034208}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGVjaGFydHMgZnJvbSAnZWNoYXJ0cyc7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0xpbmVDaGFydCcsCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGNvbnRhaW5lck1heFdpZHRoOiAxNTAsCiAgICAgIGNoYXJ0RGF0YTE6IFtdLAogICAgICBjaGFydERhdGEyOiBbXSwKICAgICAgY2hhcnREYXRhMzogW10sCiAgICAgIGNoYXJ0RGF0YTQ6IFtdLCAvLyDlvILluLjngrnmlbDmja4KICAgICAgeEF4aXNfbWluOiAwLAogICAgICB4QXhpc19tYXg6IDYwMDAsCiAgICAgIHlBeGlzX21pbjogMCwKICAgICAgeUF4aXNfbWF4OiAzMCwKICAgICAgcmFuZ2U6IDQsCiAgICAgIGN1cnJlbnRYOiAwLAogICAgICBIRlJNYXg6IDAsCiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLAogICAgICBzdGFydFg6IDAsCiAgICAgIGRlbHRhWDogMCwKICAgICAgeF9taW46IC02MDAwMCwKICAgICAgeF9tYXg6IDYwMDAwLAogICAgICBxdWFkcmF0aWNSZXN1bHQ6IHsKICAgICAgICBzaG93OiBmYWxzZSwKICAgICAgICBhOiAwLAogICAgICAgIGI6IDAsCiAgICAgICAgYzogMCwKICAgICAgICBiZXN0UG9zaXRpb246IDAsCiAgICAgICAgbWluSEZSOiAwCiAgICAgIH0sCiAgICAgIGxvZ2dlcjogbnVsbCAvLyDnu5/kuIDml6Xlv5forrDlvZXlmagKICAgIH07CiAgfSwKICBjb21wdXRlZDogewogICAgdmFsaWREYXRhUG9pbnRDb3VudCgpIHsKICAgICAgLy8g6L+H5ruk5o6J5byC5bi45pWw5o2u54K577yI5L2N572u5Li6MOaIlui0n+aVsO+8jEhGUuS4ujDmiJbotJ/mlbDvvIkKICAgICAgcmV0dXJuIHRoaXMuY2hhcnREYXRhMS5maWx0ZXIocG9pbnQgPT4gCiAgICAgICAgcG9pbnRbMF0gPiAwICYmIHBvaW50WzFdID4gMAogICAgICApLmxlbmd0aDsKICAgIH0sCiAgICAKICAgIC8vIOiOt+WPlua4heeQhuWQjueahOaVsOaNrueCue+8iOWOu+mZpOW8guW4uOeCue+8iQogICAgY2xlYW5EYXRhUG9pbnRzKCkgewogICAgICByZXR1cm4gdGhpcy51bmlmaWVkT3V0bGllckRldGVjdGlvbih0aGlzLmNoYXJ0RGF0YTEpOwogICAgfSwKICAgIAogICAgLy8g6I635Y+W5byC5bi454K55pWw5o2uCiAgICBvdXRsaWVyRGF0YVBvaW50cygpIHsKICAgICAgY29uc3QgY2xlYW5EYXRhID0gdGhpcy51bmlmaWVkT3V0bGllckRldGVjdGlvbih0aGlzLmNoYXJ0RGF0YTEpOwogICAgICByZXR1cm4gdGhpcy5jaGFydERhdGExLmZpbHRlcihwb2ludCA9PiAKICAgICAgICAhY2xlYW5EYXRhLnNvbWUoY2xlYW5Qb2ludCA9PiAKICAgICAgICAgIGNsZWFuUG9pbnRbMF0gPT09IHBvaW50WzBdICYmIGNsZWFuUG9pbnRbMV0gPT09IHBvaW50WzFdCiAgICAgICAgKQogICAgICApOwogICAgfQogIH0sCiAgbW91bnRlZCgpIHsKICAgIC8vIOWIneWni+WMlmxvZ2dlcgogICAgdGhpcy5pbml0TG9nZ2VyKCk7CiAgICAKICAgIC8vIOWcqOW8gOWPkeeOr+Wig+S4i+i/kOihjOa1i+ivlQogICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7CiAgICAgIC8vIOW7tui/n+aJp+ihjOa1i+ivle+8jOehruS/nee7hOS7tuWujOWFqOWIneWni+WMlgogICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDlvIDlj5Hnjq/looPvvJrov5DooYzkuozmrKHmm7Lnur/mi5/lkIjmtYvor5UnKTsKICAgICAgICB0aGlzLnRlc3RRdWFkcmF0aWNGaXR0aW5nKCk7CiAgICAgIH0sIDEwMDApOwogICAgfQogIH0sCiAgY3JlYXRlZCgpIHsKICAgIHRoaXMuJGJ1cy4kb24oJ0ZvY3VzUG9zaXRpb24nLCB0aGlzLmNoYW5nZVJhbmdlX3gpOwogICAgLy8gdGhpcy4kYnVzLiRvbignVXBkYXRlSEZSJywgdGhpcy5VcGRhdGVIRlIpOwogICAgdGhpcy4kYnVzLiRvbignZml0UXVhZHJhdGljQ3VydmUnLCB0aGlzLmZpdFF1YWRyYXRpY0N1cnZlKTsKICAgIHRoaXMuJGJ1cy4kb24oJ2ZpdFF1YWRyYXRpY0N1cnZlX21pblBvaW50JywgdGhpcy5maXRRdWFkcmF0aWNDdXJ2ZV9taW5Qb2ludCk7CgogICAgdGhpcy4kYnVzLiRvbignQ2xlYXJmaXRRdWFkcmF0aWNDdXJ2ZScsIHRoaXMuY2xlYXJDaGFydERhdGEyKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0NsZWFyQWxsRGF0YScsIHRoaXMuQ2xlYXJBbGxEYXRhKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0NsZWFyRmluZURhdGEnLCB0aGlzLkNsZWFyRmluZURhdGEpOwogICAgdGhpcy4kYnVzLiRvbigndXBkYXRlRm9jdXNDaGFydFdpZHRoJywgdGhpcy5pbml0Q2hhcnQpOwogICAgdGhpcy4kYnVzLiRvbignYWRkRGF0YV9Qb2ludCcsIHRoaXMuYWRkRGF0YV9Qb2ludCk7CiAgICB0aGlzLiRidXMuJG9uKCdhZGRNaW5Qb2ludERhdGFfUG9pbnQnLCB0aGlzLmFkZE1pblBvaW50RGF0YV9Qb2ludCk7CiAgICB0aGlzLiRidXMuJG9uKCdhZGRMaW5lRGF0YV9Qb2ludCcsIHRoaXMuYWRkTGluZURhdGFfUG9pbnQpOwogICAgdGhpcy4kYnVzLiRvbignc2V0Rm9jdXNDaGFydFJhbmdlJywgdGhpcy5zZXRGb2N1c0NoYXJ0UmFuZ2UpOwogIH0sCiAgbWV0aG9kczogewogICAgLy8g5Yid5aeL5YyWbG9nZ2VyCiAgICBpbml0TG9nZ2VyKCkgewogICAgICB0aGlzLmxvZ2dlciA9IHsKICAgICAgICBpbmZvOiAobWVzc2FnZSwgLi4uYXJncykgPT4gewogICAgICAgICAgY29uc29sZS5sb2coYFtJTkZPXSAke21lc3NhZ2V9YCwgLi4uYXJncyk7CiAgICAgICAgfSwKICAgICAgICB3YXJuOiAobWVzc2FnZSwgLi4uYXJncykgPT4gewogICAgICAgICAgY29uc29sZS53YXJuKGBbV0FSTl0gJHttZXNzYWdlfWAsIC4uLmFyZ3MpOwogICAgICAgIH0sCiAgICAgICAgZXJyb3I6IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbRVJST1JdICR7bWVzc2FnZX1gLCAuLi5hcmdzKTsKICAgICAgICB9LAogICAgICAgIGRlYnVnOiAobWVzc2FnZSwgLi4uYXJncykgPT4gewogICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7CiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFtERUJVR10gJHttZXNzYWdlfWAsIC4uLmFyZ3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgIH0sCiAgICAKICAgIC8vIOmqjOivgeaLn+WQiOezu+aVsOeahOacieaViOaApwogICAgdmFsaWRhdGVGaXRDb2VmZmljaWVudHMoYSwgYiwgYykgewogICAgICAvLyDmo4Dmn6XmmK/lkKbkuLrmnInmlYjmlbDlgLwKICAgICAgaWYgKCFpc0Zpbml0ZShhKSB8fCAhaXNGaW5pdGUoYikgfHwgIWlzRmluaXRlKGMpKSB7CiAgICAgICAgdGhpcy5sb2dnZXIud2Fybign5ouf5ZCI57O75pWw5YyF5ZCr5peg5pWI5YC8IChOYU4vSW5maW5pdHkpJyk7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICAgIAogICAgICAvLyDmo4Dmn6XmmK/lkKbkuLrmsLTlubPnur/mi5/lkIgKICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtNiAmJiBNYXRoLmFicyhiKSA8IDFlLTYpIHsKICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCfmo4DmtYvliLDmsLTlubPnur/mi5/lkIggKGHiiYgwLCBi4omIMCknKTsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOajgOafpeS6jOasoemhueezu+aVsOaYr+WQpui/h+WwjwogICAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMCkgewogICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ+S6jOasoemhueezu+aVsOi/h+Wwj++8jOWPr+iDveaYr+ebtOe6v+aLn+WQiCcpOwogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICAKICAgICAgcmV0dXJuIHRydWU7CiAgICB9LAogICAgCiAgICAvLyDnu5/kuIDnmoTliY3lkI7nq6/lvILluLjngrnmo4DmtYvnrpfms5UKICAgIC8vIOS4juWQjuerr0MrK+eul+azleS/neaMgeS4gOiHtAogICAgdW5pZmllZE91dGxpZXJEZXRlY3Rpb24oZGF0YVBvaW50cykgewogICAgICBpZiAoZGF0YVBvaW50cy5sZW5ndGggPCA0KSB7CiAgICAgICAgcmV0dXJuIGRhdGFQb2ludHM7CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOW8gOWni+e7n+S4gOW8guW4uOeCueajgOa1i++8jOaVsOaNrueCueaVsOmHjzonLCBkYXRhUG9pbnRzLmxlbmd0aCk7CiAgICAgIAogICAgICAvLyDnrKzkuIDmraXvvJrln7rkuo5IRlLnu5/orqHliIbluIPnmoRJUVLmlrnms5XvvIjkuI7lkI7nq6/kuIDoh7TvvIkKICAgICAgY29uc3QgY2xlYW5EYXRhID0gdGhpcy5yZW1vdmVPdXRsaWVyc0J5SVFSKGRhdGFQb2ludHMpOwogICAgICAKICAgICAgLy8g56ys5LqM5q2l77ya5aaC5p6c5pWw5o2u54K55LuN54S26Laz5aSf77yM6L+b6KGM5LqM5qyh5ouf5ZCI5q6L5beu5YiG5p6QCiAgICAgIGlmIChjbGVhbkRhdGEubGVuZ3RoID49IDQpIHsKICAgICAgICBjb25zdCByZXNpZHVhbENsZWFuRGF0YSA9IHRoaXMucmVtb3ZlT3V0bGllcnNCeVJlc2lkdWFsKGNsZWFuRGF0YSk7CiAgICAgICAgCiAgICAgICAgLy8g6YCJ5oup5L+d55WZ5pu05aSa5pWw5o2u54K555qE5pa55rOVCiAgICAgICAgaWYgKHJlc2lkdWFsQ2xlYW5EYXRhLmxlbmd0aCA+PSAzKSB7CiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDkvb/nlKjmrovlt67liIbmnpDmlrnms5XvvIzkv53nlZknLCByZXNpZHVhbENsZWFuRGF0YS5sZW5ndGgsICfkuKrmlbDmja7ngrknKTsKICAgICAgICAgIHJldHVybiByZXNpZHVhbENsZWFuRGF0YTsKICAgICAgICB9CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOS9v+eUqElRUuaWueazle+8jOS/neeVmScsIGNsZWFuRGF0YS5sZW5ndGgsICfkuKrmlbDmja7ngrknKTsKICAgICAgcmV0dXJuIGNsZWFuRGF0YTsKICAgIH0sCiAgICAKICAgIC8vIOmqjOivgeWJjeWQjuerr+aLn+WQiOe7k+aenOS4gOiHtOaApwogICAgdmFsaWRhdGVGaXRDb25zaXN0ZW5jeShiYWNrZW5kQ29lZmZpY2llbnRzLCBmcm9udGVuZENvZWZmaWNpZW50cykgewogICAgICBjb25zdCB0b2xlcmFuY2UgPSAxZS02OyAvLyDlhYHorrjnmoTor6/lt67ojIPlm7QKICAgICAgCiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoYmFja2VuZENvZWZmaWNpZW50cy5hIC0gZnJvbnRlbmRDb2VmZmljaWVudHMuYSk7CiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoYmFja2VuZENvZWZmaWNpZW50cy5iIC0gZnJvbnRlbmRDb2VmZmljaWVudHMuYik7CiAgICAgIGNvbnN0IGNEaWZmID0gTWF0aC5hYnMoYmFja2VuZENvZWZmaWNpZW50cy5jIC0gZnJvbnRlbmRDb2VmZmljaWVudHMuYyk7CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmi5/lkIjns7vmlbDlr7nmr5Q6JywgewogICAgICAgIGJhY2tlbmQ6IGJhY2tlbmRDb2VmZmljaWVudHMsCiAgICAgICAgZnJvbnRlbmQ6IGZyb250ZW5kQ29lZmZpY2llbnRzLAogICAgICAgIGRpZmZlcmVuY2VzOiB7IGE6IGFEaWZmLCBiOiBiRGlmZiwgYzogY0RpZmYgfQogICAgICB9KTsKICAgICAgCiAgICAgIGNvbnN0IGlzQ29uc2lzdGVudCA9IGFEaWZmIDwgdG9sZXJhbmNlICYmIGJEaWZmIDwgdG9sZXJhbmNlICYmIGNEaWZmIDwgdG9sZXJhbmNlOwogICAgICAKICAgICAgaWYgKGlzQ29uc2lzdGVudCkgewogICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWJjeWQjuerr+aLn+WQiOe7k+aenOS4gOiHtCcpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWJjeWQjuerr+aLn+WQiOe7k+aenOS4jeS4gOiHtO+8jOWPr+iDveWtmOWcqOeul+azleW3ruW8gicpOwogICAgICB9CiAgICAgIAogICAgICByZXR1cm4gaXNDb25zaXN0ZW50OwogICAgfSwKICAgIAogICAgLy8g5YWz6Zet6Z2i5p2/CiAgICBjbG9zZVBhbmVsKCkgewogICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5zaG93ID0gZmFsc2U7CiAgICB9LAogICAgCiAgICAvLyDmo4Dmn6XmmK/lkKbkuLrmsLTlubPnur/mi5/lkIgKICAgIGlzSG9yaXpvbnRhbEZpdCgpIHsKICAgICAgY29uc3QgYSA9IHBhcnNlRmxvYXQodGhpcy5xdWFkcmF0aWNSZXN1bHQuYSk7CiAgICAgIGNvbnN0IGIgPSBwYXJzZUZsb2F0KHRoaXMucXVhZHJhdGljUmVzdWx0LmIpOwogICAgICByZXR1cm4gTWF0aC5hYnMoYSkgPCAxZS02ICYmIE1hdGguYWJzKGIpIDwgMWUtNjsKICAgIH0sCiAgICAKICAgIC8vIOiOt+WPluacgOS9s+S9jee9ruaYvuekuuaWh+acrAogICAgZ2V0QmVzdFBvc2l0aW9uRGlzcGxheSgpIHsKICAgICAgLy8g5qOA5p+l5piv5ZCm5Li65rC05bmz57q/5ouf5ZCI77yIYeWSjGLpg73mjqXov5Ew77yJCiAgICAgIGNvbnN0IGEgPSBwYXJzZUZsb2F0KHRoaXMucXVhZHJhdGljUmVzdWx0LmEpOwogICAgICBjb25zdCBiID0gcGFyc2VGbG9hdCh0aGlzLnF1YWRyYXRpY1Jlc3VsdC5iKTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmo4Dmn6XmnIDkvbPkvY3nva7mmL7npLo6JywgeyBhLCBiLCBiZXN0UG9zaXRpb246IHRoaXMucXVhZHJhdGljUmVzdWx0LmJlc3RQb3NpdGlvbiB9KTsKICAgICAgCiAgICAgIC8vIOWmguaenGHlkoxi6YO95o6l6L+RMO+8jOivtOaYjuaYr+awtOW5s+e6v++8jOayoeacieacgOS9s+S9jee9rgogICAgICBpZiAodGhpcy5pc0hvcml6b250YWxGaXQoKSkgewogICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOajgOa1i+WIsOawtOW5s+e6v+aLn+WQiO+8jOaYvuekuiLmnKrmib7liLDmnIDkvbPkvY3nva4iJyk7CiAgICAgICAgcmV0dXJuICLmnKrmib7liLDmnIDkvbPkvY3nva4iOwogICAgICB9CiAgICAgIAogICAgICAvLyDlkKbliJnmmL7npLrlhbfkvZPnmoTmnIDkvbPkvY3nva7mlbDlgLwKICAgICAgcmV0dXJuIHRoaXMucXVhZHJhdGljUmVzdWx0LmJlc3RQb3NpdGlvbjsKICAgIH0sCiAgICAKICAgIGluaXRDaGFydChXaWR0aCkgewogICAgICB0aGlzLmNvbnRhaW5lck1heFdpZHRoID0gV2lkdGggLSA5NTsKICAgICAgY29uc3QgY2hhcnREb20gPSB0aGlzLiRyZWZzLmxpbmVjaGFydDsKICAgICAgY2hhcnREb20uc3R5bGUud2lkdGggPSB0aGlzLmNvbnRhaW5lck1heFdpZHRoICsgJ3B4JzsKICAgICAgdGhpcy5teUNoYXJ0ID0gZWNoYXJ0cy5pbml0KGNoYXJ0RG9tKTsKICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIHN0YXJ0RHJhZyhldmVudCkgewogICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlOwogICAgICAvLyDlhbzlrrnpvKDmoIfkuovku7blkozop6bmkbjkuovku7YKICAgICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgdGhpcy5zdGFydFggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5zdGFydFggPSBldmVudC5jbGllbnRYOwogICAgICB9CiAgICB9LAogICAgZHJhZ2dpbmcoZXZlbnQpIHsKICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykgewogICAgICAgIC8vIOWFvOWuuem8oOagh+S6i+S7tuWSjOinpuaRuOS6i+S7tgogICAgICAgIGxldCBjbGllbnRYOwogICAgICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkgewogICAgICAgICAgY2xpZW50WCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY2xpZW50WCA9IGV2ZW50LmNsaWVudFg7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIHRoaXMuZGVsdGFYID0gKGNsaWVudFggLSB0aGlzLnN0YXJ0WCkgKiAxMDsKICAgICAgICB0aGlzLnN0YXJ0WCA9IGNsaWVudFg7CiAgICAgICAgdGhpcy54QXhpc19taW4gLT0gdGhpcy5kZWx0YVg7CiAgICAgICAgdGhpcy54QXhpc19tYXggLT0gdGhpcy5kZWx0YVg7CiAgICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICB9CiAgICB9LAogICAgZW5kRHJhZygpIHsKICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7CiAgICAgIHRoaXMuZGVsdGFYID0gMDsKICAgICAgLy8gdGhpcy4kYnVzLiRlbWl0KCdzZXRUYXJnZXRQb3NpdGlvbicsICh0aGlzLnhBeGlzX21pbiArIHRoaXMueEF4aXNfbWF4KSAvIDIpOwogICAgfSwKICAgIHJlbmRlckNoYXJ0KGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHsKICAgICAgLy8g6K6h566XWei9tOacgOWkp+WAvO+8jOWMheaLrOaJgOacieaVsOaNrgogICAgICBsZXQgYWxsWVZhbHVlcyA9IFtdOwogICAgICBpZiAodGhpcy5jaGFydERhdGExLmxlbmd0aCA+IDApIGFsbFlWYWx1ZXMgPSBhbGxZVmFsdWVzLmNvbmNhdCh0aGlzLmNoYXJ0RGF0YTEubWFwKGl0ZW0gPT4gaXRlbVsxXSkpOwogICAgICBpZiAodGhpcy5jaGFydERhdGEyLmxlbmd0aCA+IDApIGFsbFlWYWx1ZXMgPSBhbGxZVmFsdWVzLmNvbmNhdCh0aGlzLmNoYXJ0RGF0YTIubWFwKGl0ZW0gPT4gaXRlbVsxXSkpOwogICAgICBpZiAodGhpcy5jaGFydERhdGEzLmxlbmd0aCA+IDApIGFsbFlWYWx1ZXMgPSBhbGxZVmFsdWVzLmNvbmNhdCh0aGlzLmNoYXJ0RGF0YTMubWFwKGl0ZW0gPT4gaXRlbVsxXSkpOwogICAgICBpZiAodGhpcy5jaGFydERhdGE0Lmxlbmd0aCA+IDApIGFsbFlWYWx1ZXMgPSBhbGxZVmFsdWVzLmNvbmNhdCh0aGlzLmNoYXJ0RGF0YTQubWFwKGl0ZW0gPT4gaXRlbVsxXSkpOwogICAgICAKICAgICAgY29uc3QgeV9tYXggPSBhbGxZVmFsdWVzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5hbGxZVmFsdWVzKSAqIDEuMiA6IHRoaXMueUF4aXNfbWF4OwogICAgICBjb25zdCB5X21pbiA9IGFsbFlWYWx1ZXMubGVuZ3RoID4gMCA/IE1hdGgubWluKC4uLmFsbFlWYWx1ZXMpICogMC44IDogdGhpcy55QXhpc19taW47CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5riy5p+T5Zu+6KGoOicsIHsKICAgICAgICBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCB5X21pbiwgeV9tYXgsCiAgICAgICAgZGF0YTE6IHRoaXMuY2hhcnREYXRhMS5sZW5ndGgsCiAgICAgICAgZGF0YTI6IHRoaXMuY2hhcnREYXRhMi5sZW5ndGgsCiAgICAgICAgZGF0YTM6IHRoaXMuY2hhcnREYXRhMy5sZW5ndGgKICAgICAgfSk7CiAgICAgIAogICAgICBjb25zdCBvcHRpb24gPSB7CiAgICAgICAgZ3JpZDogewogICAgICAgICAgbGVmdDogJzAlJywKICAgICAgICAgIHJpZ2h0OiAnMiUnLAogICAgICAgICAgYm90dG9tOiAnMCUnLAogICAgICAgICAgdG9wOiAnMTAlJywKICAgICAgICAgIGNvbnRhaW5MYWJlbDogdHJ1ZQogICAgICAgIH0sCiAgICAgICAgeEF4aXM6IHsKICAgICAgICAgIG1pbjogbG93ZXJCb3VuZCwKICAgICAgICAgIG1heDogdXBwZXJCb3VuZCwKICAgICAgICAgIGF4aXNMaW5lOiB7CiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyMDAsIDIwMCwgMjAwLCAwLjUpJyAgLy8geOi9tOe6v+minOiJsgogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgYXhpc0xhYmVsOiB7CiAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLAogICAgICAgICAgICBmb250U2l6ZTogNQogICAgICAgICAgfSwKICAgICAgICAgIHNwbGl0TGluZTogewogICAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTI4LCAxMjgsIDEyOCwgMC41KScsIAogICAgICAgICAgICAgIHdpZHRoOiAxLAogICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgeUF4aXM6IHsKICAgICAgICAgIG1pbjogeV9taW4sCiAgICAgICAgICBtYXg6IHlfbWF4LAogICAgICAgICAgYXhpc0xpbmU6IHsKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSknICAvLyB56L2057q/6aKc6ImyCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICBheGlzTGFiZWw6IHsKICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsCiAgICAgICAgICAgIGZvbnRTaXplOiA1CiAgICAgICAgICB9LAogICAgICAgICAgc3BsaXROdW1iZXI6IDMsCiAgICAgICAgICBzcGxpdExpbmU6IHsKICAgICAgICAgICAgc2hvdzogdHJ1ZSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNSknLAogICAgICAgICAgICAgIHdpZHRoOiAxLAogICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2VyaWVzOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgIG5hbWU6ICdIRlInLAogICAgICAgICAgICB0eXBlOiAnc2NhdHRlcicsCiAgICAgICAgICAgIGRhdGE6IHRoaXMuY2hhcnREYXRhMSwKICAgICAgICAgICAgaXRlbVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnd2hpdGUnLAogICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN5bWJvbFNpemU6IDgKICAgICAgICAgIH0sCiAgICAgICAgICB7CiAgICAgICAgICAgIG5hbWU6ICdRdWFkcmF0aWNDdXJ2ZScsCiAgICAgICAgICAgIHR5cGU6ICdsaW5lJywKICAgICAgICAgICAgZGF0YTogdGhpcy5jaGFydERhdGEyLAogICAgICAgICAgICBpdGVtU3R5bGU6IHsKICAgICAgICAgICAgICBjb2xvcjogJ3llbGxvdycKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgd2lkdGg6IDMsCiAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJwogICAgICAgICAgICB9LAogICAgICAgICAgICBzeW1ib2xTaXplOiAwLAogICAgICAgICAgICBzbW9vdGg6IGZhbHNlCiAgICAgICAgICB9LAogICAgICAgICAgewogICAgICAgICAgICBuYW1lOiAnbWluUG9pbnQnLAogICAgICAgICAgICB0eXBlOiAnc2NhdHRlcicsCiAgICAgICAgICAgIGRhdGE6IHRoaXMuY2hhcnREYXRhMywKICAgICAgICAgICAgaXRlbVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDc1LCAxNTUsIDI1MCwgMC43KScKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3ltYm9sU2l6ZTogNAogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgbmFtZTogJ3hNaW5MaW5lJywKICAgICAgICAgICAgdHlwZTogJ2xpbmUnLAogICAgICAgICAgICBkYXRhOiBbCiAgICAgICAgICAgICAgW3RoaXMueF9taW4sIHRoaXMueUF4aXNfbWluXSwKICAgICAgICAgICAgICBbdGhpcy54X21pbiwgeV9tYXhdCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmVkJywKICAgICAgICAgICAgICB3aWR0aDogMQogICAgICAgICAgICB9LAogICAgICAgICAgICBzeW1ib2w6ICdub25lJwogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgbmFtZTogJ3hNYXhMaW5lJywKICAgICAgICAgICAgdHlwZTogJ2xpbmUnLAogICAgICAgICAgICBkYXRhOiBbCiAgICAgICAgICAgICAgW3RoaXMueF9tYXgsIHRoaXMueUF4aXNfbWluXSwKICAgICAgICAgICAgICBbdGhpcy54X21heCwgeV9tYXhdCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmVkJywKICAgICAgICAgICAgICB3aWR0aDogMQogICAgICAgICAgICB9LAogICAgICAgICAgICBzeW1ib2w6ICdub25lJwogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgbmFtZTogJ2N1cnJlbnRQb3NpdGlvbicsCiAgICAgICAgICAgIHR5cGU6ICdsaW5lJywKICAgICAgICAgICAgZGF0YTogWwogICAgICAgICAgICAgIFt0aGlzLmN1cnJlbnRYLCB0aGlzLnlBeGlzX21pbl0sCiAgICAgICAgICAgICAgW3RoaXMuY3VycmVudFgsIHlfbWF4XQogICAgICAgICAgICBdLAogICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICBjb2xvcjogJ2dyZWVuJywKICAgICAgICAgICAgICB3aWR0aDogMQogICAgICAgICAgICB9LAogICAgICAgICAgICBzeW1ib2w6ICdub25lJwogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgbmFtZTogJ091dGxpZXJzJywKICAgICAgICAgICAgdHlwZTogJ3NjYXR0ZXInLAogICAgICAgICAgICBkYXRhOiB0aGlzLmNoYXJ0RGF0YTQsCiAgICAgICAgICAgIGl0ZW1TdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDAsIDI1NSwgMC44KScsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICd3aGl0ZScsCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3ltYm9sU2l6ZTogMTIsCiAgICAgICAgICAgIHN5bWJvbDogJ2RpYW1vbmQnCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9OwogICAgICB0aGlzLm15Q2hhcnQuc2V0T3B0aW9uKG9wdGlvbik7CiAgICB9LAogICAgYWRkRGF0YV9Qb2ludCh4LHkpIHsKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5re75Yqg5pWw5o2u54K5OicsIHsgeCwgeSB9KTsKICAgICAgCiAgICAgIC8vIOi/h+a7pEhGUuWkp+S6juetieS6jjEwMOeahOaVsOaNrueCuQogICAgICBpZiAoeSA+PSAxMDApIHsKICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDaGFydC1Gb2N1cy52dWUgfCBIRlLlgLzov4flpKcoPj0xMDAp77yM5b+955Wl5q2k5pWw5o2u54K5OicsIHsgeCwgeSB9KTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgCiAgICAgIGNvbnN0IG5ld0RhdGFQb2ludCA9IFt4LCB5XTsKICAgICAgY29uc3QgZXhpc3RpbmdQb2ludEluZGV4ID0gdGhpcy5jaGFydERhdGExLmZpbmRJbmRleChwb2ludCA9PiBwb2ludFswXSA9PT0gbmV3RGF0YVBvaW50WzBdKTsKICAgICAgaWYgKGV4aXN0aW5nUG9pbnRJbmRleCAhPT0gLTEpIHsKICAgICAgICAvLyBJZiB0aGUgeCB2YWx1ZSBhbHJlYWR5IGV4aXN0cywgdXBkYXRlIHRoZSB5IHZhbHVlCiAgICAgICAgaWYgKG5ld0RhdGFQb2ludFsxXSA9PSAwIHx8IG5ld0RhdGFQb2ludFsxXSA9PSB0aGlzLmNoYXJ0RGF0YTFbZXhpc3RpbmdQb2ludEluZGV4XVsxXSkgewogICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOi3s+i/h+mHjeWkjeaVsOaNrueCuTonLCBuZXdEYXRhUG9pbnQpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB0aGlzLmNoYXJ0RGF0YTFbZXhpc3RpbmdQb2ludEluZGV4XSA9IG5ld0RhdGFQb2ludDsKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmm7TmlrDnjrDmnInmlbDmja7ngrk6JywgbmV3RGF0YVBvaW50KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBJZiB0aGUgeCB2YWx1ZSBkb2VzIG5vdCBleGlzdCwgYWRkIHRoZSBuZXcgZGF0YSBwb2ludAogICAgICAgIHRoaXMuY2hhcnREYXRhMS5wdXNoKG5ld0RhdGFQb2ludCk7CiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5re75Yqg5paw5pWw5o2u54K5OicsIG5ld0RhdGFQb2ludCk7CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDlvZPliY3mlbDmja7ngrnmgLvmlbA6JywgdGhpcy5jaGFydERhdGExLmxlbmd0aCk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmiYDmnInmlbDmja7ngrk6JywgdGhpcy5jaGFydERhdGExKTsKICAgICAgCiAgICAgIC8vIOabtOaWsOW8guW4uOeCueaVsOaNrgogICAgICB0aGlzLnVwZGF0ZU91dGxpZXJEYXRhKCk7CiAgICAgIAogICAgICAvLyDlpoLmnpzlt7Lnu4/mnInmi5/lkIjnu5PmnpzvvIzph43mlrDnlJ/miJDmm7Lnur8KICAgICAgaWYgKHRoaXMucXVhZHJhdGljUmVzdWx0LnNob3cpIHsKICAgICAgICBjb25zdCBhID0gcGFyc2VGbG9hdCh0aGlzLnF1YWRyYXRpY1Jlc3VsdC5hKTsKICAgICAgICBjb25zdCBiID0gcGFyc2VGbG9hdCh0aGlzLnF1YWRyYXRpY1Jlc3VsdC5iKTsKICAgICAgICBjb25zdCBjID0gcGFyc2VGbG9hdCh0aGlzLnF1YWRyYXRpY1Jlc3VsdC5jKTsKICAgICAgICBjb25zdCBiZXN0UG9zaXRpb24gPSBwYXJzZUZsb2F0KHRoaXMucXVhZHJhdGljUmVzdWx0LmJlc3RQb3NpdGlvbik7CiAgICAgICAgCiAgICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTApIHsKICAgICAgICAgIC8vIOe6v+aAp+aLn+WQiAogICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5pWw5o2u54K55pu05paw77yM6YeN5paw55Sf5oiQ57q/5oCn5ouf5ZCI5puy57q/Jyk7CiAgICAgICAgICB0aGlzLmdlbmVyYXRlTGluZWFyQ3VydmUoYiwgYywgYmVzdFBvc2l0aW9uKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8g5LqM5qyh5ouf5ZCICiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmlbDmja7ngrnmm7TmlrDvvIzph43mlrDnlJ/miJDkuozmrKHmi5/lkIjmm7Lnur8nKTsKICAgICAgICAgIHRoaXMuZ2VuZXJhdGVRdWFkcmF0aWNDdXJ2ZShhLCBiLCBjLCBiZXN0UG9zaXRpb24pOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgIH0KICAgIH0sCiAgICAvLyDnu5jliLbmipjnur8KICAgIGFkZExpbmVEYXRhX1BvaW50KGRhdGFMaXN0KSB7CiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IGRhdGFMaXN0OwogICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgYWRkTWluUG9pbnREYXRhX1BvaW50KHgseSkgewogICAgICBjb25zdCBuZXdEYXRhUG9pbnQgPSBbeCwgeV07CiAgICAgIHRoaXMuY2hhcnREYXRhMy5wdXNoKG5ld0RhdGFQb2ludCk7CiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICAvLyDmm7TmlLnmmL7npLrnmoR46L206IyD5Zu0CiAgICBjaGFuZ2VSYW5nZV94KGN1cnJlbnQsIHRhcmdldCkgewogICAgICBjb25zdCBuZXdDdXJyZW50WCA9IE51bWJlcihjdXJyZW50KTsKICAgICAgCiAgICAgIC8vIOWPquacieW9k+S9jee9ruecn+ato+WPkeeUn+WPmOWMluaXtuaJjeabtOaWsAogICAgICBpZiAoTWF0aC5hYnMobmV3Q3VycmVudFggLSB0aGlzLmN1cnJlbnRYKSA+IDEpIHsKICAgICAgICB0aGlzLmN1cnJlbnRYID0gbmV3Q3VycmVudFg7CiAgICAgICAgCiAgICAgICAgLy8g5qOA5p+l5piv5ZCm6ZyA6KaB6LCD5pW0WOi9tOiMg+WbtAogICAgICAgIGNvbnN0IG5ld1hBeGlzTWluID0gbmV3Q3VycmVudFggLSAzMDAwOwogICAgICAgIGNvbnN0IG5ld1hBeGlzTWF4ID0gbmV3Q3VycmVudFggKyAzMDAwOwogICAgICAgIAogICAgICAgIC8vIOWPquacieW9k+aWsOS9jee9rui2heWHuuW9k+WJjeaYvuekuuiMg+WbtOaXtuaJjeiwg+aVtFjovbTojIPlm7QKICAgICAgICBpZiAobmV3Q3VycmVudFggPCB0aGlzLnhBeGlzX21pbiArIDEwMDAgfHwgbmV3Q3VycmVudFggPiB0aGlzLnhBeGlzX21heCAtIDEwMDApIHsKICAgICAgICAgIHRoaXMueEF4aXNfbWluID0gbmV3WEF4aXNNaW47CiAgICAgICAgICB0aGlzLnhBeGlzX21heCA9IG5ld1hBeGlzTWF4OwogICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoIkNoYXJ0LUZvY3VzLnZ1ZSB8IOiwg+aVtFjovbTojIPlm7Q6IiwgbmV3Q3VycmVudFgsIHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIOWPquabtOaWsOe7v+iJsue6v+S9jee9ru+8jOS4jemHjeaWsOa4suafk+aVtOS4quWbvuihqAogICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50UG9zaXRpb25MaW5lKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgCiAgICAvLyDlj6rmm7TmlrDlvZPliY3nu7/oibLkvY3nva7nur/vvIzkuI3ph43mlrDmuLLmn5PmlbTkuKrlm77ooagKICAgIHVwZGF0ZUN1cnJlbnRQb3NpdGlvbkxpbmUoKSB7CiAgICAgIGlmICh0aGlzLm15Q2hhcnQpIHsKICAgICAgICAvLyDorqHnrpdZ6L205pyA5aSn5YC8CiAgICAgICAgbGV0IGFsbFlWYWx1ZXMgPSBbXTsKICAgICAgICBpZiAodGhpcy5jaGFydERhdGExLmxlbmd0aCA+IDApIGFsbFlWYWx1ZXMgPSBhbGxZVmFsdWVzLmNvbmNhdCh0aGlzLmNoYXJ0RGF0YTEubWFwKGl0ZW0gPT4gaXRlbVsxXSkpOwogICAgICAgIGlmICh0aGlzLmNoYXJ0RGF0YTIubGVuZ3RoID4gMCkgYWxsWVZhbHVlcyA9IGFsbFlWYWx1ZXMuY29uY2F0KHRoaXMuY2hhcnREYXRhMi5tYXAoaXRlbSA9PiBpdGVtWzFdKSk7CiAgICAgICAgaWYgKHRoaXMuY2hhcnREYXRhMy5sZW5ndGggPiAwKSBhbGxZVmFsdWVzID0gYWxsWVZhbHVlcy5jb25jYXQodGhpcy5jaGFydERhdGEzLm1hcChpdGVtID0+IGl0ZW1bMV0pKTsKICAgICAgICAKICAgICAgICBjb25zdCB5X21heCA9IGFsbFlWYWx1ZXMubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLmFsbFlWYWx1ZXMpICogMS4yIDogdGhpcy55QXhpc19tYXg7CiAgICAgICAgY29uc3QgeV9taW4gPSBhbGxZVmFsdWVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi5hbGxZVmFsdWVzKSAqIDAuOCA6IHRoaXMueUF4aXNfbWluOwogICAgICAgIAogICAgICAgIC8vIOWPquabtOaWsGN1cnJlbnRQb3NpdGlvbuezu+WIlwogICAgICAgIHRoaXMubXlDaGFydC5zZXRPcHRpb24oewogICAgICAgICAgc2VyaWVzOiBbewogICAgICAgICAgICBuYW1lOiAnY3VycmVudFBvc2l0aW9uJywKICAgICAgICAgICAgdHlwZTogJ2xpbmUnLAogICAgICAgICAgICBkYXRhOiBbCiAgICAgICAgICAgICAgW3RoaXMuY3VycmVudFgsIHlfbWluXSwKICAgICAgICAgICAgICBbdGhpcy5jdXJyZW50WCwgeV9tYXhdCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAnZ3JlZW4nLAogICAgICAgICAgICAgIHdpZHRoOiAxCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN5bWJvbDogJ25vbmUnCiAgICAgICAgICB9XQogICAgICAgIH0sIGZhbHNlKTsgLy8gZmFsc2XooajnpLrkuI3ph43mlrDmuLLmn5PvvIzlj6rmm7TmlrDmlbDmja4KICAgICAgfQogICAgfSwKCiAgICAvLyDmuIXpmaTmlbDmja4KICAgIGNsZWFyQ2hhcnREYXRhMSgpIHsKICAgICAgdGhpcy5jaGFydERhdGExID0gW107CiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICBjbGVhckNoYXJ0RGF0YTIoKSB7CiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IFtdOwogICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgQ2xlYXJBbGxEYXRhKCkgewogICAgICAvLyDmuIXnqbrmiYDmnInmlbDmja7vvIzljIXmi6znsr7osIPmlbDmja7ngrkKICAgICAgdGhpcy5jaGFydERhdGExID0gW107CiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTMgPSBbXTsKICAgICAgdGhpcy5jaGFydERhdGE0ID0gW107CiAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LnNob3cgPSBmYWxzZTsKICAgICAgdGhpcy55QXhpc19tYXggPSAzMDsKICAgICAgdGhpcy5IRlJNYXggPSAxNTsKICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIAogICAgLy8g5riF56m657K+6LCD5pWw5o2u77yI5Zyo57K+6LCD5byA5aeL5pe26LCD55So77yJCiAgICBDbGVhckZpbmVEYXRhKCkgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmuIXnqbrnsr7osIPmlbDmja4nKTsKICAgICAgdGhpcy5jaGFydERhdGExID0gW107CiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTMgPSBbXTsKICAgICAgdGhpcy5jaGFydERhdGE0ID0gW107CiAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LnNob3cgPSBmYWxzZTsKICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIAogICAgLy8g5pu05paw5byC5bi454K55pWw5o2uCiAgICB1cGRhdGVPdXRsaWVyRGF0YSgpIHsKICAgICAgaWYgKHRoaXMuY2hhcnREYXRhMS5sZW5ndGggPj0gNCkgewogICAgICAgIHRoaXMuY2hhcnREYXRhNCA9IHRoaXMub3V0bGllckRhdGFQb2ludHM7CiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOabtOaWsOW8guW4uOeCueaVsOaNru+8jOW8guW4uOeCueaVsOmHjzonLCB0aGlzLmNoYXJ0RGF0YTQubGVuZ3RoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmNoYXJ0RGF0YTQgPSBbXTsKICAgICAgfQogICAgfSwKICAgIC8vIOWIh+aNouaYvuekuuiMg+WbtAogICAgUmFuZ2VTd2l0Y2goKSB7CiAgICAgIGlmICh0aGlzLnJhbmdlID09PSA0KSB7CiAgICAgICAgdGhpcy5yYW5nZSA9IDI7CiAgICAgICAgdGhpcy55QXhpc19taW4gPSAtMjsKICAgICAgICB0aGlzLnlBeGlzX21heCA9IDI7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5yYW5nZSA9PT0gMikgewogICAgICAgIHRoaXMucmFuZ2UgPSAxOwogICAgICAgIHRoaXMueUF4aXNfbWluID0gLTE7CiAgICAgICAgdGhpcy55QXhpc19tYXggPSAxOwogICAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2UgPT09IDEpIHsKICAgICAgICB0aGlzLnJhbmdlID0gNDsKICAgICAgICB0aGlzLnlBeGlzX21pbiA9IC00OwogICAgICAgIHRoaXMueUF4aXNfbWF4ID0gNDsKICAgICAgfQogICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgLy8g5pu05pawSEZSCiAgICAvLyBVcGRhdGVIRlIoSEZSKSB7CiAgICAvLyAgIGNvbnN0IG5ld0RhdGFQb2ludCA9IFt0aGlzLmN1cnJlbnRYLCBIRlJdOwogICAgLy8gICB0aGlzLmFkZERhdGFfUG9pbnQobmV3RGF0YVBvaW50KTsKICAgIC8vICAgLy8gY29uc29sZS5sb2coIlFIWUNDRCB8IFVwZGF0ZUhGUjoiLCBuZXdEYXRhUG9pbnQpOwogICAgLy8gICAvLyB0aGlzLiRidXMuJGVtaXQoJ1NlbmRDb25zb2xlTG9nTXNnJywgJ1VwZGF0ZUhGUjonICsgbmV3RGF0YVBvaW50LCAnaW5mbycpOwogICAgLy8gICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAvLyB9LAogICAgLy8g5ouf5ZCI5LqM5qyh5puy57q/CiAgICBmaXRRdWFkcmF0aWNDdXJ2ZShkYXRhU3RyaW5nKSB7CiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaOpeaUtuS6jOasoeabsue6v+aVsOaNrjonLCBkYXRhU3RyaW5nKTsKICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaOpeaUtuS6jOasoeabsue6v+aVsOaNrjonLCBkYXRhU3RyaW5nKTsKICAgICAgCiAgICAgIGNvbnN0IHBhcnRzID0gZGF0YVN0cmluZy5zcGxpdCgnOicpOwogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDop6PmnpDlkI7nmoTmlbDmja7pg6jliIY6JywgcGFydHMpOwogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwg6Kej5p6Q5ZCO55qE5pWw5o2u6YOo5YiGOicsIHBhcnRzKTsKICAgICAgCiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gNikgewogICAgICAgIGNvbnN0IGEgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICBjb25zdCBiID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7CiAgICAgICAgY29uc3QgYyA9IHBhcnNlRmxvYXQocGFydHNbM10pOwogICAgICAgIGNvbnN0IGJlc3RQb3NpdGlvbiA9IHBhcnNlRmxvYXQocGFydHNbNF0pOwogICAgICAgIGNvbnN0IG1pbkhGUiA9IHBhcnNlRmxvYXQocGFydHNbNV0pOwogICAgICAgIAogICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOino+aekOeahOaVsOWAvDonLCB7IGEsIGIsIGMsIGJlc3RQb3NpdGlvbiwgbWluSEZSIH0pOwogICAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDop6PmnpDnmoTmlbDlgLw6JywgeyBhLCBiLCBjLCBiZXN0UG9zaXRpb24sIG1pbkhGUiB9KTsKICAgICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwg5Y6f5aeL5a2X56ym5Liy6YOo5YiGOicsIHBhcnRzKTsKICAgICAgICAKICAgICAgICAvLyDpqozor4Hmi5/lkIjns7vmlbDnmoTmnInmlYjmgKcKICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVGaXRDb2VmZmljaWVudHMoYSwgYiwgYykpIHsKICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaLn+WQiOezu+aVsOaXoOaViO+8jOWPr+iDveaYr+awtOW5s+e6v+aLn+WQiCcpOwogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDkuI3lho3ov5vooYzliY3nq6/mi5/lkIjorqHnrpfvvIzlrozlhajkvp3otZblkI7nq6/mj5DkvpvnmoTlj4LmlbAKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDkvb/nlKjlkI7nq6/mj5DkvpvnmoTmi5/lkIjlj4LmlbDvvIzkuI3lho3ov5vooYzliY3nq6/mi5/lkIjorqHnrpcnKTsKICAgICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwg5L2/55So5ZCO56uv5o+Q5L6b55qE5ouf5ZCI5Y+C5pWw77yM5LiN5YaN6L+b6KGM5YmN56uv5ouf5ZCI6K6h566XJyk7CiAgICAgICAgCiAgICAgICAgLy8g6aqM6K+B5Y+C5pWw5piv5ZCm5ZCI55CGCiAgICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTApIHsKICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOitpuWRiu+8mmHns7vmlbDmjqXov5Ew77yM6L+Z5piv57q/5oCn5ouf5ZCI6ICM5LiN5piv5LqM5qyh5ouf5ZCIJyk7CiAgICAgICAgICBjb25zb2xlLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOitpuWRiu+8mmHns7vmlbDmjqXov5Ew77yM6L+Z5piv57q/5oCn5ouf5ZCI6ICM5LiN5piv5LqM5qyh5ouf5ZCIJyk7CiAgICAgICAgICAKICAgICAgICAgIC8vIOWvueS6jue6v+aAp+aLn+WQiO+8jOaIkeS7rOmcgOimgeeJueauiuWkhOeQhgogICAgICAgICAgdGhpcy5nZW5lcmF0ZUxpbmVhckN1cnZlKGIsIGMsIGJlc3RQb3NpdGlvbik7CiAgICAgICAgICAKICAgICAgICAgIC8vIOabtOaWsOaWh+acrOahhuaYvuekuu+8iOe6v+aAp+aLn+WQiO+8iQogICAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuYSA9ICIwLjAwMDAwMCI7IC8vIOaYvuekuuS4ujAKICAgICAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LmIgPSBiLnRvRml4ZWQoNik7CiAgICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5jID0gYy50b0ZpeGVkKDYpOwogICAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuYmVzdFBvc2l0aW9uID0gIue6v+aAp+aLn+WQiCI7CiAgICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5taW5IRlIgPSBtaW5IRlIudG9GaXhlZCgzKTsKICAgICAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LnNob3cgPSB0cnVlOwogICAgICAgICAgCiAgICAgICAgICByZXR1cm47IC8vIOebtOaOpei/lOWbnu+8jOS4jeaJp+ihjOS6jOasoeabsue6v+eUn+aIkAogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDmm7TmlrDmlofmnKzmoYbmmL7npLoKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5hID0gYS50b0ZpeGVkKDYpOwogICAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LmIgPSBiLnRvRml4ZWQoNik7CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuYyA9IGMudG9GaXhlZCg2KTsKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5iZXN0UG9zaXRpb24gPSBiZXN0UG9zaXRpb24udG9GaXhlZCgyKTsKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5taW5IRlIgPSBtaW5IRlIudG9GaXhlZCgzKTsKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5zaG93ID0gdHJ1ZTsKICAgICAgICAKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmlofmnKzmoYbmlbDmja7lt7Lmm7TmlrA6JywgdGhpcy5xdWFkcmF0aWNSZXN1bHQpOwogICAgICAgIAogICAgICAgIC8vIOeUn+aIkOS6jOasoeabsue6v+aVsOaNrueCuQogICAgICAgIHRoaXMuZ2VuZXJhdGVRdWFkcmF0aWNDdXJ2ZShhLCBiLCBjLCBiZXN0UG9zaXRpb24pOwogICAgICAgIAogICAgICAgIC8vIOabtOaWsOW8guW4uOeCueaVsOaNrgogICAgICAgIHRoaXMudXBkYXRlT3V0bGllckRhdGEoKTsKICAgICAgICAKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDkuozmrKHmi5/lkIjkv6Hmga/lt7Lmm7TmlrA6JywgdGhpcy5xdWFkcmF0aWNSZXN1bHQpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdDaGFydC1Gb2N1cy52dWUgfCDmlbDmja7moLzlvI/plJnor6/vvIzpg6jliIbmlbDph4/kuI3otrM6JywgcGFydHMubGVuZ3RoKTsKICAgICAgfQogICAgfSwKICAgIAogICAgLy8g55Sf5oiQ5LqM5qyh5puy57q/5pWw5o2u54K5CiAgICBnZW5lcmF0ZVF1YWRyYXRpY0N1cnZlKGEsIGIsIGMsIGJlc3RQb3NpdGlvbikgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDlvIDlp4vnlJ/miJDkuozmrKHmm7Lnur/mlbDmja7ngrk6JywgeyBhLCBiLCBjLCBiZXN0UG9zaXRpb24gfSk7CiAgICAgIAogICAgICAvLyDkv67mraPvvJrlkI7nq6/lj5HpgIHnmoRh44CBYuOAgWPns7vmlbDmmK/ln7rkuo7nm7jlr7nlnZDmoIfnmoQKICAgICAgLy8g6ZyA6KaB5om+5Yiw5pWw5o2u54K555qE5pyA5bCP5L2N572u5L2c5Li65YGP56e76YeP77yM56Gu5L+d5LiO5ZCO56uv566X5rOV5LiA6Ie0CiAgICAgIAogICAgICAvLyDku47mlbDmja7ngrnkuK3mib7liLDmnIDlsI/kvY3nva7kvZzkuLrlgY/np7vph4/vvIjkv67mraPvvJrkuI3kvb/nlKhiZXN0UG9zaXRpb27kvZzkuLptaW5Qb3PvvIkKICAgICAgbGV0IG1pblBvcyA9IDA7CiAgICAgIGlmICh0aGlzLmNoYXJ0RGF0YTEubGVuZ3RoID4gMCkgewogICAgICAgIG1pblBvcyA9IE1hdGgubWluKC4uLnRoaXMuY2hhcnREYXRhMS5tYXAocG9pbnQgPT4gcG9pbnRbMF0pKTsKICAgICAgfQogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWdkOagh+ezu+e7n+S/oeaBrzonKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5pWw5o2u54K55pyA5bCP5L2N572uIChtaW5Qb3MpOicsIG1pblBvcyk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOWQjuerr+WPkemAgeeahOacgOS9s+S9jee9riAoYmVzdFBvc2l0aW9uKTonLCBiZXN0UG9zaXRpb24pOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDmi5/lkIjns7vmlbAgYTonLCBhLCAnYjonLCBiLCAnYzonLCBjKTsKICAgICAgCiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDlnZDmoIfns7vnu5/kv6Hmga86Jyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCAtIOaVsOaNrueCueacgOWwj+S9jee9riAobWluUG9zKTonLCBtaW5Qb3MpOwogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDlkI7nq6/lj5HpgIHnmoTmnIDkvbPkvY3nva4gKGJlc3RQb3NpdGlvbik6JywgYmVzdFBvc2l0aW9uKTsKICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5ouf5ZCI57O75pWwIGE6JywgYSwgJ2I6JywgYiwgJ2M6JywgYyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCAtIOW9k+WJjeaVsOaNrueCuTonLCB0aGlzLmNoYXJ0RGF0YTEpOwogICAgICAKICAgICAgLy8g6aqM6K+B5pyA5L2z5L2N572u55qE6K6h566X5piv5ZCm5q2j56GuCiAgICAgIGNvbnN0IGV4cGVjdGVkQmVzdFJlbGF0aXZlUG9zID0gLWIgLyAoMiAqIGEpOwogICAgICBjb25zdCBleHBlY3RlZEJlc3RBYnNvbHV0ZVBvcyA9IGV4cGVjdGVkQmVzdFJlbGF0aXZlUG9zICsgbWluUG9zOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDorqHnrpfnmoTmnIDkvbPnm7jlr7nkvY3nva46JywgZXhwZWN0ZWRCZXN0UmVsYXRpdmVQb3MpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDorqHnrpfnmoTmnIDkvbPnu53lr7nkvY3nva46JywgZXhwZWN0ZWRCZXN0QWJzb2x1dGVQb3MpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDkvY3nva7lt67lvII6JywgTWF0aC5hYnMoZXhwZWN0ZWRCZXN0QWJzb2x1dGVQb3MgLSBiZXN0UG9zaXRpb24pKTsKICAgICAgCiAgICAgIGNvbnN0IGN1cnZlRGF0YSA9IFtdOwogICAgICAKICAgICAgLy8g5pm66IO956Gu5a6a5puy57q/55Sf5oiQ6IyD5Zu0CiAgICAgIGxldCBzdGFydFgsIGVuZFgsIHN0ZXBTaXplOwogICAgICAKICAgICAgaWYgKHRoaXMuY2hhcnREYXRhMS5sZW5ndGggPiAwKSB7CiAgICAgICAgLy8g5Z+65LqO5pWw5o2u54K56IyD5Zu055Sf5oiQ5puy57q/CiAgICAgICAgY29uc3QgZGF0YU1pblggPSBNYXRoLm1pbiguLi50aGlzLmNoYXJ0RGF0YTEubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgICAgY29uc3QgZGF0YU1heFggPSBNYXRoLm1heCguLi50aGlzLmNoYXJ0RGF0YTEubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgICAgY29uc3QgZGF0YVJhbmdlID0gZGF0YU1heFggLSBkYXRhTWluWDsKICAgICAgICAKICAgICAgICAvLyDmianlsZXojIPlm7Tku6Xnoa7kv53mm7Lnur/opobnm5blrozmlbQKICAgICAgICBjb25zdCBleHRlbnNpb24gPSBNYXRoLm1heChkYXRhUmFuZ2UgKiAwLjIsIDEwMDApOyAvLyDmianlsZUyMCXmiJboh7PlsJExMDAwCiAgICAgICAgc3RhcnRYID0gZGF0YU1pblggLSBleHRlbnNpb247CiAgICAgICAgZW5kWCA9IGRhdGFNYXhYICsgZXh0ZW5zaW9uOwogICAgICAgIAogICAgICAgIC8vIOagueaNruaVsOaNruiMg+WbtOiwg+aVtOatpemVvwogICAgICAgIHN0ZXBTaXplID0gTWF0aC5tYXgoTWF0aC5mbG9vcihkYXRhUmFuZ2UgLyAxMDApLCAyMCk7IC8vIOiHs+WwkTEwMOS4queCue+8jOatpemVv+iHs+WwkTIwCiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8g5aaC5p6c5rKh5pyJ5pWw5o2u54K577yM5L2/55So6buY6K6k6IyD5Zu0CiAgICAgICAgY29uc3QgcmFuZ2UgPSA1MDAwOwogICAgICAgIHN0YXJ0WCA9IGJlc3RQb3NpdGlvbiAtIHJhbmdlOwogICAgICAgIGVuZFggPSBiZXN0UG9zaXRpb24gKyByYW5nZTsKICAgICAgICBzdGVwU2l6ZSA9IDUwOwogICAgICB9CiAgICAgIAogICAgICAvLyDnoa7kv53mm7Lnur/opobnm5blvZPliY1Y6L206IyD5Zu0CiAgICAgIHN0YXJ0WCA9IE1hdGgubWluKHN0YXJ0WCwgdGhpcy54QXhpc19taW4pOwogICAgICBlbmRYID0gTWF0aC5tYXgoZW5kWCwgdGhpcy54QXhpc19tYXgpOwogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOabsue6v+eUn+aIkOiMg+WbtDonLCBzdGFydFgsICfliLAnLCBlbmRYLCAn5q2l6ZW/OicsIHN0ZXBTaXplKTsKICAgICAgCiAgICAgIC8vIOeUn+aIkOabsue6v+aVsOaNrueCuQogICAgICBmb3IgKGxldCB4ID0gc3RhcnRYOyB4IDw9IGVuZFg7IHggKz0gc3RlcFNpemUpIHsKICAgICAgICAvLyDlsIbnu53lr7nlnZDmoIfovazmjaLkuLrnm7jlr7nlnZDmoIfov5vooYzorqHnrpfvvIjkuI7lkI7nq6/nrpfms5XkuIDoh7TvvIkKICAgICAgICBjb25zdCByZWxhdGl2ZVggPSB4IC0gbWluUG9zOwogICAgICAgIGNvbnN0IHkgPSBhICogcmVsYXRpdmVYICogcmVsYXRpdmVYICsgYiAqIHJlbGF0aXZlWCArIGM7CiAgICAgICAgCiAgICAgICAgLy8g6aqM6K+B6K6h566X57uT5p6cCiAgICAgICAgaWYgKGlzRmluaXRlKHkpICYmIHkgPj0gMCkgewogICAgICAgICAgY3VydmVEYXRhLnB1c2goW3gsIHldKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2hhcnQtRm9jdXMudnVlIHwg6K2m5ZGK77ya6K6h566X5b6X5Yiw5peg5pWI55qEWeWAvDonLCB5LCAn5Zyo5L2N572uOicsIHgsICfnm7jlr7nkvY3nva46JywgcmVsYXRpdmVYKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOa3u+WKoOWFs+mUrueCue+8muehruS/neaVsOaNrueCueS9jee9ruWcqOabsue6v+S4iuacieeyvuehrueahOeCuQogICAgICBpZiAodGhpcy5jaGFydERhdGExLmxlbmd0aCA+IDApIHsKICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRoaXMuY2hhcnREYXRhMSkgewogICAgICAgICAgY29uc3QgeCA9IHBvaW50WzBdOwogICAgICAgICAgY29uc3QgcmVsYXRpdmVYID0geCAtIG1pblBvczsKICAgICAgICAgIGNvbnN0IHkgPSBhICogcmVsYXRpdmVYICogcmVsYXRpdmVYICsgYiAqIHJlbGF0aXZlWCArIGM7CiAgICAgICAgICAKICAgICAgICAgIGlmIChpc0Zpbml0ZSh5KSAmJiB5ID49IDApIHsKICAgICAgICAgICAgLy8g5qOA5p+l5piv5ZCm5bey57uP5a2Y5Zyo6L+Z5Liq54K577yI6YG/5YWN6YeN5aSN77yJCiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IGN1cnZlRGF0YS5zb21lKGN1cnZlUG9pbnQgPT4gTWF0aC5hYnMoY3VydmVQb2ludFswXSAtIHgpIDwgc3RlcFNpemUgLyAyKTsKICAgICAgICAgICAgaWYgKCFleGlzdHMpIHsKICAgICAgICAgICAgICBjdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOa3u+WKoOacgOS9s+S9jee9rueCueWPiuWFtumZhOi/keeahOmrmOeyvuW6pueCuQogICAgICAgIGNvbnN0IGJlc3RSZWxhdGl2ZVggPSBiZXN0UG9zaXRpb24gLSBtaW5Qb3M7CiAgICAgICAgY29uc3QgYmVzdFkgPSBhICogYmVzdFJlbGF0aXZlWCAqIGJlc3RSZWxhdGl2ZVggKyBiICogYmVzdFJlbGF0aXZlWCArIGM7CiAgICAgICAgaWYgKGlzRmluaXRlKGJlc3RZKSAmJiBiZXN0WSA+PSAwKSB7CiAgICAgICAgICBjb25zdCBleGlzdHMgPSBjdXJ2ZURhdGEuc29tZShjdXJ2ZVBvaW50ID0+IE1hdGguYWJzKGN1cnZlUG9pbnRbMF0gLSBiZXN0UG9zaXRpb24pIDwgc3RlcFNpemUgLyAyKTsKICAgICAgICAgIGlmICghZXhpc3RzKSB7CiAgICAgICAgICAgIGN1cnZlRGF0YS5wdXNoKFtiZXN0UG9zaXRpb24sIGJlc3RZXSk7CiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIC8vIOWcqOacgOS9s+S9jee9rumZhOi/kea3u+WKoOabtOWkmumrmOeyvuW6pueCuQogICAgICAgICAgY29uc3QgZmluZVJhbmdlID0gTWF0aC5tYXgoc3RlcFNpemUgKiAyLCAyMDApOyAvLyDlnKjmnIDkvbPkvY3nva7pmYTov5EyMDDojIPlm7TlhoXkvb/nlKjpq5jnsr7luqYKICAgICAgICAgIGNvbnN0IGZpbmVTdGVwID0gTWF0aC5tYXgoc3RlcFNpemUgLyAxMCwgNSk7CiAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAtZmluZVJhbmdlOyBvZmZzZXQgPD0gZmluZVJhbmdlOyBvZmZzZXQgKz0gZmluZVN0ZXApIHsKICAgICAgICAgICAgY29uc3QgeCA9IGJlc3RQb3NpdGlvbiArIG9mZnNldDsKICAgICAgICAgICAgaWYgKHggPj0gc3RhcnRYICYmIHggPD0gZW5kWCkgewogICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlWCA9IHggLSBtaW5Qb3M7CiAgICAgICAgICAgICAgY29uc3QgeSA9IGEgKiByZWxhdGl2ZVggKiByZWxhdGl2ZVggKyBiICogcmVsYXRpdmVYICsgYzsKICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoeSkgJiYgeSA+PSAwKSB7CiAgICAgICAgICAgICAgICBjb25zdCBleGlzdHMgPSBjdXJ2ZURhdGEuc29tZShjdXJ2ZVBvaW50ID0+IE1hdGguYWJzKGN1cnZlUG9pbnRbMF0gLSB4KSA8IGZpbmVTdGVwIC8gMik7CiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykgewogICAgICAgICAgICAgICAgICBjdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g5oyJWOWdkOagh+aOkuW6jwogICAgICBjdXJ2ZURhdGEuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pOwogICAgICAKICAgICAgLy8g5Zyo5pWw5o2u54K55a+G6ZuG5Yy65Z+f5aKe5Yqg5puy57q/5a+G5bqmCiAgICAgIGlmICh0aGlzLmNoYXJ0RGF0YTEubGVuZ3RoID4gMCkgewogICAgICAgIGNvbnN0IGVuaGFuY2VkQ3VydmVEYXRhID0gW107CiAgICAgICAgY29uc3QgZmluZVN0ZXBTaXplID0gTWF0aC5tYXgoc3RlcFNpemUgLyA1LCA1KTsgLy8g5Zyo5a+G6ZuG5Yy65Z+f5L2/55So5pu05bCP55qE5q2l6ZW/CiAgICAgICAgCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJ2ZURhdGEubGVuZ3RoIC0gMTsgaSsrKSB7CiAgICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBjdXJ2ZURhdGFbaV07CiAgICAgICAgICBjb25zdCBuZXh0UG9pbnQgPSBjdXJ2ZURhdGFbaSArIDFdOwogICAgICAgICAgCiAgICAgICAgICBlbmhhbmNlZEN1cnZlRGF0YS5wdXNoKGN1cnJlbnRQb2ludCk7CiAgICAgICAgICAKICAgICAgICAgIC8vIOajgOafpeW9k+WJjeauteaYr+WQpuWMheWQq+aVsOaNrueCuQogICAgICAgICAgY29uc3QgaGFzRGF0YVBvaW50ID0gdGhpcy5jaGFydERhdGExLnNvbWUocG9pbnQgPT4gCiAgICAgICAgICAgIHBvaW50WzBdID49IGN1cnJlbnRQb2ludFswXSAmJiBwb2ludFswXSA8PSBuZXh0UG9pbnRbMF0KICAgICAgICAgICk7CiAgICAgICAgICAKICAgICAgICAgIC8vIOWmguaenOWMheWQq+aVsOaNrueCue+8jOWcqOS4remXtOa3u+WKoOabtOWkmueCuQogICAgICAgICAgaWYgKGhhc0RhdGFQb2ludCAmJiAobmV4dFBvaW50WzBdIC0gY3VycmVudFBvaW50WzBdKSA+IGZpbmVTdGVwU2l6ZSkgewogICAgICAgICAgICBjb25zdCBtaWRQb2ludHMgPSBNYXRoLmZsb29yKChuZXh0UG9pbnRbMF0gLSBjdXJyZW50UG9pbnRbMF0pIC8gZmluZVN0ZXBTaXplKTsKICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBtaWRQb2ludHM7IGorKykgewogICAgICAgICAgICAgIGNvbnN0IHggPSBjdXJyZW50UG9pbnRbMF0gKyAoaiAqIGZpbmVTdGVwU2l6ZSk7CiAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVYID0geCAtIG1pblBvczsKICAgICAgICAgICAgICBjb25zdCB5ID0gYSAqIHJlbGF0aXZlWCAqIHJlbGF0aXZlWCArIGIgKiByZWxhdGl2ZVggKyBjOwogICAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh5KSAmJiB5ID49IDApIHsKICAgICAgICAgICAgICAgIGVuaGFuY2VkQ3VydmVEYXRhLnB1c2goW3gsIHldKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8g5re75Yqg5pyA5ZCO5LiA5Liq54K5CiAgICAgICAgaWYgKGN1cnZlRGF0YS5sZW5ndGggPiAwKSB7CiAgICAgICAgICBlbmhhbmNlZEN1cnZlRGF0YS5wdXNoKGN1cnZlRGF0YVtjdXJ2ZURhdGEubGVuZ3RoIC0gMV0pOwogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDmm7TmlrDmm7Lnur/mlbDmja4KICAgICAgICBjdXJ2ZURhdGEubGVuZ3RoID0gMDsKICAgICAgICBjdXJ2ZURhdGEucHVzaCguLi5lbmhhbmNlZEN1cnZlRGF0YSk7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOa3u+WKoOWFs+mUrueCueeahOmqjOivgQogICAgICBpZiAoY3VydmVEYXRhLmxlbmd0aCA+IDApIHsKICAgICAgICAvLyDpqozor4HmnIDkvbPkvY3nva7ngrnnmoRZ5YC8CiAgICAgICAgY29uc3QgYmVzdFBvaW50WSA9IGEgKiAoYmVzdFBvc2l0aW9uIC0gbWluUG9zKSAqIChiZXN0UG9zaXRpb24gLSBtaW5Qb3MpICsgYiAqIChiZXN0UG9zaXRpb24gLSBtaW5Qb3MpICsgYzsKICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5pyA5L2z5L2N572u54K56aqM6K+BOicpOwogICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOacgOS9s+S9jee9rjonLCBiZXN0UG9zaXRpb24pOwogICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOacgOS9s+S9jee9ruebuOWvueWdkOaghzonLCBiZXN0UG9zaXRpb24gLSBtaW5Qb3MpOwogICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOacgOS9s+S9jee9rlnlgLw6JywgYmVzdFBvaW50WSk7CiAgICAgICAgCiAgICAgICAgLy8g6aqM6K+B5pWw5o2u54K55piv5ZCm5Zyo5puy57q/5LiKCiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaVsOaNrueCueS4juabsue6v+WvueavlDonKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKHRoaXMuY2hhcnREYXRhMS5sZW5ndGgsIDUpOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5jaGFydERhdGExW2ldOwogICAgICAgICAgY29uc3QgcG9pbnRSZWxhdGl2ZVggPSBwb2ludFswXSAtIG1pblBvczsKICAgICAgICAgIGNvbnN0IHBvaW50WSA9IGEgKiBwb2ludFJlbGF0aXZlWCAqIHBvaW50UmVsYXRpdmVYICsgYiAqIHBvaW50UmVsYXRpdmVYICsgYzsKICAgICAgICAgIGNvbnN0IGFjdHVhbFkgPSBwb2ludFsxXTsKICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhwb2ludFkgLSBhY3R1YWxZKTsKICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBDaGFydC1Gb2N1cy52dWUgfCAtIOeCuSR7aX06IOS9jee9rj0ke3BvaW50WzBdfSwg5a6e6ZmFSEZSPSR7YWN0dWFsWX0sIOabsue6v0hGUj0ke3BvaW50WX0sIOW3ruW8gj0ke2RpZmZ9YCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg55Sf5oiQ55qE5puy57q/5pWw5o2u54K55pWw6YePOicsIGN1cnZlRGF0YS5sZW5ndGgpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgWOi9tOiMg+WbtDonLCBzdGFydFgsICfliLAnLCBlbmRYKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWJjTXkuKrmlbDmja7ngrk6JywgY3VydmVEYXRhLnNsaWNlKDAsIDUpKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWQjjXkuKrmlbDmja7ngrk6JywgY3VydmVEYXRhLnNsaWNlKC01KSk7CiAgICAgIAogICAgICAvLyDpqozor4Hmm7Lnur/lvaLnirYKICAgICAgaWYgKGN1cnZlRGF0YS5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc3QgZmlyc3RZID0gY3VydmVEYXRhWzBdWzFdOwogICAgICAgIGNvbnN0IGxhc3RZID0gY3VydmVEYXRhW2N1cnZlRGF0YS5sZW5ndGggLSAxXVsxXTsKICAgICAgICBjb25zdCBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3IoY3VydmVEYXRhLmxlbmd0aCAvIDIpOwogICAgICAgIGNvbnN0IG1pZGRsZVkgPSBjdXJ2ZURhdGFbbWlkZGxlSW5kZXhdWzFdOwogICAgICAgIAogICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmm7Lnur/lvaLnirbpqozor4EgLSDotbflp4tZOicsIGZpcnN0WSwgJ+S4remXtFk6JywgbWlkZGxlWSwgJ+e7k+adn1k6JywgbGFzdFkpOwogICAgICAgIAogICAgICAgIC8vIOajgOafpeaYr+WQpuS4uuacieaViOeahOS6jOasoeabsue6v++8iOW6lOivpeacieacgOWwj+WAvOaIluacgOWkp+WAvO+8iQogICAgICAgIGlmIChNYXRoLmFicyhhKSA+IDFlLTEwKSB7CiAgICAgICAgICBjb25zdCB2ZXJ0ZXhYID0gLWIgLyAoMiAqIGEpICsgbWluUG9zOyAvLyDpobbngrlY5Z2Q5qCH77yI6L2s5o2i5Zue57ud5a+55Z2Q5qCH77yJCiAgICAgICAgICBjb25zdCB2ZXJ0ZXhZID0gYyAtIChiICogYikgLyAoNCAqIGEpOyAvLyDpobbngrlZ5Z2Q5qCHCiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5LqM5qyh5puy57q/6aG254K55L2N572uOicsIHZlcnRleFgsICdZ5YC8OicsIHZlcnRleFkpOwogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g5pyA57uI6aqM6K+B5ZKM5riF55CG5puy57q/5pWw5o2uCiAgICAgIGNvbnN0IGZpbmFsQ3VydmVEYXRhID0gY3VydmVEYXRhLmZpbHRlcihwb2ludCA9PiB7CiAgICAgICAgY29uc3QgW3gsIHldID0gcG9pbnQ7CiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHgpICYmIGlzRmluaXRlKHkpICYmIHkgPj0gMCAmJiB4ID49IHN0YXJ0WCAmJiB4IDw9IGVuZFg7CiAgICAgIH0pOwogICAgICAKICAgICAgLy8g56Gu5L+d5puy57q/5pWw5o2u5oyJWOWdkOagh+aOkuW6jwogICAgICBmaW5hbEN1cnZlRGF0YS5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSk7CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5pyA57uI5puy57q/5pWw5o2u6aqM6K+BOicpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDljp/lp4vmlbDmja7ngrnmlbDph486JywgY3VydmVEYXRhLmxlbmd0aCk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOa4heeQhuWQjuaVsOaNrueCueaVsOmHjzonLCBmaW5hbEN1cnZlRGF0YS5sZW5ndGgpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSBY6L206IyD5Zu0OicsIGZpbmFsQ3VydmVEYXRhLmxlbmd0aCA+IDAgPyBgJHtmaW5hbEN1cnZlRGF0YVswXVswXX0g5YiwICR7ZmluYWxDdXJ2ZURhdGFbZmluYWxDdXJ2ZURhdGEubGVuZ3RoIC0gMV1bMF19YCA6ICfml6DmlbDmja4nKTsKICAgICAgCiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IGZpbmFsQ3VydmVEYXRhOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgY2hhcnREYXRhMuW3suabtOaWsO+8jOmVv+W6pjonLCB0aGlzLmNoYXJ0RGF0YTIubGVuZ3RoKTsKICAgICAgCiAgICAgIC8vIOiwg+aVtFjovbTojIPlm7Tku6XmmL7npLrlrozmlbTmm7Lnur8KICAgICAgaWYgKGZpbmFsQ3VydmVEYXRhLmxlbmd0aCA+IDApIHsKICAgICAgICB0aGlzLnhBeGlzX21pbiA9IE1hdGgubWluKHRoaXMueEF4aXNfbWluLCBmaW5hbEN1cnZlRGF0YVswXVswXSk7CiAgICAgICAgdGhpcy54QXhpc19tYXggPSBNYXRoLm1heCh0aGlzLnhBeGlzX21heCwgZmluYWxDdXJ2ZURhdGFbZmluYWxDdXJ2ZURhdGEubGVuZ3RoIC0gMV1bMF0pOwogICAgICB9CiAgICAgIAogICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDkuozmrKHmm7Lnur/mlbDmja7ngrnlt7LnlJ/miJDlubbmuLLmn5PlrozmiJAnKTsKICAgIH0sCiAgICAKICAgIC8vIOeUn+aIkOe6v+aAp+absue6v+aVsOaNrueCue+8iOW9k2E9MOaXtu+8iQogICAgZ2VuZXJhdGVMaW5lYXJDdXJ2ZShiLCBjLCBiZXN0UG9zaXRpb24pIHsKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5byA5aeL55Sf5oiQ57q/5oCn5puy57q/5pWw5o2u54K5OicsIHsgYiwgYywgYmVzdFBvc2l0aW9uIH0pOwogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwg5byA5aeL55Sf5oiQ57q/5oCn5puy57q/5pWw5o2u54K5OicsIHsgYiwgYywgYmVzdFBvc2l0aW9uIH0pOwogICAgICAKICAgICAgLy8g5a+55LqO57q/5oCn5ouf5ZCI77yM5oiR5Lus6ZyA6KaB5om+5Yiw5pWw5o2u54K555qE5pyA5bCP5L2N572u5L2c5Li65YGP56e76YePCiAgICAgIGxldCBtaW5Qb3MgPSAwOwogICAgICBpZiAodGhpcy5jaGFydERhdGExLmxlbmd0aCA+IDApIHsKICAgICAgICBtaW5Qb3MgPSBNYXRoLm1pbiguLi50aGlzLmNoYXJ0RGF0YTEubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmi5/lkIjlnZDmoIfns7vnu5/kv6Hmga86Jyk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOaVsOaNrueCueacgOWwj+S9jee9riAobWluUG9zKTonLCBtaW5Qb3MpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDnur/mgKfns7vmlbAgYjonLCBiLCAnYzonLCBjKTsKICAgICAgCiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmi5/lkIjlnZDmoIfns7vnu5/kv6Hmga86Jyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCAtIOaVsOaNrueCueacgOWwj+S9jee9riAobWluUG9zKTonLCBtaW5Qb3MpOwogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDnur/mgKfns7vmlbAgYjonLCBiLCAnYzonLCBjKTsKICAgICAgCiAgICAgIGNvbnN0IGN1cnZlRGF0YSA9IFtdOwogICAgICAKICAgICAgLy8g5pm66IO956Gu5a6a5puy57q/55Sf5oiQ6IyD5Zu0CiAgICAgIGxldCBzdGFydFgsIGVuZFgsIHN0ZXBTaXplOwogICAgICAKICAgICAgaWYgKHRoaXMuY2hhcnREYXRhMS5sZW5ndGggPiAwKSB7CiAgICAgICAgLy8g5Z+65LqO5pWw5o2u54K56IyD5Zu055Sf5oiQ5puy57q/CiAgICAgICAgY29uc3QgZGF0YU1pblggPSBNYXRoLm1pbiguLi50aGlzLmNoYXJ0RGF0YTEubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgICAgY29uc3QgZGF0YU1heFggPSBNYXRoLm1heCguLi50aGlzLmNoYXJ0RGF0YTEubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgICAgY29uc3QgZGF0YVJhbmdlID0gZGF0YU1heFggLSBkYXRhTWluWDsKICAgICAgICAKICAgICAgICAvLyDmianlsZXojIPlm7Tku6Xnoa7kv53mm7Lnur/opobnm5blrozmlbQKICAgICAgICBjb25zdCBleHRlbnNpb24gPSBNYXRoLm1heChkYXRhUmFuZ2UgKiAwLjIsIDEwMDApOwogICAgICAgIHN0YXJ0WCA9IGRhdGFNaW5YIC0gZXh0ZW5zaW9uOwogICAgICAgIGVuZFggPSBkYXRhTWF4WCArIGV4dGVuc2lvbjsKICAgICAgICAKICAgICAgICAvLyDmoLnmja7mlbDmja7ojIPlm7TosIPmlbTmraXplb8KICAgICAgICBzdGVwU2l6ZSA9IE1hdGgubWF4KE1hdGguZmxvb3IoZGF0YVJhbmdlIC8gMTAwKSwgMjApOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIOWmguaenOayoeacieaVsOaNrueCue+8jOS9v+eUqOm7mOiupOiMg+WbtAogICAgICAgIGNvbnN0IHJhbmdlID0gNTAwMDsKICAgICAgICBzdGFydFggPSBiZXN0UG9zaXRpb24gLSByYW5nZTsKICAgICAgICBlbmRYID0gYmVzdFBvc2l0aW9uICsgcmFuZ2U7CiAgICAgICAgc3RlcFNpemUgPSA1MDsKICAgICAgfQogICAgICAKICAgICAgLy8g56Gu5L+d5puy57q/6KaG55uW5b2T5YmNWOi9tOiMg+WbtAogICAgICBzdGFydFggPSBNYXRoLm1pbihzdGFydFgsIHRoaXMueEF4aXNfbWluKTsKICAgICAgZW5kWCA9IE1hdGgubWF4KGVuZFgsIHRoaXMueEF4aXNfbWF4KTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmm7Lnur/nlJ/miJDojIPlm7Q6Jywgc3RhcnRYLCAn5YiwJywgZW5kWCwgJ+atpemVvzonLCBzdGVwU2l6ZSk7CiAgICAgIAogICAgICAvLyDnlJ/miJDnur/mgKfmm7Lnur/mlbDmja7ngrkKICAgICAgZm9yIChsZXQgeCA9IHN0YXJ0WDsgeCA8PSBlbmRYOyB4ICs9IHN0ZXBTaXplKSB7CiAgICAgICAgLy8g5bCG57ud5a+55Z2Q5qCH6L2s5o2i5Li655u45a+55Z2Q5qCH6L+b6KGM6K6h566XCiAgICAgICAgY29uc3QgcmVsYXRpdmVYID0geCAtIG1pblBvczsKICAgICAgICBjb25zdCB5ID0gYiAqIHJlbGF0aXZlWCArIGM7IC8vIOe6v+aAp+aWueeoi++8mnkgPSBieCArIGMKICAgICAgICAKICAgICAgICAvLyDpqozor4HorqHnrpfnu5PmnpwKICAgICAgICBpZiAoaXNGaW5pdGUoeSkgJiYgeSA+PSAwKSB7CiAgICAgICAgICBjdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDaGFydC1Gb2N1cy52dWUgfCDorablkYrvvJrorqHnrpflvpfliLDml6DmlYjnmoRZ5YC8OicsIHksICflnKjkvY3nva46JywgeCwgJ+ebuOWvueS9jee9rjonLCByZWxhdGl2ZVgpOwogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g5re75Yqg5YWz6ZSu54K577ya56Gu5L+d5pWw5o2u54K55L2N572u5Zyo5puy57q/5LiK5pyJ57K+56Gu55qE54K5CiAgICAgIGlmICh0aGlzLmNoYXJ0RGF0YTEubGVuZ3RoID4gMCkgewogICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGhpcy5jaGFydERhdGExKSB7CiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRbMF07CiAgICAgICAgICBjb25zdCByZWxhdGl2ZVggPSB4IC0gbWluUG9zOwogICAgICAgICAgY29uc3QgeSA9IGIgKiByZWxhdGl2ZVggKyBjOwogICAgICAgICAgCiAgICAgICAgICBpZiAoaXNGaW5pdGUoeSkgJiYgeSA+PSAwKSB7CiAgICAgICAgICAgIC8vIOajgOafpeaYr+WQpuW3sue7j+WtmOWcqOi/meS4queCue+8iOmBv+WFjemHjeWkje+8iQogICAgICAgICAgICBjb25zdCBleGlzdHMgPSBjdXJ2ZURhdGEuc29tZShjdXJ2ZVBvaW50ID0+IE1hdGguYWJzKGN1cnZlUG9pbnRbMF0gLSB4KSA8IHN0ZXBTaXplIC8gMik7CiAgICAgICAgICAgIGlmICghZXhpc3RzKSB7CiAgICAgICAgICAgICAgY3VydmVEYXRhLnB1c2goW3gsIHldKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g5oyJWOWdkOagh+aOkuW6jwogICAgICBjdXJ2ZURhdGEuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pOwogICAgICAKICAgICAgLy8g5pyA57uI6aqM6K+B5ZKM5riF55CG5puy57q/5pWw5o2uCiAgICAgIGNvbnN0IGZpbmFsQ3VydmVEYXRhID0gY3VydmVEYXRhLmZpbHRlcihwb2ludCA9PiB7CiAgICAgICAgY29uc3QgW3gsIHldID0gcG9pbnQ7CiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHgpICYmIGlzRmluaXRlKHkpICYmIHkgPj0gMCAmJiB4ID49IHN0YXJ0WCAmJiB4IDw9IGVuZFg7CiAgICAgIH0pOwogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOe6v+aAp+absue6v+acgOe7iOaVsOaNrumqjOivgTonKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5Y6f5aeL5pWw5o2u54K55pWw6YePOicsIGN1cnZlRGF0YS5sZW5ndGgpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDmuIXnkIblkI7mlbDmja7ngrnmlbDph486JywgZmluYWxDdXJ2ZURhdGEubGVuZ3RoKTsKICAgICAgCiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IGZpbmFsQ3VydmVEYXRhOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgY2hhcnREYXRhMuW3suabtOaWsO+8iOe6v+aAp+aLn+WQiO+8ie+8jOmVv+W6pjonLCB0aGlzLmNoYXJ0RGF0YTIubGVuZ3RoKTsKICAgICAgCiAgICAgIC8vIOiwg+aVtFjovbTojIPlm7Tku6XmmL7npLrlrozmlbTmm7Lnur8KICAgICAgaWYgKGZpbmFsQ3VydmVEYXRhLmxlbmd0aCA+IDApIHsKICAgICAgICB0aGlzLnhBeGlzX21pbiA9IE1hdGgubWluKHRoaXMueEF4aXNfbWluLCBmaW5hbEN1cnZlRGF0YVswXVswXSk7CiAgICAgICAgdGhpcy54QXhpc19tYXggPSBNYXRoLm1heCh0aGlzLnhBeGlzX21heCwgZmluYWxDdXJ2ZURhdGFbZmluYWxDdXJ2ZURhdGEubGVuZ3RoIC0gMV1bMF0pOwogICAgICB9CiAgICAgIAogICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmm7Lnur/mlbDmja7ngrnlt7LnlJ/miJDlubbmuLLmn5PlrozmiJAnKTsKICAgIH0sCiAgICAKICAgIC8vIOaLn+WQiOS6jOasoeabsue6v+acgOWwj+eCuQogICAgZml0UXVhZHJhdGljQ3VydmVfbWluUG9pbnQoZGF0YVN0cmluZykgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmjqXmlLbmnIDlsI/ngrnmlbDmja46JywgZGF0YVN0cmluZyk7CiAgICAgIAogICAgICBjb25zdCBwYXJ0cyA9IGRhdGFTdHJpbmcuc3BsaXQoJzonKTsKICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAzKSB7CiAgICAgICAgY29uc3QgYmVzdFBvc2l0aW9uID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7CiAgICAgICAgY29uc3QgbWluSEZSID0gcGFyc2VGbG9hdChwYXJ0c1syXSk7CiAgICAgICAgCiAgICAgICAgLy8g5pu05paw5paH5pys5qGG5pi+56S6CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuYmVzdFBvc2l0aW9uID0gYmVzdFBvc2l0aW9uLnRvRml4ZWQoMik7CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQubWluSEZSID0gbWluSEZSLnRvRml4ZWQoMyk7CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuc2hvdyA9IHRydWU7CiAgICAgICAgCiAgICAgICAgLy8g5re75Yqg5pyA5bCP54K55Yiw5Zu+6KGoCiAgICAgICAgdGhpcy5jaGFydERhdGEzID0gW107CiAgICAgICAgdGhpcy5jaGFydERhdGEzLnB1c2goW2Jlc3RQb3NpdGlvbiwgbWluSEZSXSk7CiAgICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICAgIAogICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOacgOWwj+eCueS/oeaBr+W3suabtOaWsDonLCB7IGJlc3RQb3NpdGlvbiwgbWluSEZSIH0pOwogICAgICB9CiAgICB9LAogICAgc2V0Rm9jdXNDaGFydFJhbmdlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHsKICAgICAgdGhpcy54X21pbiA9IGxvd2VyQm91bmQ7CiAgICAgIHRoaXMueF9tYXggPSB1cHBlckJvdW5kOwogICAgfSwKICAgIAogICAgLy8gPT09PT09PT09PT09PT09PT09PT0g5byC5bi454K55qOA5rWL5pa55rOVID09PT09PT09PT09PT09PT09PT09CiAgICAKICAgIC8qKgogICAgICog5pm66IO95byC5bi454K55qOA5rWLCiAgICAgKiDkvb/nlKjlpJrnp43mlrnms5Xmo4DmtYvlubbljrvpmaTlvILluLjngrkKICAgICAqLwogICAgcmVtb3ZlT3V0bGllcnMoZGF0YVBvaW50cykgewogICAgICBpZiAoZGF0YVBvaW50cy5sZW5ndGggPCA0KSB7CiAgICAgICAgcmV0dXJuIGRhdGFQb2ludHM7IC8vIOaVsOaNrueCueWkquWwke+8jOS4jei/m+ihjOW8guW4uOWAvOajgOa1iwogICAgICB9CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDlvIDlp4vmmbrog73lvILluLjlgLzmo4DmtYvvvIzljp/lp4vmlbDmja7ngrnmlbDph486JywgZGF0YVBvaW50cy5sZW5ndGgpOwogICAgICAKICAgICAgLy8g5pa55rOVMe+8muWfuuS6juS6jOasoeabsue6v+aLn+WQiOeahOaui+W3ruWIhuaekAogICAgICBjb25zdCBjbGVhbkRhdGExID0gdGhpcy5yZW1vdmVPdXRsaWVyc0J5UmVzaWR1YWwoZGF0YVBvaW50cyk7CiAgICAgIAogICAgICAvLyDmlrnms5Uy77ya5Z+65LqOSEZS57uf6K6h5YiG5biD55qESVFS5pa55rOVCiAgICAgIGNvbnN0IGNsZWFuRGF0YTIgPSB0aGlzLnJlbW92ZU91dGxpZXJzQnlJUVIoZGF0YVBvaW50cyk7CiAgICAgIAogICAgICAvLyDmlrnms5Uz77ya5Z+65LqO5L2N572u5YiG5biD55qE5byC5bi45qOA5rWLCiAgICAgIGNvbnN0IGNsZWFuRGF0YTMgPSB0aGlzLnJlbW92ZU91dGxpZXJzQnlQb3NpdGlvbihkYXRhUG9pbnRzKTsKICAgICAgCiAgICAgIC8vIOmAieaLqeS/neeVmeacgOWkmuaVsOaNrueCueeahOaWueazle+8jOS9huehruS/neiHs+WwkeaciTPkuKrmlbDmja7ngrkKICAgICAgbGV0IGJlc3RDbGVhbkRhdGEgPSBjbGVhbkRhdGExOwogICAgICBpZiAoY2xlYW5EYXRhMi5sZW5ndGggPiBiZXN0Q2xlYW5EYXRhLmxlbmd0aCAmJiBjbGVhbkRhdGEyLmxlbmd0aCA+PSAzKSB7CiAgICAgICAgYmVzdENsZWFuRGF0YSA9IGNsZWFuRGF0YTI7CiAgICAgIH0KICAgICAgaWYgKGNsZWFuRGF0YTMubGVuZ3RoID4gYmVzdENsZWFuRGF0YS5sZW5ndGggJiYgY2xlYW5EYXRhMy5sZW5ndGggPj0gMykgewogICAgICAgIGJlc3RDbGVhbkRhdGEgPSBjbGVhbkRhdGEzOwogICAgICB9CiAgICAgIAogICAgICAvLyDlpoLmnpzmiYDmnInmlrnms5Xpg73ov4fmu6TlvpflpKrkuKXmoLzvvIzkvb/nlKjmnIDlrr3mnb7nmoTmlrnms5UKICAgICAgaWYgKGJlc3RDbGVhbkRhdGEubGVuZ3RoIDwgMykgewogICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaJgOacieW8guW4uOWAvOajgOa1i+aWueazlemDvei/h+S6juS4peagvO+8jOS9v+eUqOacgOWuveadvueahOaWueazlScpOwogICAgICAgIGJlc3RDbGVhbkRhdGEgPSBjbGVhbkRhdGEyOyAvLyBJUVLmlrnms5Xnm7jlr7nlrr3mnb4KICAgICAgICBpZiAoYmVzdENsZWFuRGF0YS5sZW5ndGggPCAzKSB7CiAgICAgICAgICBiZXN0Q2xlYW5EYXRhID0gZGF0YVBvaW50czsgLy8g5aaC5p6c6L+Y5piv5LiN5aSf77yM6L+U5Zue5Y6f5aeL5pWw5o2uCiAgICAgICAgfQogICAgICB9CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmmbrog73lvILluLjlgLzmo4DmtYvlrozmiJA6IOWOn+Wni+aVsOaNricsIGRhdGFQb2ludHMubGVuZ3RoLCAn5Liq54K577yM5riF55CG5ZCOJywgYmVzdENsZWFuRGF0YS5sZW5ndGgsICfkuKrngrknKTsKICAgICAgCiAgICAgIHJldHVybiBiZXN0Q2xlYW5EYXRhOwogICAgfSwKICAgIAogICAgLyoqCiAgICAgKiDln7rkuo7kuozmrKHmm7Lnur/mi5/lkIjmrovlt67nmoTlvILluLjlgLzmo4DmtYsKICAgICAqIOazqOaEj++8mueOsOWcqOS4u+imgeS+nei1luWQjuerr+aLn+WQiOe7k+aenO+8jOatpOaWueazleS7heS9nOS4uuWkh+eUqAogICAgICovCiAgICByZW1vdmVPdXRsaWVyc0J5UmVzaWR1YWwoZGF0YVBvaW50cykgewogICAgICBpZiAoZGF0YVBvaW50cy5sZW5ndGggPCA0KSB7CiAgICAgICAgcmV0dXJuIGRhdGFQb2ludHM7IC8vIOmcgOimgeiHs+WwkTTkuKrngrnmiY3og73ov5vooYzkuozmrKHmi5/lkIgKICAgICAgfQogICAgICAKICAgICAgLy8g566A5YyW5byC5bi45YC85qOA5rWL77ya55u05o6l5L2/55SoSVFS5pa55rOV77yM5LiN5YaN6L+b6KGM5LqM5qyh5ouf5ZCICiAgICAgIGNvbnN0IHByZWxpbWluYXJ5Q2xlYW4gPSB0aGlzLnJlbW92ZU91dGxpZXJzQnlJUVIoZGF0YVBvaW50cyk7CiAgICAgIGlmIChwcmVsaW1pbmFyeUNsZWFuLmxlbmd0aCA8IDMpIHsKICAgICAgICByZXR1cm4gZGF0YVBvaW50czsKICAgICAgfQogICAgICAKICAgICAgLy8g5LiN5YaN6L+b6KGM5YmN56uv5ouf5ZCI77yM55u05o6l6L+U5ZueSVFS5riF55CG5ZCO55qE5pWw5o2uCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOW8guW4uOWAvOajgOa1i++8muS9v+eUqElRUuaWueazle+8jOS4jeWGjei/m+ihjOWJjeerr+aLn+WQiCcpOwogICAgICByZXR1cm4gcHJlbGltaW5hcnlDbGVhbjsKICAgIH0sCiAgICAKICAgIC8qKgogICAgICog5Z+65LqOSEZS57uf6K6h5YiG5biD55qESVFS5byC5bi45YC85qOA5rWLCiAgICAgKi8KICAgIHJlbW92ZU91dGxpZXJzQnlJUVIoZGF0YVBvaW50cykgewogICAgICAvLyDorqHnrpdIRlLnmoTnu5/orqHkv6Hmga8KICAgICAgY29uc3QgaGZyVmFsdWVzID0gZGF0YVBvaW50cy5tYXAocG9pbnQgPT4gcG9pbnRbMV0pOwogICAgICAKICAgICAgLy8g5o6S5bqPCiAgICAgIGNvbnN0IHNvcnRlZEhmclZhbHVlcyA9IFsuLi5oZnJWYWx1ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTsKICAgICAgCiAgICAgIC8vIOiuoeeul+Wbm+WIhuS9jeaVsAogICAgICBjb25zdCBuID0gc29ydGVkSGZyVmFsdWVzLmxlbmd0aDsKICAgICAgY29uc3QgcTEgPSBzb3J0ZWRIZnJWYWx1ZXNbTWF0aC5mbG9vcihuIC8gNCldOwogICAgICBjb25zdCBxMyA9IHNvcnRlZEhmclZhbHVlc1tNYXRoLmZsb29yKDMgKiBuIC8gNCldOwogICAgICBjb25zdCBpcXIgPSBxMyAtIHExOwogICAgICAKICAgICAgLy8g5a6a5LmJ5byC5bi45YC86L6555WM77yI5L2/55SoMuWAjUlRUu+8jOavlDEuNeWAjeabtOWuveadvu+8iQogICAgICBjb25zdCBsb3dlckJvdW5kID0gcTEgLSAyLjAgKiBpcXI7CiAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSBxMyArIDIuMCAqIGlxcjsKICAgICAgCiAgICAgIC8vIOi/h+a7pOW8guW4uOWAvAogICAgICBjb25zdCBjbGVhbkRhdGEgPSBkYXRhUG9pbnRzLmZpbHRlcihwb2ludCA9PiAKICAgICAgICBwb2ludFsxXSA+PSBsb3dlckJvdW5kICYmIHBvaW50WzFdIDw9IHVwcGVyQm91bmQKICAgICAgKTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWfuuS6jklRUueahOW8guW4uOWAvOajgOa1izog5Y6f5aeL5pWw5o2uJywgZGF0YVBvaW50cy5sZW5ndGgsICfkuKrngrnvvIzmuIXnkIblkI4nLCBjbGVhbkRhdGEubGVuZ3RoLCAn5Liq54K5Jyk7CiAgICAgIAogICAgICByZXR1cm4gY2xlYW5EYXRhOwogICAgfSwKICAgIAogICAgLyoqCiAgICAgKiDln7rkuo7kvY3nva7liIbluIPnmoTlvILluLjlgLzmo4DmtYsKICAgICAqLwogICAgcmVtb3ZlT3V0bGllcnNCeVBvc2l0aW9uKGRhdGFQb2ludHMpIHsKICAgICAgaWYgKGRhdGFQb2ludHMubGVuZ3RoIDwgNCkgewogICAgICAgIHJldHVybiBkYXRhUG9pbnRzOwogICAgICB9CiAgICAgIAogICAgICAvLyDmjInkvY3nva7mjpLluo8KICAgICAgY29uc3Qgc29ydGVkRGF0YSA9IFsuLi5kYXRhUG9pbnRzXS5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSk7CiAgICAgIAogICAgICAvLyDorqHnrpfnm7jpgrvngrnkuYvpl7TnmoTot53nprsKICAgICAgY29uc3QgZGlzdGFuY2VzID0gW107CiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc29ydGVkRGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGRpc3QgPSBzb3J0ZWREYXRhW2ldWzBdIC0gc29ydGVkRGF0YVtpLTFdWzBdOwogICAgICAgIGRpc3RhbmNlcy5wdXNoKGRpc3QpOwogICAgICB9CiAgICAgIAogICAgICAvLyDorqHnrpfot53nprvnmoTnu5/orqHkv6Hmga8KICAgICAgY29uc3Qgc29ydGVkRGlzdGFuY2VzID0gWy4uLmRpc3RhbmNlc10uc29ydCgoYSwgYikgPT4gYSAtIGIpOwogICAgICBjb25zdCBuID0gc29ydGVkRGlzdGFuY2VzLmxlbmd0aDsKICAgICAgY29uc3QgbWVkaWFuRGlzdGFuY2UgPSBzb3J0ZWREaXN0YW5jZXNbTWF0aC5mbG9vcihuIC8gMildOwogICAgICBjb25zdCBxMyA9IHNvcnRlZERpc3RhbmNlc1tNYXRoLmZsb29yKDMgKiBuIC8gNCldOwogICAgICBjb25zdCB0aHJlc2hvbGQgPSBxMyArIDEuNSAqIChxMyAtIG1lZGlhbkRpc3RhbmNlKTsKICAgICAgCiAgICAgIC8vIOivhuWIq+S9jee9ruW8guW4uOeahOeCuQogICAgICBjb25zdCBjbGVhbkRhdGEgPSBbXTsKICAgICAgY2xlYW5EYXRhLnB1c2goc29ydGVkRGF0YVswXSk7IC8vIOesrOS4gOS4queCueaAu+aYr+S/neeVmQogICAgICAKICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzb3J0ZWREYXRhLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgZGlzdCA9IHNvcnRlZERhdGFbaV1bMF0gLSBzb3J0ZWREYXRhW2ktMV1bMF07CiAgICAgICAgaWYgKGRpc3QgPD0gdGhyZXNob2xkKSB7CiAgICAgICAgICBjbGVhbkRhdGEucHVzaChzb3J0ZWREYXRhW2ldKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8g5qOA5p+l5piv5ZCm5piv5a2k56uL54K577yI5YmN5ZCO6Led56a76YO95b6I5aSn77yJCiAgICAgICAgICBsZXQgaXNJc29sYXRlZCA9IHRydWU7CiAgICAgICAgICBpZiAoaSA+IDEpIHsKICAgICAgICAgICAgY29uc3QgcHJldkRpc3QgPSBzb3J0ZWREYXRhW2ktMV1bMF0gLSBzb3J0ZWREYXRhW2ktMl1bMF07CiAgICAgICAgICAgIGlmIChwcmV2RGlzdCA8PSB0aHJlc2hvbGQpIGlzSXNvbGF0ZWQgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChpIDwgc29ydGVkRGF0YS5sZW5ndGggLSAxKSB7CiAgICAgICAgICAgIGNvbnN0IG5leHREaXN0ID0gc29ydGVkRGF0YVtpKzFdWzBdIC0gc29ydGVkRGF0YVtpXVswXTsKICAgICAgICAgICAgaWYgKG5leHREaXN0IDw9IHRocmVzaG9sZCkgaXNJc29sYXRlZCA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgCiAgICAgICAgICBpZiAoIWlzSXNvbGF0ZWQpIHsKICAgICAgICAgICAgY2xlYW5EYXRhLnB1c2goc29ydGVkRGF0YVtpXSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDln7rkuo7kvY3nva7nmoTlvILluLjlgLzmo4DmtYs6IOWOn+Wni+aVsOaNricsIGRhdGFQb2ludHMubGVuZ3RoLCAn5Liq54K577yM5riF55CG5ZCOJywgY2xlYW5EYXRhLmxlbmd0aCwgJ+S4queCuScpOwogICAgICAKICAgICAgcmV0dXJuIGNsZWFuRGF0YTsKICAgIH0sCiAgICAKICAgIC8qKgogICAgICog5omn6KGM5LqM5qyh5puy57q/5ouf5ZCICiAgICAgKiDms6jmhI/vvJrnjrDlnKjkuLvopoHkvp3otZblkI7nq6/mi5/lkIjnu5PmnpzvvIzmraTmlrnms5Xku4XnlKjkuo7mtYvor5XlkozosIPor5UKICAgICAqIOi/lOWbnuaLn+WQiOezu+aVsCB7YSwgYiwgY30KICAgICAqLwogICAgcGVyZm9ybVF1YWRyYXRpY0ZpdChkYXRhUG9pbnRzKSB7CiAgICAgIGlmIChkYXRhUG9pbnRzLmxlbmd0aCA8IDMpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgICAKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5byA5aeL5LqM5qyh5puy57q/5ouf5ZCI77yM5pWw5o2u54K55pWw6YePOicsIGRhdGFQb2ludHMubGVuZ3RoKTsKICAgICAgCiAgICAgIC8vIOagh+WHhuWMluWdkOagh++8muWwhuS9jee9rui9rOaNouS4uuebuOWvueWdkOaghwogICAgICBjb25zdCBtaW5Qb3MgPSBNYXRoLm1pbiguLi5kYXRhUG9pbnRzLm1hcChwb2ludCA9PiBwb2ludFswXSkpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5pyA5bCP5L2N572uICjlgY/np7vph48pOicsIG1pblBvcyk7CiAgICAgIAogICAgICAvLyDmnoTlu7rmnIDlsI/kuozkuZjms5XmraPop4TmlrnnqIvnu4QKICAgICAgbGV0IHN1bV94NCA9IDAsIHN1bV94MyA9IDAsIHN1bV94MiA9IDAsIHN1bV94ID0gMCwgc3VtXzEgPSAwOwogICAgICBsZXQgc3VtX3gyeSA9IDAsIHN1bV94eSA9IDAsIHN1bV95ID0gMDsKICAgICAgCiAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YVBvaW50cykgewogICAgICAgIGNvbnN0IHggPSBwb2ludFswXSAtIG1pblBvczsgLy8g55u45a+55Z2Q5qCHCiAgICAgICAgY29uc3QgeSA9IHBvaW50WzFdOwogICAgICAgIAogICAgICAgIGNvbnN0IHgyID0geCAqIHg7CiAgICAgICAgY29uc3QgeDMgPSB4MiAqIHg7CiAgICAgICAgY29uc3QgeDQgPSB4MyAqIHg7CiAgICAgICAgCiAgICAgICAgc3VtX3g0ICs9IHg0OwogICAgICAgIHN1bV94MyArPSB4MzsKICAgICAgICBzdW1feDIgKz0geDI7CiAgICAgICAgc3VtX3ggKz0geDsKICAgICAgICBzdW1fMSArPSAxOwogICAgICAgIAogICAgICAgIHN1bV94MnkgKz0geDIgKiB5OwogICAgICAgIHN1bV94eSArPSB4ICogeTsKICAgICAgICBzdW1feSArPSB5OwogICAgICB9CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5ouf5ZCI57uf6K6h6YePOicsIHsKICAgICAgICBzdW1feDQsIHN1bV94Mywgc3VtX3gyLCBzdW1feCwgc3VtXzEsCiAgICAgICAgc3VtX3gyeSwgc3VtX3h5LCBzdW1feQogICAgICB9KTsKICAgICAgCiAgICAgIC8vIOaehOW7uuezu+aVsOefqemYteWSjOW4uOaVsOWQkemHjwogICAgICBjb25zdCBtYXRyaXggPSBbCiAgICAgICAgW3N1bV94NCwgc3VtX3gzLCBzdW1feDJdLAogICAgICAgIFtzdW1feDMsIHN1bV94Miwgc3VtX3hdLAogICAgICAgIFtzdW1feDIsIHN1bV94LCBzdW1fMV0KICAgICAgXTsKICAgICAgCiAgICAgIGNvbnN0IGNvbnN0YW50cyA9IFtzdW1feDJ5LCBzdW1feHksIHN1bV95XTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDns7vmlbDnn6npmLU6JywgbWF0cml4KTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOW4uOaVsOWQkemHjzonLCBjb25zdGFudHMpOwogICAgICAKICAgICAgLy8g5rGC6Kej57q/5oCn5pa556iL57uE77yI5L2/55So6auY5pav5raI5YWD5rOV77yJCiAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuc29sdmVMaW5lYXJTeXN0ZW0obWF0cml4LCBjb25zdGFudHMpOwogICAgICBpZiAoIWNvZWZmaWNpZW50cykgewogICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmlrnnqIvnu4TmsYLop6PlpLHotKUnKTsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgICAKICAgICAgY29uc3QgcmVzdWx0ID0gewogICAgICAgIGE6IGNvZWZmaWNpZW50c1swXSwKICAgICAgICBiOiBjb2VmZmljaWVudHNbMV0sCiAgICAgICAgYzogY29lZmZpY2llbnRzWzJdCiAgICAgIH07CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmi5/lkIjns7vmlbA6JywgcmVzdWx0KTsKICAgICAgCiAgICAgIC8vIOmqjOivgeaLn+WQiOe7k+aenAogICAgICBpZiAoIWlzRmluaXRlKHJlc3VsdC5hKSB8fCAhaXNGaW5pdGUocmVzdWx0LmIpIHx8ICFpc0Zpbml0ZShyZXN1bHQuYykpIHsKICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignQ2hhcnQtRm9jdXMudnVlIHwg5ouf5ZCI57O75pWw5YyF5ZCr5peg5pWI5YC8Jyk7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOajgOafpeaYr+WQpuS4uuacieaViOeahOS6jOasoeabsue6v++8iGHkuI3kuLow77yJCiAgICAgIGlmIChNYXRoLmFicyhyZXN1bHQuYSkgPCAxZS0xMCkgewogICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOitpuWRiu+8muS6jOasoemhueezu+aVsOaOpei/kTDvvIzlj6/og73mmK/nm7Tnur/mi5/lkIgnKTsKICAgICAgfQogICAgICAKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0sCiAgICAKICAgIC8qKgogICAgICog5rGC6KejM3gz57q/5oCn5pa556iL57uECiAgICAgKi8KICAgIHNvbHZlTGluZWFyU3lzdGVtKG1hdHJpeCwgY29uc3RhbnRzKSB7CiAgICAgIC8vIOmrmOaWr+a2iOWFg+azleaxguino+e6v+aAp+aWueeoi+e7hAogICAgICBjb25zdCBhdWdtZW50ZWQgPSBbXTsKICAgICAgCiAgICAgIC8vIOaehOW7uuWinuW5v+efqemYtQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykgewogICAgICAgIGF1Z21lbnRlZFtpXSA9IFsuLi5tYXRyaXhbaV0sIGNvbnN0YW50c1tpXV07CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOWJjeWQkea2iOWFgwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykgewogICAgICAgIC8vIOWvu+aJvuS4u+WFgwogICAgICAgIGxldCBtYXhSb3cgPSBpOwogICAgICAgIGZvciAobGV0IGsgPSBpICsgMTsgayA8IDM7IGsrKykgewogICAgICAgICAgaWYgKE1hdGguYWJzKGF1Z21lbnRlZFtrXVtpXSkgPiBNYXRoLmFicyhhdWdtZW50ZWRbbWF4Um93XVtpXSkpIHsKICAgICAgICAgICAgbWF4Um93ID0gazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8g5Lqk5o2i6KGMCiAgICAgICAgaWYgKG1heFJvdyAhPT0gaSkgewogICAgICAgICAgW2F1Z21lbnRlZFtpXSwgYXVnbWVudGVkW21heFJvd11dID0gW2F1Z21lbnRlZFttYXhSb3ddLCBhdWdtZW50ZWRbaV1dOwogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDmo4Dmn6XkuLvlhYPmmK/lkKbkuLrpm7YKICAgICAgICBpZiAoTWF0aC5hYnMoYXVnbWVudGVkW2ldW2ldKSA8IDFlLTEwKSB7CiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignQ2hhcnQtRm9jdXMudnVlIHwg57q/5oCn5pa556iL57uE5aWH5byC77yM5peg5rOV5rGC6KejJyk7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8g5raI5YWDCiAgICAgICAgZm9yIChsZXQgayA9IGkgKyAxOyBrIDwgMzsgaysrKSB7CiAgICAgICAgICBjb25zdCBmYWN0b3IgPSBhdWdtZW50ZWRba11baV0gLyBhdWdtZW50ZWRbaV1baV07CiAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IDQ7IGorKykgewogICAgICAgICAgICBhdWdtZW50ZWRba11bal0gLT0gZmFjdG9yICogYXVnbWVudGVkW2ldW2pdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g5Zue5Luj5rGC6KejCiAgICAgIGNvbnN0IHNvbHV0aW9uID0gWzAsIDAsIDBdOwogICAgICBmb3IgKGxldCBpID0gMjsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBzb2x1dGlvbltpXSA9IGF1Z21lbnRlZFtpXVszXTsKICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCAzOyBqKyspIHsKICAgICAgICAgIHNvbHV0aW9uW2ldIC09IGF1Z21lbnRlZFtpXVtqXSAqIHNvbHV0aW9uW2pdOwogICAgICAgIH0KICAgICAgICBzb2x1dGlvbltpXSAvPSBhdWdtZW50ZWRbaV1baV07CiAgICAgIH0KICAgICAgCiAgICAgIHJldHVybiBzb2x1dGlvbjsKICAgIH0sCiAgICAKICAgIC8vID09PT09PT09PT09PT09PT09PT09IOa1i+ivleWSjOiwg+ivleaWueazlSA9PT09PT09PT09PT09PT09PT09PQogICAgCiAgICAvKioKICAgICAqIOa1i+ivleWQjuerr+aVsOaNruaOpeaUtuWKn+iDvQogICAgICog5qih5ouf5ZCO56uv5Y+R6YCB55qE5ouf5ZCI5pWw5o2u5p2l5rWL6K+V5YmN56uv5aSE55CGCiAgICAgKi8KICAgIHRlc3RCYWNrZW5kRGF0YVJlY2VwdGlvbigpIHsKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5byA5aeL5rWL6K+V5ZCO56uv5pWw5o2u5o6l5pS25Yqf6IO9Jyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDlvIDlp4vmtYvor5XlkI7nq6/mlbDmja7mjqXmlLblip/og70nKTsKICAgICAgCiAgICAgIC8vIOaooeaLn+WQjuerr+WPkemAgeeahOaVsOaNruagvOW8jwogICAgICBjb25zdCB0ZXN0RGF0YSA9ICJmaXRRdWFkcmF0aWNDdXJ2ZTowLjAwMDAwMTotMC4wMjo1LjA6MTU3MzEuMTM6MS45MzAiOwogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmqKHmi5/lkI7nq6/mlbDmja46JywgdGVzdERhdGEpOwogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwg5qih5ouf5ZCO56uv5pWw5o2uOicsIHRlc3REYXRhKTsKICAgICAgCiAgICAgIC8vIOiwg+eUqOaLn+WQiOaWueazlQogICAgICB0aGlzLmZpdFF1YWRyYXRpY0N1cnZlKHRlc3REYXRhKTsKICAgIH0sCiAgICAKICAgIC8qKgogICAgICog5rWL6K+V5LqM5qyh5puy57q/5ouf5ZCI5Yqf6IO9CiAgICAgKiDms6jmhI/vvJrnjrDlnKjkuLvopoHkvp3otZblkI7nq6/mi5/lkIjnu5PmnpzvvIzmraTmlrnms5Xku4XnlKjkuo7mtYvor5XliY3nq6/mi5/lkIjnrpfms5UKICAgICAqIOS9v+eUqOaooeaLn+aVsOaNrumqjOivgeaLn+WQiOeul+azleaYr+WQpuato+ehrgogICAgICovCiAgICB0ZXN0UXVhZHJhdGljRml0dGluZygpIHsKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5byA5aeL5rWL6K+V5LqM5qyh5puy57q/5ouf5ZCI5Yqf6IO9Jyk7CiAgICAgIAogICAgICAvLyDnlJ/miJDmtYvor5XmlbDmja7vvJp5ID0gMC4wMDAxICogKHggLSAzMDAwKV4yICsgMi4wCiAgICAgIGNvbnN0IHRlc3REYXRhID0gW107CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykgewogICAgICAgIGNvbnN0IHggPSAyMDAwICsgaSAqIDIwMDsgLy8g5L2N572u5LuOMjAwMOWIsDM4MDAKICAgICAgICBjb25zdCB5ID0gMC4wMDAxICogTWF0aC5wb3coeCAtIDMwMDAsIDIpICsgMi4wICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4yOyAvLyDmt7vliqDlmarlo7AKICAgICAgICB0ZXN0RGF0YS5wdXNoKFt4LCB5XSk7CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmtYvor5XmlbDmja46JywgdGVzdERhdGEpOwogICAgICAKICAgICAgLy8g5omn6KGM5ouf5ZCICiAgICAgIGNvbnN0IGZpdFJlc3VsdCA9IHRoaXMucGVyZm9ybVF1YWRyYXRpY0ZpdCh0ZXN0RGF0YSk7CiAgICAgIGlmIChmaXRSZXN1bHQpIHsKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmi5/lkIjnu5Pmnpw6JywgZml0UmVzdWx0KTsKICAgICAgICAKICAgICAgICAvLyDorqHnrpfnkIborrrmnIDkvbPkvY3nva7vvIjlupTor6XmmK8zMDAw77yJCiAgICAgICAgY29uc3QgbWluUG9zID0gTWF0aC5taW4oLi4udGVzdERhdGEubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgICAgY29uc3QgdGhlb3JldGljYWxCZXN0UG9zID0gLWZpdFJlc3VsdC5iIC8gKDIgKiBmaXRSZXN1bHQuYSkgKyBtaW5Qb3M7CiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg55CG6K665pyA5L2z5L2N572uOicsIHRoZW9yZXRpY2FsQmVzdFBvcywgJ+acn+acm+WAvDogMzAwMCcpOwogICAgICAgIAogICAgICAgIC8vIOeUn+aIkOaLn+WQiOabsue6vwogICAgICAgIHRoaXMuZ2VuZXJhdGVRdWFkcmF0aWNDdXJ2ZShmaXRSZXN1bHQuYSwgZml0UmVzdWx0LmIsIGZpdFJlc3VsdC5jLCB0aGVvcmV0aWNhbEJlc3RQb3MpOwogICAgICAgIAogICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOS6jOasoeabsue6v+aLn+WQiOa1i+ivleWujOaIkCcpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdDaGFydC1Gb2N1cy52dWUgfCDkuozmrKHmm7Lnur/mi5/lkIjmtYvor5XlpLHotKUnKTsKICAgICAgfQogICAgfSwKICAgIAogIH0KfQo="},{"version":3,"sources":["Chart-Focus.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA","file":"Chart-Focus.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div\n      ref=\"linechart\"\n      :style=\"{ width: containerMaxWidth + 'px', height: 80 + 'px' }\"\n      class=\"linechart-panel\"\n      @mousedown=\"startDrag\"\n      @mousemove=\"dragging\"\n      @mouseup=\"endDrag\"\n      @touchstart=\"startDrag\"\n      @touchmove=\"dragging\"\n      @touchend=\"endDrag\"\n    ></div>\n    \n    <!--  -->\n    <div class=\"focus-result-panel\" v-if=\"quadraticResult.show\">\n      <div class=\"panel-header\">\n        <div class=\"header-left\">\n          <div class=\"status-icon\" :class=\"{ 'success': !isHorizontalFit(), 'warning': isHorizontalFit() }\">\n            <i v-if=\"!isHorizontalFit()\" class=\"icon-check\"></i>\n            <i v-else class=\"icon-warning\"></i>\n          </div>\n          <div class=\"panel-title\"></div>\n        </div>\n        <div class=\"close-button\" @click=\"closePanel\">\n          <i class=\"icon-close\"></i>\n        </div>\n      </div>\n      <div class=\"panel-content\">\n        <div class=\"status-row\">\n          <span class=\"label\"></span>\n          <span class=\"value\" :class=\"{ 'error': isHorizontalFit() }\">{{ getBestPositionDisplay() }}</span>\n        </div>\n        <div class=\"status-row\">\n          <span class=\"label\">HFR</span>\n          <span class=\"value\">{{ quadraticResult.minHFR }}</span>\n        </div>\n        <div class=\"status-row\">\n          <span class=\"label\"></span>\n          <span class=\"value\">{{ validDataPointCount }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as echarts from 'echarts';\n\nexport default {\n  name: 'LineChart',\n  data() {\n    return {\n      containerMaxWidth: 150,\n      chartData1: [],\n      chartData2: [],\n      chartData3: [],\n      chartData4: [], // \n      xAxis_min: 0,\n      xAxis_max: 6000,\n      yAxis_min: 0,\n      yAxis_max: 30,\n      range: 4,\n      currentX: 0,\n      HFRMax: 0,\n      isDragging: false,\n      startX: 0,\n      deltaX: 0,\n      x_min: -60000,\n      x_max: 60000,\n      quadraticResult: {\n        show: false,\n        a: 0,\n        b: 0,\n        c: 0,\n        bestPosition: 0,\n        minHFR: 0\n      },\n      logger: null // \n    };\n  },\n  computed: {\n    validDataPointCount() {\n      // 0HFR0\n      return this.chartData1.filter(point => \n        point[0] > 0 && point[1] > 0\n      ).length;\n    },\n    \n    // \n    cleanDataPoints() {\n      return this.unifiedOutlierDetection(this.chartData1);\n    },\n    \n    // \n    outlierDataPoints() {\n      const cleanData = this.unifiedOutlierDetection(this.chartData1);\n      return this.chartData1.filter(point => \n        !cleanData.some(cleanPoint => \n          cleanPoint[0] === point[0] && cleanPoint[1] === point[1]\n        )\n      );\n    }\n  },\n  mounted() {\n    // logger\n    this.initLogger();\n    \n    // \n    if (process.env.NODE_ENV === 'development') {\n      // \n      setTimeout(() => {\n        this.logger.info('Chart-Focus.vue | ');\n        this.testQuadraticFitting();\n      }, 1000);\n    }\n  },\n  created() {\n    this.$bus.$on('FocusPosition', this.changeRange_x);\n    // this.$bus.$on('UpdateHFR', this.UpdateHFR);\n    this.$bus.$on('fitQuadraticCurve', this.fitQuadraticCurve);\n    this.$bus.$on('fitQuadraticCurve_minPoint', this.fitQuadraticCurve_minPoint);\n\n    this.$bus.$on('ClearfitQuadraticCurve', this.clearChartData2);\n    this.$bus.$on('ClearAllData', this.ClearAllData);\n    this.$bus.$on('ClearFineData', this.ClearFineData);\n    this.$bus.$on('updateFocusChartWidth', this.initChart);\n    this.$bus.$on('addData_Point', this.addData_Point);\n    this.$bus.$on('addMinPointData_Point', this.addMinPointData_Point);\n    this.$bus.$on('addLineData_Point', this.addLineData_Point);\n    this.$bus.$on('setFocusChartRange', this.setFocusChartRange);\n  },\n  methods: {\n    // logger\n    initLogger() {\n      this.logger = {\n        info: (message, ...args) => {\n          console.log(`[INFO] ${message}`, ...args);\n        },\n        warn: (message, ...args) => {\n          console.warn(`[WARN] ${message}`, ...args);\n        },\n        error: (message, ...args) => {\n          console.error(`[ERROR] ${message}`, ...args);\n        },\n        debug: (message, ...args) => {\n          if (process.env.NODE_ENV === 'development') {\n            console.debug(`[DEBUG] ${message}`, ...args);\n          }\n        }\n      };\n    },\n    \n    // \n    validateFitCoefficients(a, b, c) {\n      // \n      if (!isFinite(a) || !isFinite(b) || !isFinite(c)) {\n        this.logger.warn(' (NaN/Infinity)');\n        return false;\n      }\n      \n      // \n      if (Math.abs(a) < 1e-6 && Math.abs(b) < 1e-6) {\n        this.logger.warn(' (a0, b0)');\n        return false;\n      }\n      \n      // \n      if (Math.abs(a) < 1e-10) {\n        this.logger.warn('');\n        return false;\n      }\n      \n      return true;\n    },\n    \n    // \n    // C++\n    unifiedOutlierDetection(dataPoints) {\n      if (dataPoints.length < 4) {\n        return dataPoints;\n      }\n      \n      this.logger.info('Chart-Focus.vue | :', dataPoints.length);\n      \n      // HFRIQR\n      const cleanData = this.removeOutliersByIQR(dataPoints);\n      \n      // \n      if (cleanData.length >= 4) {\n        const residualCleanData = this.removeOutliersByResidual(cleanData);\n        \n        // \n        if (residualCleanData.length >= 3) {\n          this.logger.info('Chart-Focus.vue | ', residualCleanData.length, '');\n          return residualCleanData;\n        }\n      }\n      \n      this.logger.info('Chart-Focus.vue | IQR', cleanData.length, '');\n      return cleanData;\n    },\n    \n    // \n    validateFitConsistency(backendCoefficients, frontendCoefficients) {\n      const tolerance = 1e-6; // \n      \n      const aDiff = Math.abs(backendCoefficients.a - frontendCoefficients.a);\n      const bDiff = Math.abs(backendCoefficients.b - frontendCoefficients.b);\n      const cDiff = Math.abs(backendCoefficients.c - frontendCoefficients.c);\n      \n      this.logger.info('Chart-Focus.vue | :', {\n        backend: backendCoefficients,\n        frontend: frontendCoefficients,\n        differences: { a: aDiff, b: bDiff, c: cDiff }\n      });\n      \n      const isConsistent = aDiff < tolerance && bDiff < tolerance && cDiff < tolerance;\n      \n      if (isConsistent) {\n        this.logger.info('Chart-Focus.vue | ');\n      } else {\n        this.logger.warn('Chart-Focus.vue | ');\n      }\n      \n      return isConsistent;\n    },\n    \n    // \n    closePanel() {\n      this.quadraticResult.show = false;\n    },\n    \n    // \n    isHorizontalFit() {\n      const a = parseFloat(this.quadraticResult.a);\n      const b = parseFloat(this.quadraticResult.b);\n      return Math.abs(a) < 1e-6 && Math.abs(b) < 1e-6;\n    },\n    \n    // \n    getBestPositionDisplay() {\n      // ab0\n      const a = parseFloat(this.quadraticResult.a);\n      const b = parseFloat(this.quadraticResult.b);\n      \n      this.logger.debug('Chart-Focus.vue | :', { a, b, bestPosition: this.quadraticResult.bestPosition });\n      \n      // ab0\n      if (this.isHorizontalFit()) {\n        this.logger.warn('Chart-Focus.vue | \"\"');\n        return \"\";\n      }\n      \n      // \n      return this.quadraticResult.bestPosition;\n    },\n    \n    initChart(Width) {\n      this.containerMaxWidth = Width - 95;\n      const chartDom = this.$refs.linechart;\n      chartDom.style.width = this.containerMaxWidth + 'px';\n      this.myChart = echarts.init(chartDom);\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    startDrag(event) {\n      this.isDragging = true;\n      // \n      if (event.touches && event.touches.length > 0) {\n        this.startX = event.touches[0].clientX;\n      } else {\n        this.startX = event.clientX;\n      }\n    },\n    dragging(event) {\n      if (this.isDragging) {\n        // \n        let clientX;\n        if (event.touches && event.touches.length > 0) {\n          clientX = event.touches[0].clientX;\n        } else {\n          clientX = event.clientX;\n        }\n        \n        this.deltaX = (clientX - this.startX) * 10;\n        this.startX = clientX;\n        this.xAxis_min -= this.deltaX;\n        this.xAxis_max -= this.deltaX;\n        this.renderChart(this.xAxis_min, this.xAxis_max);\n      }\n    },\n    endDrag() {\n      this.isDragging = false;\n      this.deltaX = 0;\n      // this.$bus.$emit('setTargetPosition', (this.xAxis_min + this.xAxis_max) / 2);\n    },\n    renderChart(lowerBound, upperBound) {\n      // Y\n      let allYValues = [];\n      if (this.chartData1.length > 0) allYValues = allYValues.concat(this.chartData1.map(item => item[1]));\n      if (this.chartData2.length > 0) allYValues = allYValues.concat(this.chartData2.map(item => item[1]));\n      if (this.chartData3.length > 0) allYValues = allYValues.concat(this.chartData3.map(item => item[1]));\n      if (this.chartData4.length > 0) allYValues = allYValues.concat(this.chartData4.map(item => item[1]));\n      \n      const y_max = allYValues.length > 0 ? Math.max(...allYValues) * 1.2 : this.yAxis_max;\n      const y_min = allYValues.length > 0 ? Math.min(...allYValues) * 0.8 : this.yAxis_min;\n      \n      this.logger.debug('Chart-Focus.vue | :', {\n        lowerBound, upperBound, y_min, y_max,\n        data1: this.chartData1.length,\n        data2: this.chartData2.length,\n        data3: this.chartData3.length\n      });\n      \n      const option = {\n        grid: {\n          left: '0%',\n          right: '2%',\n          bottom: '0%',\n          top: '10%',\n          containLabel: true\n        },\n        xAxis: {\n          min: lowerBound,\n          max: upperBound,\n          axisLine: {\n            lineStyle: {\n              color: 'rgba(200, 200, 200, 0.5)'  // x\n            }\n          },\n          axisLabel: {\n            color: 'white',\n            fontSize: 5\n          },\n          splitLine: {\n            show: true,\n            lineStyle: {\n              color: 'rgba(128, 128, 128, 0.5)', \n              width: 1,\n              type: 'solid'\n            }\n          }\n        },\n        yAxis: {\n          min: y_min,\n          max: y_max,\n          axisLine: {\n            lineStyle: {\n              color: 'rgba(200, 200, 200, 0.5)'  // y\n            }\n          },\n          axisLabel: {\n            color: 'white',\n            fontSize: 5\n          },\n          splitNumber: 3,\n          splitLine: {\n            show: true,\n            lineStyle: {\n              color: 'rgba(128, 128, 128, 0.5)',\n              width: 1,\n              type: 'solid'\n            }\n          }\n        },\n        series: [\n          {\n            name: 'HFR',\n            type: 'scatter',\n            data: this.chartData1,\n            itemStyle: {\n              color: 'red',\n              borderColor: 'white',\n              borderWidth: 1\n            },\n            symbolSize: 8\n          },\n          {\n            name: 'QuadraticCurve',\n            type: 'line',\n            data: this.chartData2,\n            itemStyle: {\n              color: 'yellow'\n            },\n            lineStyle: {\n              width: 3,\n              type: 'solid'\n            },\n            symbolSize: 0,\n            smooth: false\n          },\n          {\n            name: 'minPoint',\n            type: 'scatter',\n            data: this.chartData3,\n            itemStyle: {\n              color: 'rgba(75, 155, 250, 0.7)'\n            },\n            symbolSize: 4\n          },\n          {\n            name: 'xMinLine',\n            type: 'line',\n            data: [\n              [this.x_min, this.yAxis_min],\n              [this.x_min, y_max]\n            ],\n            lineStyle: {\n              color: 'red',\n              width: 1\n            },\n            symbol: 'none'\n          },\n          {\n            name: 'xMaxLine',\n            type: 'line',\n            data: [\n              [this.x_max, this.yAxis_min],\n              [this.x_max, y_max]\n            ],\n            lineStyle: {\n              color: 'red',\n              width: 1\n            },\n            symbol: 'none'\n          },\n          {\n            name: 'currentPosition',\n            type: 'line',\n            data: [\n              [this.currentX, this.yAxis_min],\n              [this.currentX, y_max]\n            ],\n            lineStyle: {\n              color: 'green',\n              width: 1\n            },\n            symbol: 'none'\n          },\n          {\n            name: 'Outliers',\n            type: 'scatter',\n            data: this.chartData4,\n            itemStyle: {\n              color: 'rgba(255, 0, 255, 0.8)',\n              borderColor: 'white',\n              borderWidth: 2\n            },\n            symbolSize: 12,\n            symbol: 'diamond'\n          }\n        ]\n      };\n      this.myChart.setOption(option);\n    },\n    addData_Point(x,y) {\n      this.logger.info('Chart-Focus.vue | :', { x, y });\n      \n      // HFR100\n      if (y >= 100) {\n        this.logger.warn('Chart-Focus.vue | HFR(>=100):', { x, y });\n        return;\n      }\n      \n      const newDataPoint = [x, y];\n      const existingPointIndex = this.chartData1.findIndex(point => point[0] === newDataPoint[0]);\n      if (existingPointIndex !== -1) {\n        // If the x value already exists, update the y value\n        if (newDataPoint[1] == 0 || newDataPoint[1] == this.chartData1[existingPointIndex][1]) {\n          this.logger.debug('Chart-Focus.vue | :', newDataPoint);\n          return;\n        }\n        this.chartData1[existingPointIndex] = newDataPoint;\n        this.logger.info('Chart-Focus.vue | :', newDataPoint);\n      } else {\n        // If the x value does not exist, add the new data point\n        this.chartData1.push(newDataPoint);\n        this.logger.info('Chart-Focus.vue | :', newDataPoint);\n      }\n      \n      this.logger.debug('Chart-Focus.vue | :', this.chartData1.length);\n      this.logger.debug('Chart-Focus.vue | :', this.chartData1);\n      \n      // \n      this.updateOutlierData();\n      \n      // \n      if (this.quadraticResult.show) {\n        const a = parseFloat(this.quadraticResult.a);\n        const b = parseFloat(this.quadraticResult.b);\n        const c = parseFloat(this.quadraticResult.c);\n        const bestPosition = parseFloat(this.quadraticResult.bestPosition);\n        \n        if (Math.abs(a) < 1e-10) {\n          // \n          this.logger.info('Chart-Focus.vue | ');\n          this.generateLinearCurve(b, c, bestPosition);\n        } else {\n          // \n          this.logger.info('Chart-Focus.vue | ');\n          this.generateQuadraticCurve(a, b, c, bestPosition);\n        }\n      } else {\n        this.renderChart(this.xAxis_min, this.xAxis_max);\n      }\n    },\n    // \n    addLineData_Point(dataList) {\n      this.chartData2 = dataList;\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    addMinPointData_Point(x,y) {\n      const newDataPoint = [x, y];\n      this.chartData3.push(newDataPoint);\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    // x\n    changeRange_x(current, target) {\n      const newCurrentX = Number(current);\n      \n      // \n      if (Math.abs(newCurrentX - this.currentX) > 1) {\n        this.currentX = newCurrentX;\n        \n        // X\n        const newXAxisMin = newCurrentX - 3000;\n        const newXAxisMax = newCurrentX + 3000;\n        \n        // X\n        if (newCurrentX < this.xAxis_min + 1000 || newCurrentX > this.xAxis_max - 1000) {\n          this.xAxis_min = newXAxisMin;\n          this.xAxis_max = newXAxisMax;\n          this.logger.debug(\"Chart-Focus.vue | X:\", newCurrentX, this.xAxis_min, this.xAxis_max);\n          this.renderChart(this.xAxis_min, this.xAxis_max);\n        } else {\n          // \n          this.updateCurrentPositionLine();\n        }\n      }\n    },\n    \n    // \n    updateCurrentPositionLine() {\n      if (this.myChart) {\n        // Y\n        let allYValues = [];\n        if (this.chartData1.length > 0) allYValues = allYValues.concat(this.chartData1.map(item => item[1]));\n        if (this.chartData2.length > 0) allYValues = allYValues.concat(this.chartData2.map(item => item[1]));\n        if (this.chartData3.length > 0) allYValues = allYValues.concat(this.chartData3.map(item => item[1]));\n        \n        const y_max = allYValues.length > 0 ? Math.max(...allYValues) * 1.2 : this.yAxis_max;\n        const y_min = allYValues.length > 0 ? Math.min(...allYValues) * 0.8 : this.yAxis_min;\n        \n        // currentPosition\n        this.myChart.setOption({\n          series: [{\n            name: 'currentPosition',\n            type: 'line',\n            data: [\n              [this.currentX, y_min],\n              [this.currentX, y_max]\n            ],\n            lineStyle: {\n              color: 'green',\n              width: 1\n            },\n            symbol: 'none'\n          }]\n        }, false); // false\n      }\n    },\n\n    // \n    clearChartData1() {\n      this.chartData1 = [];\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    clearChartData2() {\n      this.chartData2 = [];\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    ClearAllData() {\n      // \n      this.chartData1 = [];\n      this.chartData2 = [];\n      this.chartData3 = [];\n      this.chartData4 = [];\n      this.quadraticResult.show = false;\n      this.yAxis_max = 30;\n      this.HFRMax = 15;\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    \n    // \n    ClearFineData() {\n      this.logger.info('Chart-Focus.vue | ');\n      this.chartData1 = [];\n      this.chartData2 = [];\n      this.chartData3 = [];\n      this.chartData4 = [];\n      this.quadraticResult.show = false;\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    \n    // \n    updateOutlierData() {\n      if (this.chartData1.length >= 4) {\n        this.chartData4 = this.outlierDataPoints;\n        this.logger.debug('Chart-Focus.vue | :', this.chartData4.length);\n      } else {\n        this.chartData4 = [];\n      }\n    },\n    // \n    RangeSwitch() {\n      if (this.range === 4) {\n        this.range = 2;\n        this.yAxis_min = -2;\n        this.yAxis_max = 2;\n      } else if (this.range === 2) {\n        this.range = 1;\n        this.yAxis_min = -1;\n        this.yAxis_max = 1;\n      } else if (this.range === 1) {\n        this.range = 4;\n        this.yAxis_min = -4;\n        this.yAxis_max = 4;\n      }\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    // HFR\n    // UpdateHFR(HFR) {\n    //   const newDataPoint = [this.currentX, HFR];\n    //   this.addData_Point(newDataPoint);\n    //   // console.log(\"QHYCCD | UpdateHFR:\", newDataPoint);\n    //   // this.$bus.$emit('SendConsoleLogMsg', 'UpdateHFR:' + newDataPoint, 'info');\n    //   this.renderChart(this.xAxis_min, this.xAxis_max);\n    // },\n    // \n    fitQuadraticCurve(dataString) {\n      this.logger.info('Chart-Focus.vue | :', dataString);\n      console.log('Chart-Focus.vue | :', dataString);\n      \n      const parts = dataString.split(':');\n      this.logger.info('Chart-Focus.vue | :', parts);\n      console.log('Chart-Focus.vue | :', parts);\n      \n      if (parts.length >= 6) {\n        const a = parseFloat(parts[1]);\n        const b = parseFloat(parts[2]);\n        const c = parseFloat(parts[3]);\n        const bestPosition = parseFloat(parts[4]);\n        const minHFR = parseFloat(parts[5]);\n        \n        this.logger.info('Chart-Focus.vue | :', { a, b, c, bestPosition, minHFR });\n        console.log('Chart-Focus.vue | :', { a, b, c, bestPosition, minHFR });\n        console.log('Chart-Focus.vue | :', parts);\n        \n        // \n        if (!this.validateFitCoefficients(a, b, c)) {\n          this.logger.warn('Chart-Focus.vue | ');\n        }\n        \n        // \n        this.logger.info('Chart-Focus.vue | ');\n        console.log('Chart-Focus.vue | ');\n        \n        // \n        if (Math.abs(a) < 1e-10) {\n          this.logger.warn('Chart-Focus.vue | a0');\n          console.warn('Chart-Focus.vue | a0');\n          \n          // \n          this.generateLinearCurve(b, c, bestPosition);\n          \n          // \n          this.quadraticResult.a = \"0.000000\"; // 0\n          this.quadraticResult.b = b.toFixed(6);\n          this.quadraticResult.c = c.toFixed(6);\n          this.quadraticResult.bestPosition = \"\";\n          this.quadraticResult.minHFR = minHFR.toFixed(3);\n          this.quadraticResult.show = true;\n          \n          return; // \n        }\n        \n        // \n        this.quadraticResult.a = a.toFixed(6);\n        this.quadraticResult.b = b.toFixed(6);\n        this.quadraticResult.c = c.toFixed(6);\n        this.quadraticResult.bestPosition = bestPosition.toFixed(2);\n        this.quadraticResult.minHFR = minHFR.toFixed(3);\n        this.quadraticResult.show = true;\n        \n        this.logger.info('Chart-Focus.vue | :', this.quadraticResult);\n        \n        // \n        this.generateQuadraticCurve(a, b, c, bestPosition);\n        \n        // \n        this.updateOutlierData();\n        \n        this.logger.info('Chart-Focus.vue | :', this.quadraticResult);\n      } else {\n        this.logger.error('Chart-Focus.vue | :', parts.length);\n      }\n    },\n    \n    // \n    generateQuadraticCurve(a, b, c, bestPosition) {\n      this.logger.info('Chart-Focus.vue | :', { a, b, c, bestPosition });\n      \n      // abc\n      // \n      \n      // bestPositionminPos\n      let minPos = 0;\n      if (this.chartData1.length > 0) {\n        minPos = Math.min(...this.chartData1.map(point => point[0]));\n      }\n      \n      this.logger.debug('Chart-Focus.vue | :');\n      this.logger.debug('Chart-Focus.vue | -  (minPos):', minPos);\n      this.logger.debug('Chart-Focus.vue | -  (bestPosition):', bestPosition);\n      this.logger.debug('Chart-Focus.vue | -  a:', a, 'b:', b, 'c:', c);\n      \n      console.log('Chart-Focus.vue | :');\n      console.log('Chart-Focus.vue | -  (minPos):', minPos);\n      console.log('Chart-Focus.vue | -  (bestPosition):', bestPosition);\n      console.log('Chart-Focus.vue | -  a:', a, 'b:', b, 'c:', c);\n      console.log('Chart-Focus.vue | - :', this.chartData1);\n      \n      // \n      const expectedBestRelativePos = -b / (2 * a);\n      const expectedBestAbsolutePos = expectedBestRelativePos + minPos;\n      this.logger.debug('Chart-Focus.vue | - :', expectedBestRelativePos);\n      this.logger.debug('Chart-Focus.vue | - :', expectedBestAbsolutePos);\n      this.logger.debug('Chart-Focus.vue | - :', Math.abs(expectedBestAbsolutePos - bestPosition));\n      \n      const curveData = [];\n      \n      // \n      let startX, endX, stepSize;\n      \n      if (this.chartData1.length > 0) {\n        // \n        const dataMinX = Math.min(...this.chartData1.map(point => point[0]));\n        const dataMaxX = Math.max(...this.chartData1.map(point => point[0]));\n        const dataRange = dataMaxX - dataMinX;\n        \n        // \n        const extension = Math.max(dataRange * 0.2, 1000); // 20%1000\n        startX = dataMinX - extension;\n        endX = dataMaxX + extension;\n        \n        // \n        stepSize = Math.max(Math.floor(dataRange / 100), 20); // 10020\n      } else {\n        // \n        const range = 5000;\n        startX = bestPosition - range;\n        endX = bestPosition + range;\n        stepSize = 50;\n      }\n      \n      // X\n      startX = Math.min(startX, this.xAxis_min);\n      endX = Math.max(endX, this.xAxis_max);\n      \n      this.logger.debug('Chart-Focus.vue | :', startX, '', endX, ':', stepSize);\n      \n      // \n      for (let x = startX; x <= endX; x += stepSize) {\n        // \n        const relativeX = x - minPos;\n        const y = a * relativeX * relativeX + b * relativeX + c;\n        \n        // \n        if (isFinite(y) && y >= 0) {\n          curveData.push([x, y]);\n        } else {\n          this.logger.warn('Chart-Focus.vue | Y:', y, ':', x, ':', relativeX);\n        }\n      }\n      \n      // \n      if (this.chartData1.length > 0) {\n        for (const point of this.chartData1) {\n          const x = point[0];\n          const relativeX = x - minPos;\n          const y = a * relativeX * relativeX + b * relativeX + c;\n          \n          if (isFinite(y) && y >= 0) {\n            // \n            const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - x) < stepSize / 2);\n            if (!exists) {\n              curveData.push([x, y]);\n            }\n          }\n        }\n        \n        // \n        const bestRelativeX = bestPosition - minPos;\n        const bestY = a * bestRelativeX * bestRelativeX + b * bestRelativeX + c;\n        if (isFinite(bestY) && bestY >= 0) {\n          const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - bestPosition) < stepSize / 2);\n          if (!exists) {\n            curveData.push([bestPosition, bestY]);\n          }\n          \n          // \n          const fineRange = Math.max(stepSize * 2, 200); // 200\n          const fineStep = Math.max(stepSize / 10, 5);\n          for (let offset = -fineRange; offset <= fineRange; offset += fineStep) {\n            const x = bestPosition + offset;\n            if (x >= startX && x <= endX) {\n              const relativeX = x - minPos;\n              const y = a * relativeX * relativeX + b * relativeX + c;\n              if (isFinite(y) && y >= 0) {\n                const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - x) < fineStep / 2);\n                if (!exists) {\n                  curveData.push([x, y]);\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      // X\n      curveData.sort((a, b) => a[0] - b[0]);\n      \n      // \n      if (this.chartData1.length > 0) {\n        const enhancedCurveData = [];\n        const fineStepSize = Math.max(stepSize / 5, 5); // \n        \n        for (let i = 0; i < curveData.length - 1; i++) {\n          const currentPoint = curveData[i];\n          const nextPoint = curveData[i + 1];\n          \n          enhancedCurveData.push(currentPoint);\n          \n          // \n          const hasDataPoint = this.chartData1.some(point => \n            point[0] >= currentPoint[0] && point[0] <= nextPoint[0]\n          );\n          \n          // \n          if (hasDataPoint && (nextPoint[0] - currentPoint[0]) > fineStepSize) {\n            const midPoints = Math.floor((nextPoint[0] - currentPoint[0]) / fineStepSize);\n            for (let j = 1; j < midPoints; j++) {\n              const x = currentPoint[0] + (j * fineStepSize);\n              const relativeX = x - minPos;\n              const y = a * relativeX * relativeX + b * relativeX + c;\n              if (isFinite(y) && y >= 0) {\n                enhancedCurveData.push([x, y]);\n              }\n            }\n          }\n        }\n        \n        // \n        if (curveData.length > 0) {\n          enhancedCurveData.push(curveData[curveData.length - 1]);\n        }\n        \n        // \n        curveData.length = 0;\n        curveData.push(...enhancedCurveData);\n      }\n      \n      // \n      if (curveData.length > 0) {\n        // Y\n        const bestPointY = a * (bestPosition - minPos) * (bestPosition - minPos) + b * (bestPosition - minPos) + c;\n        this.logger.debug('Chart-Focus.vue | :');\n        this.logger.debug('Chart-Focus.vue | - :', bestPosition);\n        this.logger.debug('Chart-Focus.vue | - :', bestPosition - minPos);\n        this.logger.debug('Chart-Focus.vue | - Y:', bestPointY);\n        \n        // \n        this.logger.debug('Chart-Focus.vue | :');\n        for (let i = 0; i < Math.min(this.chartData1.length, 5); i++) {\n          const point = this.chartData1[i];\n          const pointRelativeX = point[0] - minPos;\n          const pointY = a * pointRelativeX * pointRelativeX + b * pointRelativeX + c;\n          const actualY = point[1];\n          const diff = Math.abs(pointY - actualY);\n          this.logger.debug(`Chart-Focus.vue | - ${i}: =${point[0]}, HFR=${actualY}, HFR=${pointY}, =${diff}`);\n        }\n      }\n      \n      this.logger.debug('Chart-Focus.vue | :', curveData.length);\n      this.logger.debug('Chart-Focus.vue | X:', startX, '', endX);\n      this.logger.debug('Chart-Focus.vue | 5:', curveData.slice(0, 5));\n      this.logger.debug('Chart-Focus.vue | 5:', curveData.slice(-5));\n      \n      // \n      if (curveData.length > 0) {\n        const firstY = curveData[0][1];\n        const lastY = curveData[curveData.length - 1][1];\n        const middleIndex = Math.floor(curveData.length / 2);\n        const middleY = curveData[middleIndex][1];\n        \n        this.logger.debug('Chart-Focus.vue |  - Y:', firstY, 'Y:', middleY, 'Y:', lastY);\n        \n        // \n        if (Math.abs(a) > 1e-10) {\n          const vertexX = -b / (2 * a) + minPos; // X\n          const vertexY = c - (b * b) / (4 * a); // Y\n          this.logger.debug('Chart-Focus.vue | :', vertexX, 'Y:', vertexY);\n        }\n      }\n      \n      // \n      const finalCurveData = curveData.filter(point => {\n        const [x, y] = point;\n        return isFinite(x) && isFinite(y) && y >= 0 && x >= startX && x <= endX;\n      });\n      \n      // X\n      finalCurveData.sort((a, b) => a[0] - b[0]);\n      \n      this.logger.debug('Chart-Focus.vue | :');\n      this.logger.debug('Chart-Focus.vue | - :', curveData.length);\n      this.logger.debug('Chart-Focus.vue | - :', finalCurveData.length);\n      this.logger.debug('Chart-Focus.vue | - X:', finalCurveData.length > 0 ? `${finalCurveData[0][0]}  ${finalCurveData[finalCurveData.length - 1][0]}` : '');\n      \n      this.chartData2 = finalCurveData;\n      this.logger.debug('Chart-Focus.vue | chartData2:', this.chartData2.length);\n      \n      // X\n      if (finalCurveData.length > 0) {\n        this.xAxis_min = Math.min(this.xAxis_min, finalCurveData[0][0]);\n        this.xAxis_max = Math.max(this.xAxis_max, finalCurveData[finalCurveData.length - 1][0]);\n      }\n      \n      this.renderChart(this.xAxis_min, this.xAxis_max);\n      \n      this.logger.info('Chart-Focus.vue | ');\n    },\n    \n    // a=0\n    generateLinearCurve(b, c, bestPosition) {\n      this.logger.info('Chart-Focus.vue | :', { b, c, bestPosition });\n      console.log('Chart-Focus.vue | :', { b, c, bestPosition });\n      \n      // \n      let minPos = 0;\n      if (this.chartData1.length > 0) {\n        minPos = Math.min(...this.chartData1.map(point => point[0]));\n      }\n      \n      this.logger.debug('Chart-Focus.vue | :');\n      this.logger.debug('Chart-Focus.vue | -  (minPos):', minPos);\n      this.logger.debug('Chart-Focus.vue | -  b:', b, 'c:', c);\n      \n      console.log('Chart-Focus.vue | :');\n      console.log('Chart-Focus.vue | -  (minPos):', minPos);\n      console.log('Chart-Focus.vue | -  b:', b, 'c:', c);\n      \n      const curveData = [];\n      \n      // \n      let startX, endX, stepSize;\n      \n      if (this.chartData1.length > 0) {\n        // \n        const dataMinX = Math.min(...this.chartData1.map(point => point[0]));\n        const dataMaxX = Math.max(...this.chartData1.map(point => point[0]));\n        const dataRange = dataMaxX - dataMinX;\n        \n        // \n        const extension = Math.max(dataRange * 0.2, 1000);\n        startX = dataMinX - extension;\n        endX = dataMaxX + extension;\n        \n        // \n        stepSize = Math.max(Math.floor(dataRange / 100), 20);\n      } else {\n        // \n        const range = 5000;\n        startX = bestPosition - range;\n        endX = bestPosition + range;\n        stepSize = 50;\n      }\n      \n      // X\n      startX = Math.min(startX, this.xAxis_min);\n      endX = Math.max(endX, this.xAxis_max);\n      \n      this.logger.debug('Chart-Focus.vue | :', startX, '', endX, ':', stepSize);\n      \n      // \n      for (let x = startX; x <= endX; x += stepSize) {\n        // \n        const relativeX = x - minPos;\n        const y = b * relativeX + c; // y = bx + c\n        \n        // \n        if (isFinite(y) && y >= 0) {\n          curveData.push([x, y]);\n        } else {\n          this.logger.warn('Chart-Focus.vue | Y:', y, ':', x, ':', relativeX);\n        }\n      }\n      \n      // \n      if (this.chartData1.length > 0) {\n        for (const point of this.chartData1) {\n          const x = point[0];\n          const relativeX = x - minPos;\n          const y = b * relativeX + c;\n          \n          if (isFinite(y) && y >= 0) {\n            // \n            const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - x) < stepSize / 2);\n            if (!exists) {\n              curveData.push([x, y]);\n            }\n          }\n        }\n      }\n      \n      // X\n      curveData.sort((a, b) => a[0] - b[0]);\n      \n      // \n      const finalCurveData = curveData.filter(point => {\n        const [x, y] = point;\n        return isFinite(x) && isFinite(y) && y >= 0 && x >= startX && x <= endX;\n      });\n      \n      this.logger.debug('Chart-Focus.vue | :');\n      this.logger.debug('Chart-Focus.vue | - :', curveData.length);\n      this.logger.debug('Chart-Focus.vue | - :', finalCurveData.length);\n      \n      this.chartData2 = finalCurveData;\n      this.logger.debug('Chart-Focus.vue | chartData2:', this.chartData2.length);\n      \n      // X\n      if (finalCurveData.length > 0) {\n        this.xAxis_min = Math.min(this.xAxis_min, finalCurveData[0][0]);\n        this.xAxis_max = Math.max(this.xAxis_max, finalCurveData[finalCurveData.length - 1][0]);\n      }\n      \n      this.renderChart(this.xAxis_min, this.xAxis_max);\n      \n      this.logger.info('Chart-Focus.vue | ');\n    },\n    \n    // \n    fitQuadraticCurve_minPoint(dataString) {\n      this.logger.info('Chart-Focus.vue | :', dataString);\n      \n      const parts = dataString.split(':');\n      if (parts.length >= 3) {\n        const bestPosition = parseFloat(parts[1]);\n        const minHFR = parseFloat(parts[2]);\n        \n        // \n        this.quadraticResult.bestPosition = bestPosition.toFixed(2);\n        this.quadraticResult.minHFR = minHFR.toFixed(3);\n        this.quadraticResult.show = true;\n        \n        // \n        this.chartData3 = [];\n        this.chartData3.push([bestPosition, minHFR]);\n        this.renderChart(this.xAxis_min, this.xAxis_max);\n        \n        this.logger.info('Chart-Focus.vue | :', { bestPosition, minHFR });\n      }\n    },\n    setFocusChartRange(lowerBound, upperBound) {\n      this.x_min = lowerBound;\n      this.x_max = upperBound;\n    },\n    \n    // ====================  ====================\n    \n    /**\n     * \n     * \n     */\n    removeOutliers(dataPoints) {\n      if (dataPoints.length < 4) {\n        return dataPoints; // \n      }\n      \n      this.logger.info('Chart-Focus.vue | :', dataPoints.length);\n      \n      // 1\n      const cleanData1 = this.removeOutliersByResidual(dataPoints);\n      \n      // 2HFRIQR\n      const cleanData2 = this.removeOutliersByIQR(dataPoints);\n      \n      // 3\n      const cleanData3 = this.removeOutliersByPosition(dataPoints);\n      \n      // 3\n      let bestCleanData = cleanData1;\n      if (cleanData2.length > bestCleanData.length && cleanData2.length >= 3) {\n        bestCleanData = cleanData2;\n      }\n      if (cleanData3.length > bestCleanData.length && cleanData3.length >= 3) {\n        bestCleanData = cleanData3;\n      }\n      \n      // \n      if (bestCleanData.length < 3) {\n        this.logger.warn('Chart-Focus.vue | ');\n        bestCleanData = cleanData2; // IQR\n        if (bestCleanData.length < 3) {\n          bestCleanData = dataPoints; // \n        }\n      }\n      \n      this.logger.info('Chart-Focus.vue | : ', dataPoints.length, '', bestCleanData.length, '');\n      \n      return bestCleanData;\n    },\n    \n    /**\n     * \n     * \n     */\n    removeOutliersByResidual(dataPoints) {\n      if (dataPoints.length < 4) {\n        return dataPoints; // 4\n      }\n      \n      // IQR\n      const preliminaryClean = this.removeOutliersByIQR(dataPoints);\n      if (preliminaryClean.length < 3) {\n        return dataPoints;\n      }\n      \n      // IQR\n      this.logger.info('Chart-Focus.vue | IQR');\n      return preliminaryClean;\n    },\n    \n    /**\n     * HFRIQR\n     */\n    removeOutliersByIQR(dataPoints) {\n      // HFR\n      const hfrValues = dataPoints.map(point => point[1]);\n      \n      // \n      const sortedHfrValues = [...hfrValues].sort((a, b) => a - b);\n      \n      // \n      const n = sortedHfrValues.length;\n      const q1 = sortedHfrValues[Math.floor(n / 4)];\n      const q3 = sortedHfrValues[Math.floor(3 * n / 4)];\n      const iqr = q3 - q1;\n      \n      // 2IQR1.5\n      const lowerBound = q1 - 2.0 * iqr;\n      const upperBound = q3 + 2.0 * iqr;\n      \n      // \n      const cleanData = dataPoints.filter(point => \n        point[1] >= lowerBound && point[1] <= upperBound\n      );\n      \n      this.logger.info('Chart-Focus.vue | IQR: ', dataPoints.length, '', cleanData.length, '');\n      \n      return cleanData;\n    },\n    \n    /**\n     * \n     */\n    removeOutliersByPosition(dataPoints) {\n      if (dataPoints.length < 4) {\n        return dataPoints;\n      }\n      \n      // \n      const sortedData = [...dataPoints].sort((a, b) => a[0] - b[0]);\n      \n      // \n      const distances = [];\n      for (let i = 1; i < sortedData.length; i++) {\n        const dist = sortedData[i][0] - sortedData[i-1][0];\n        distances.push(dist);\n      }\n      \n      // \n      const sortedDistances = [...distances].sort((a, b) => a - b);\n      const n = sortedDistances.length;\n      const medianDistance = sortedDistances[Math.floor(n / 2)];\n      const q3 = sortedDistances[Math.floor(3 * n / 4)];\n      const threshold = q3 + 1.5 * (q3 - medianDistance);\n      \n      // \n      const cleanData = [];\n      cleanData.push(sortedData[0]); // \n      \n      for (let i = 1; i < sortedData.length; i++) {\n        const dist = sortedData[i][0] - sortedData[i-1][0];\n        if (dist <= threshold) {\n          cleanData.push(sortedData[i]);\n        } else {\n          // \n          let isIsolated = true;\n          if (i > 1) {\n            const prevDist = sortedData[i-1][0] - sortedData[i-2][0];\n            if (prevDist <= threshold) isIsolated = false;\n          }\n          if (i < sortedData.length - 1) {\n            const nextDist = sortedData[i+1][0] - sortedData[i][0];\n            if (nextDist <= threshold) isIsolated = false;\n          }\n          \n          if (!isIsolated) {\n            cleanData.push(sortedData[i]);\n          }\n        }\n      }\n      \n      this.logger.info('Chart-Focus.vue | : ', dataPoints.length, '', cleanData.length, '');\n      \n      return cleanData;\n    },\n    \n    /**\n     * \n     * \n     *  {a, b, c}\n     */\n    performQuadraticFit(dataPoints) {\n      if (dataPoints.length < 3) {\n        return null;\n      }\n      \n      this.logger.info('Chart-Focus.vue | :', dataPoints.length);\n      \n      // \n      const minPos = Math.min(...dataPoints.map(point => point[0]));\n      this.logger.debug('Chart-Focus.vue |  ():', minPos);\n      \n      // \n      let sum_x4 = 0, sum_x3 = 0, sum_x2 = 0, sum_x = 0, sum_1 = 0;\n      let sum_x2y = 0, sum_xy = 0, sum_y = 0;\n      \n      for (const point of dataPoints) {\n        const x = point[0] - minPos; // \n        const y = point[1];\n        \n        const x2 = x * x;\n        const x3 = x2 * x;\n        const x4 = x3 * x;\n        \n        sum_x4 += x4;\n        sum_x3 += x3;\n        sum_x2 += x2;\n        sum_x += x;\n        sum_1 += 1;\n        \n        sum_x2y += x2 * y;\n        sum_xy += x * y;\n        sum_y += y;\n      }\n      \n      this.logger.debug('Chart-Focus.vue | :', {\n        sum_x4, sum_x3, sum_x2, sum_x, sum_1,\n        sum_x2y, sum_xy, sum_y\n      });\n      \n      // \n      const matrix = [\n        [sum_x4, sum_x3, sum_x2],\n        [sum_x3, sum_x2, sum_x],\n        [sum_x2, sum_x, sum_1]\n      ];\n      \n      const constants = [sum_x2y, sum_xy, sum_y];\n      \n      this.logger.debug('Chart-Focus.vue | :', matrix);\n      this.logger.debug('Chart-Focus.vue | :', constants);\n      \n      // \n      const coefficients = this.solveLinearSystem(matrix, constants);\n      if (!coefficients) {\n        this.logger.error('Chart-Focus.vue | ');\n        return null;\n      }\n      \n      const result = {\n        a: coefficients[0],\n        b: coefficients[1],\n        c: coefficients[2]\n      };\n      \n      this.logger.info('Chart-Focus.vue | :', result);\n      \n      // \n      if (!isFinite(result.a) || !isFinite(result.b) || !isFinite(result.c)) {\n        this.logger.error('Chart-Focus.vue | ');\n        return null;\n      }\n      \n      // a0\n      if (Math.abs(result.a) < 1e-10) {\n        this.logger.warn('Chart-Focus.vue | 0');\n      }\n      \n      return result;\n    },\n    \n    /**\n     * 3x3\n     */\n    solveLinearSystem(matrix, constants) {\n      // \n      const augmented = [];\n      \n      // \n      for (let i = 0; i < 3; i++) {\n        augmented[i] = [...matrix[i], constants[i]];\n      }\n      \n      // \n      for (let i = 0; i < 3; i++) {\n        // \n        let maxRow = i;\n        for (let k = i + 1; k < 3; k++) {\n          if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {\n            maxRow = k;\n          }\n        }\n        \n        // \n        if (maxRow !== i) {\n          [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];\n        }\n        \n        // \n        if (Math.abs(augmented[i][i]) < 1e-10) {\n          this.logger.error('Chart-Focus.vue | ');\n          return null;\n        }\n        \n        // \n        for (let k = i + 1; k < 3; k++) {\n          const factor = augmented[k][i] / augmented[i][i];\n          for (let j = i; j < 4; j++) {\n            augmented[k][j] -= factor * augmented[i][j];\n          }\n        }\n      }\n      \n      // \n      const solution = [0, 0, 0];\n      for (let i = 2; i >= 0; i--) {\n        solution[i] = augmented[i][3];\n        for (let j = i + 1; j < 3; j++) {\n          solution[i] -= augmented[i][j] * solution[j];\n        }\n        solution[i] /= augmented[i][i];\n      }\n      \n      return solution;\n    },\n    \n    // ====================  ====================\n    \n    /**\n     * \n     * \n     */\n    testBackendDataReception() {\n      this.logger.info('Chart-Focus.vue | ');\n      console.log('Chart-Focus.vue | ');\n      \n      // \n      const testData = \"fitQuadraticCurve:0.000001:-0.02:5.0:15731.13:1.930\";\n      this.logger.info('Chart-Focus.vue | :', testData);\n      console.log('Chart-Focus.vue | :', testData);\n      \n      // \n      this.fitQuadraticCurve(testData);\n    },\n    \n    /**\n     * \n     * \n     * \n     */\n    testQuadraticFitting() {\n      this.logger.info('Chart-Focus.vue | ');\n      \n      // y = 0.0001 * (x - 3000)^2 + 2.0\n      const testData = [];\n      for (let i = 0; i < 10; i++) {\n        const x = 2000 + i * 200; // 20003800\n        const y = 0.0001 * Math.pow(x - 3000, 2) + 2.0 + (Math.random() - 0.5) * 0.2; // \n        testData.push([x, y]);\n      }\n      \n      this.logger.debug('Chart-Focus.vue | :', testData);\n      \n      // \n      const fitResult = this.performQuadraticFit(testData);\n      if (fitResult) {\n        this.logger.info('Chart-Focus.vue | :', fitResult);\n        \n        // 3000\n        const minPos = Math.min(...testData.map(point => point[0]));\n        const theoreticalBestPos = -fitResult.b / (2 * fitResult.a) + minPos;\n        this.logger.info('Chart-Focus.vue | :', theoreticalBestPos, ': 3000');\n        \n        // \n        this.generateQuadraticCurve(fitResult.a, fitResult.b, fitResult.c, theoreticalBestPos);\n        \n        this.logger.info('Chart-Focus.vue | ');\n      } else {\n        this.logger.error('Chart-Focus.vue | ');\n      }\n    },\n    \n  }\n}\n</script>\n\n<style scoped>\n.linechart-panel {\n  background-color: rgba(0, 0, 0, 0.0);\n  /* backdrop-filter: blur(5px); */\n  border-radius: 5px;\n  box-sizing: border-box;\n}\n\n.focus-result-panel {\n  position: fixed;\n  top: -200%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 300px;\n  background: linear-gradient(135deg, rgba(30, 30, 30, 0.95), rgba(45, 45, 45, 0.95));\n  border: 1px solid rgba(100, 100, 100, 0.3);\n  border-radius: 8px;\n  padding: 12px;\n  font-size: 12px;\n  color: #e0e0e0;\n  z-index: 1000;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n  backdrop-filter: blur(10px);\n  min-height: 60px;\n}\n\n.panel-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 8px;\n  padding-bottom: 6px;\n  border-bottom: 1px solid rgba(100, 100, 100, 0.2);\n}\n\n.header-left {\n  display: flex;\n  align-items: center;\n}\n\n.close-button {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  background-color: rgba(255, 255, 255, 0.1);\n  color: #b0b0b0;\n  font-size: 14px;\n  font-weight: bold;\n  transition: all 0.2s ease;\n}\n\n.close-button:hover {\n  background-color: rgba(255, 255, 255, 0.2);\n  color: #ffffff;\n}\n\n.status-icon {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-right: 8px;\n  font-size: 12px;\n  font-weight: bold;\n}\n\n.status-icon.success {\n  background-color: rgba(76, 175, 80, 0.2);\n  color: #4caf50;\n  border: 1px solid rgba(76, 175, 80, 0.4);\n}\n\n.status-icon.warning {\n  background-color: rgba(255, 152, 0, 0.2);\n  color: #ff9800;\n  border: 1px solid rgba(255, 152, 0, 0.4);\n}\n\n.panel-title {\n  font-weight: 600;\n  color: #ffffff;\n  font-size: 13px;\n}\n\n.panel-content {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}\n\n.status-row {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 2px 0;\n}\n\n.label {\n  color: #b0b0b0;\n  font-size: 11px;\n  font-weight: 500;\n}\n\n.value {\n  color: #ffffff;\n  font-size: 11px;\n  font-weight: 600;\n  font-family: 'Courier New', monospace;\n}\n\n.value.error {\n  color: #ff9800;\n  background: none;\n}\n\n.best-position {\n  margin-bottom: 2px;\n  color: #00ffff;\n  font-size: 9px;\n}\n\n.min-hfr {\n  color: #ff00ff;\n  font-size: 9px;\n}\n\n.fit-info {\n  color: #00ff00;\n  font-size: 8px;\n  margin-top: 2px;\n  font-style: italic;\n}\n</style>\n"]}]}