{"remainingRequest":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/location-mgr.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/location-mgr.vue","mtime":1749458942073},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/thread-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/babel-loader/lib/index.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js","mtime":1707125450000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBzd2ggZnJvbSAnQC9hc3NldHMvc3dfaGVscGVycy5qcycKaW1wb3J0IHsgTE1hcCwgTFRpbGVMYXllciwgTE1hcmtlciwgTENpcmNsZSwgTFRvb2x0aXAsIExDb250cm9sWm9vbSB9IGZyb20gJ3Z1ZTItbGVhZmxldCcKaW1wb3J0IEwgZnJvbSAnbGVhZmxldCcKaW1wb3J0IE1hcENvbmZpZyBmcm9tICdAL2NvbmZpZy9tYXAtY29uZmlnLmpzJwoKZXhwb3J0IGRlZmF1bHQgewogIGRhdGE6IGZ1bmN0aW9uICgpIHsKICAgIHJldHVybiB7CiAgICAgIG1vZGU6ICdwaWNrJywKICAgICAgcGlja0xvY2F0aW9uOiB1bmRlZmluZWQsCiAgICAgIHNlbGVjdGVkS25vd25Mb2NhdGlvbjogdW5kZWZpbmVkLAogICAgICBtYXBDZW50ZXI6IFszOS45MDQyLCAxMTYuNDA3NF0sCiAgICAgIHVybDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/ICcvdGlsZXMve3p9L3t4fS97eX0ucG5nJyA6ICdodHRwOi8vbG9jYWxob3N0OjgwODAvdGlsZXMve3p9L3t4fS97eX0ucG5nJywKICAgICAgZmFsbGJhY2tVcmw6ICcvdGlsZXMve3p9L3t4fS97eX0ucG5nJywKICAgICAgc2VydmVyVXJsOiAnaHR0cDovL2xvY2FsaG9zdDo4MDgwL3RpbGVzL3t6fS97eH0ve3l9LnBuZycsCiAgICAgIG9ubGluZVVybDogJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJywKICAgICAgLy8g5L2/55So6YWN572u5paH5Lu25Lit55qE57yp5pS+57qn5Yir6K6+572uCiAgICAgIG1pblpvb206IE1hcENvbmZpZy56b29tLm9mZmxpbmUubWluLAogICAgICBtYXhab29tOiBNYXBDb25maWcuem9vbS5vZmZsaW5lLm1heCwKICAgICAgZGVmYXVsdFpvb206IE1hcENvbmZpZy56b29tLm9mZmxpbmUuZGVmYXVsdCwKICAgICAgLy8g5Zyw55CG57yW56CB5Yqg6L2954q25oCBCiAgICAgIGdlb0NvZGVMb2FkaW5nOiBmYWxzZSwKICAgICAgLy8g5Zyw5Zu+57G75Z6L5ZKM572R57uc54q25oCBCiAgICAgIHVzZU9ubGluZU1hcDogdHJ1ZSwgICAgICAgICAgICAgIC8vIOS9v+eUqOWcqOe6v+WcsOWbvu+8iOeUqOaIt+mAieaLqe+8iQogICAgICBpc09ubGluZU1hcEF2YWlsYWJsZTogZmFsc2UsICAgICAvLyDlnKjnur/lnLDlm77mmK/lkKblj6/nlKgKICAgICAgaXNOZXR3b3JrQ29ubmVjdGVkOiBmYWxzZSwgICAgICAgLy8g572R57uc5piv5ZCm6L+e6YCaCiAgICAgIGN1cnJlbnRNYXBUeXBlOiAnY2hlY2tpbmcnLCAgICAgIC8vIOW9k+WJjeWcsOWbvuexu+WeizogJ29ubGluZScsICdvZmZsaW5lJywgJ2NoZWNraW5nJwogICAgICBuZXR3b3JrQ2hlY2tJbnRlcnZhbDogbnVsbCwgICAgICAvLyDnvZHnu5zmo4DmtYvlrprml7blmagKICAgICAgLy8g6K+35rGC5o6n5Yi2CiAgICAgIGN1cnJlbnRSZXF1ZXN0SWQ6IDAsCiAgICAgIGFib3J0Q29udHJvbGxlcjogbnVsbAogICAgfQogIH0sCiAgcHJvcHM6IFsnc2hvd015TG9jYXRpb24nLCAna25vd25Mb2NhdGlvbnMnLCAnc3RhcnRMb2NhdGlvbicsICdyZWFsTG9jYXRpb24nXSwKICBjb21wdXRlZDogewogICAgZG9TaG93TXlMb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gdGhpcy5zaG93TXlMb2NhdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0aGlzLnNob3dNeUxvY2F0aW9uCiAgICB9LAogICAgcGlja0xvY2F0aW9uTW9kZTogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAncGljaycKICAgIH0sCiAgICBrbm93bkxvY2F0aW9uTW9kZTogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAna25vd24nCiAgICB9LAogICAgbG9jYXRpb25Gb3JEZXRhaWw6IGZ1bmN0aW9uICgpIHsKICAgICAgbGV0IGxvY2F0aW9uID0gbnVsbAogICAgICAKICAgICAgaWYgKHRoaXMucGlja0xvY2F0aW9uTW9kZSAmJiB0aGlzLnBpY2tMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgbG9jYXRpb24gPSB0aGlzLnN0YXJ0TG9jYXRpb24KICAgICAgfSBlbHNlIHsKICAgICAgICBsb2NhdGlvbiA9IHRoaXMucGlja0xvY2F0aW9uTW9kZSA/IHRoaXMucGlja0xvY2F0aW9uIDogdGhpcy5zZWxlY3RlZEtub3duTG9jYXRpb24KICAgICAgfQogICAgICAKICAgICAgLy8g5aaC5p6c5pyJ5pyJ5pWI5L2N572u5bCx5riF55CG5bm26L+U5ZueCiAgICAgIGlmIChsb2NhdGlvbiAmJiB0aGlzLmlzVmFsaWRMb2NhdGlvbihsb2NhdGlvbikpIHsKICAgICAgICBjb25zdCBzYW5pdGl6ZWQgPSB0aGlzLnNhbml0aXplTG9jYXRpb24obG9jYXRpb24pCiAgICAgICAgaWYgKHNhbml0aXplZCkgewogICAgICAgICAgcmV0dXJuIHNhbml0aXplZAogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g6L+U5Zue6buY6K6k5L+h5oGv55So5LqO5pi+56S677yM5L2G5LiN5Lya5b2x5ZON5Zyw5Zu+6ZKJCiAgICAgIHJldHVybiB7CiAgICAgICAgbGF0OiAzOS45MDQyLAogICAgICAgIGxuZzogMTE2LjQwNzQsCiAgICAgICAgYWNjdXJhY3k6IDEwMDAsCiAgICAgICAgc2hvcnRfbmFtZTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuYmVpamluZycpLAogICAgICAgIGNvdW50cnk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmNoaW5hJyksCiAgICAgICAgc3RyZWV0X2FkZHJlc3M6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmJlaWppbmdDaXR5JyksCiAgICAgICAgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuYmVpamluZ0NpdHknKSwKICAgICAgICBzdGF0ZTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuYmVpamluZ0NpdHknKSwKICAgICAgICBwb3N0Y29kZTogJycKICAgICAgfQogICAgfSwKICAgIC8vIOWKqOaAgee8qeaUvue6p+WIq+mFjee9rgogICAgZWZmZWN0aXZlTWluWm9vbTogZnVuY3Rpb24gKCkgewogICAgICAvLyDlnKjnur/lnLDlm77kvb/nlKjmm7Tlrr3mnb7nmoTpmZDliLbvvIznprvnur/lnLDlm77kvb/nlKjkuKXmoLzpmZDliLYKICAgICAgaWYgKHRoaXMuY3VycmVudE1hcFR5cGUgPT09ICdvbmxpbmUnKSB7CiAgICAgICAgcmV0dXJuIE1hcENvbmZpZy56b29tLm9ubGluZS5taW4gIC8vIOWcqOe6v+WcsOWbvu+8mumAmuW4uOaYrzDmiJYxCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIE1hcENvbmZpZy56b29tLm9mZmxpbmUubWluICAvLyDnprvnur/lnLDlm77vvJrln7rkuo7lj6/nlKjnk6bniYcKICAgICAgfQogICAgfSwKICAgIGVmZmVjdGl2ZU1heFpvb206IGZ1bmN0aW9uICgpIHsKICAgICAgLy8g5Zyo57q/5Zyw5Zu+5L2/55So5pu05a695p2+55qE6ZmQ5Yi277yM56a757q/5Zyw5Zu+5L2/55So5Lil5qC86ZmQ5Yi2CiAgICAgIGlmICh0aGlzLmN1cnJlbnRNYXBUeXBlID09PSAnb25saW5lJykgewogICAgICAgIHJldHVybiBNYXBDb25maWcuem9vbS5vbmxpbmUubWF4ICAvLyDlnKjnur/lnLDlm77vvJrpgJrluLjmmK8xOOaIljE5CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIE1hcENvbmZpZy56b29tLm9mZmxpbmUubWF4ICAvLyDnprvnur/lnLDlm77vvJrln7rkuo7lj6/nlKjnk6bniYcKICAgICAgfQogICAgfSwKICAgIHZhbGlkS25vd25Mb2NhdGlvbnM6IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKCF0aGlzLmtub3duTG9jYXRpb25zIHx8ICFBcnJheS5pc0FycmF5KHRoaXMua25vd25Mb2NhdGlvbnMpIHx8IHRoaXMua25vd25Mb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgLy8g5aaC5p6c5rKh5pyJ5Lyg5YWl5Lu75L2V5bey55+l5L2N572u77yM5LiN5pi+56S66buY6K6k5Zyw5Zu+6ZKJCiAgICAgICAgcmV0dXJuIFtdCiAgICAgIH0KICAgICAgCiAgICAgIGNvbnN0IHZhbGlkTG9jYXRpb25zID0gdGhpcy5rbm93bkxvY2F0aW9ucy5maWx0ZXIodGhpcy5pc1ZhbGlkTG9jYXRpb24pCiAgICAgIHJldHVybiB2YWxpZExvY2F0aW9ucwogICAgfSwKICAgIC8vIOaOp+WItnBpY2tMb2NhdGlvbuWcsOWbvumSieaYr+WQpuaYvuekugogICAgc2hvdWxkU2hvd1BpY2tMb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgICAvLyDlnKhwaWNrTG9jYXRpb25Nb2Rl5LiU5pyJ5pyJ5pWIcGlja0xvY2F0aW9u5pe25pi+56S677yI5YyF5ous6buY6K6k5L2N572u77yJCiAgICAgIHJldHVybiB0aGlzLnBpY2tMb2NhdGlvbk1vZGUgJiYgCiAgICAgICAgICAgICB0aGlzLnBpY2tMb2NhdGlvbiAmJiAKICAgICAgICAgICAgIHRoaXMuaXNWYWxpZExvY2F0aW9uKHRoaXMucGlja0xvY2F0aW9uKQogICAgfSwKICAgIGhhc1ZhbGlkU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7CiAgICAgIC8vIOajgOafpeaYr+WQpuacieecn+ato+eahOS9jee9rumAieaLqQogICAgICBpZiAodGhpcy5zZWxlY3RlZEtub3duTG9jYXRpb24pIHsKICAgICAgICByZXR1cm4gdHJ1ZSAvLyDpgInmi6nkuoblt7Lnn6XkvY3nva4KICAgICAgfQogICAgICAKICAgICAgaWYgKHRoaXMucGlja0xvY2F0aW9uICYmIHRoaXMuaXNWYWxpZExvY2F0aW9uKHRoaXMucGlja0xvY2F0aW9uKSkgewogICAgICAgIC8vIOWmguaenOWcsOWdgOS/oeaBr+aYvuekuiLmi5bmi73pgInmi6nkvY3nva4i5oiWIum7mOiupOS9jee9riLvvIzor7TmmI7nlKjmiLfov5jmsqHmnInmk43kvZwKICAgICAgICBpZiAodGhpcy5waWNrTG9jYXRpb24uc2hvcnRfbmFtZSA9PT0gdGhpcy4kdCgnbG9jYXRpb25NZ3IuZHJhZ1RvU2VsZWN0UGluJykgfHwgCiAgICAgICAgICAgIHRoaXMucGlja0xvY2F0aW9uLmNvdW50cnkgPT09IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmRlZmF1bHRMb2NhdGlvbicpKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWUKICAgICAgfQogICAgICAKICAgICAgcmV0dXJuIGZhbHNlCiAgICB9CiAgfSwKICB3YXRjaDogewogICAgc3RhcnRMb2NhdGlvbjogZnVuY3Rpb24gKG5ld0xvY2F0aW9uKSB7CiAgICAgIGlmICh0aGlzLmlzVmFsaWRMb2NhdGlvbihuZXdMb2NhdGlvbikpIHsKICAgICAgICB0aGlzLnNldFBpY2tMb2NhdGlvbihuZXdMb2NhdGlvbikKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgc3RhcnRMb2NhdGlvbiByZWNlaXZlZDonLCBuZXdMb2NhdGlvbikKICAgICAgfQogICAgfQogIH0sCiAgY3JlYXRlZCgpIHsKICAgIHRoaXMuJGJ1cy4kb24oJ3VwZGF0ZU1hcFBvc2l0aW9uJywgdGhpcy51cGRhdGVNYXBQb3NpdGlvbik7CiAgfSwKICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7CiAgICBjb25zdCB0aGF0ID0gdGhpcwogICAgCiAgICAvLyDkv67lpI1MZWFmbGV05Zu+5qCH6Zeu6aKYCiAgICB0aGlzLmZpeExlYWZsZXRJY29ucygpCiAgICAKICAgIC8vIOWPquacieWcqOS8oOWFpeacieaViHN0YXJ0TG9jYXRpb27ml7bmiY3orr7nva5waWNrTG9jYXRpb24KICAgIGlmICh0aGlzLnN0YXJ0TG9jYXRpb24gJiYgdGhpcy5pc1ZhbGlkTG9jYXRpb24odGhpcy5zdGFydExvY2F0aW9uKSkgewogICAgICB0aGlzLnNldFBpY2tMb2NhdGlvbih0aGlzLnN0YXJ0TG9jYXRpb24pCiAgICB9IGVsc2UgewogICAgICAvLyDlpoLmnpzmsqHmnIlzdGFydExvY2F0aW9u77yM5Yib5bu65LiA5Liq6buY6K6k55qEcGlja0xvY2F0aW9u5Zyo5Zyw5Zu+5Lit5b+DCiAgICAgIHRoaXMucGlja0xvY2F0aW9uID0gewogICAgICAgIGxhdDogMzkuOTA0MiwKICAgICAgICBsbmc6IDExNi40MDc0LAogICAgICAgIGFjY3VyYWN5OiAwLAogICAgICAgIHNob3J0X25hbWU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmRyYWdUb1NlbGVjdFBpbicpLAogICAgICAgIGNvdW50cnk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmRlZmF1bHRMb2NhdGlvbicpLAogICAgICAgIHN0cmVldF9hZGRyZXNzOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5kcmFnUGluVG9UYXJnZXQnKQogICAgICB9CiAgICAgIHRoaXMuc2V0UGlja0xvY2F0aW9uTW9kZSgpCiAgICB9CiAgICAKICAgIC8vIOWQr+WKqOe9kee7nOebkeaOpwogICAgdGhpcy5zdGFydE5ldHdvcmtNb25pdG9yaW5nKCkKICAgIAogICAgLy8g5qOA5rWL5bm26K6+572u5Zyw5Zu+57G75Z6LCiAgICB0aGlzLmRldGVjdEFuZFNldE1hcFR5cGUoKQogICAgCiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgIGNvbnN0IG1hcCA9IHRoaXMuJHJlZnMubXlNYXAubWFwT2JqZWN0CiAgICAgIG1hcC5fb25SZXNpemUoKQoKICAgICAgLy8g6K6+572u57yp5pS+6ZmQ5Yi2CiAgICAgIHRoaXMudXBkYXRlWm9vbUxpbWl0cyhtYXApCiAgICB9KQogIH0sCiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gKCkgewogICAgLy8g5riF55CG5a6a5pe25ZmoCiAgICBpZiAodGhpcy5uZXR3b3JrQ2hlY2tJbnRlcnZhbCkgewogICAgICBjbGVhckludGVydmFsKHRoaXMubmV0d29ya0NoZWNrSW50ZXJ2YWwpCiAgICB9CiAgICAKICAgIC8vIOa4heeQhuivt+axguaOp+WItuWZqAogICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7CiAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCkKICAgICAgY29uc29sZS5sb2coJ+e7hOS7tumUgOavge+8jOWPlua2iOWcsOeQhue8lueggeivt+axgicpCiAgICB9CiAgICAKICAgIC8vIOenu+mZpOe9kee7nOeKtuaAgeebkeWQrOWZqAogICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuZGV0ZWN0QW5kU2V0TWFwVHlwZSkKICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgdGhpcy5kZXRlY3RBbmRTZXRNYXBUeXBlKQogIH0sCiAgbWV0aG9kczogewogICAgc2VsZWN0S25vd25Mb2NhdGlvbjogZnVuY3Rpb24gKGxvYykgewogICAgICB0aGlzLnNlbGVjdGVkS25vd25Mb2NhdGlvbiA9IGxvYwogICAgICB0aGlzLnNldEtub3duTG9jYXRpb25Nb2RlKCkKICAgICAgdGhpcy5tYXBDZW50ZXIgPSBbbG9jLmxhdCwgbG9jLmxuZ10KICAgIH0sCiAgICB1c2VMb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgICBjb25zb2xlLmxvZygn6Kem5Y+R5L2N572u5pu05pawdXNlTG9jYXRpb246JywgdGhpcy5sb2NhdGlvbkZvckRldGFpbC5sYXQsIHRoaXMubG9jYXRpb25Gb3JEZXRhaWwubG5nKQogICAgICB0aGlzLiRidXMuJGVtaXQoJ2xvY2F0aW9uU2VsZWN0ZWQnLCB0aGlzLmxvY2F0aW9uRm9yRGV0YWlsKQogICAgICBjb25zdCBsYXQgPSBwYXJzZUZsb2F0KHRoaXMubG9jYXRpb25Gb3JEZXRhaWwubGF0LnRvRml4ZWQoMykpCiAgICAgIGNvbnN0IGxuZyA9IHBhcnNlRmxvYXQodGhpcy5sb2NhdGlvbkZvckRldGFpbC5sbmcudG9GaXhlZCgzKSkKICAgICAgdGhpcy4kYnVzLiRlbWl0KCdyZXNldExvY2F0aW9uJywgbGF0LCBsbmcsZmFsc2UpCiAgICB9LAogICAgc2V0UGlja0xvY2F0aW9uTW9kZTogZnVuY3Rpb24gKCkgewogICAgICB0aGlzLm1vZGUgPSAncGljaycKICAgIH0sCiAgICBzZXRLbm93bkxvY2F0aW9uTW9kZTogZnVuY3Rpb24gKCkgewogICAgICB0aGlzLm1vZGUgPSAna25vd24nCiAgICB9LAogICAgc2V0UGlja0xvY2F0aW9uOiBmdW5jdGlvbiAobG9jKSB7CiAgICAgIC8vIOmqjOivgei+k+WFpeaVsOaNrgogICAgICBpZiAoIXRoaXMuaXNWYWxpZExvY2F0aW9uKGxvYykpIHsKICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgbG9jYXRpb24gZGF0YSByZWNlaXZlZDonLCBsb2MpCiAgICAgICAgLy8g5LiN5Yib5bu66buY6K6k5L2N572u77yM55u05o6l6L+U5ZueCiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgCiAgICAgIC8vIOa4heeQhuaVsOaNrgogICAgICBjb25zdCBzYW5pdGl6ZWRMb2MgPSB0aGlzLnNhbml0aXplTG9jYXRpb24obG9jKQogICAgICAKICAgICAgaWYgKHNhbml0aXplZExvYy5hY2N1cmFjeSA8IDEwMCkgewogICAgICAgIGZvciAoY29uc3QgbCBvZiB0aGlzLmtub3duTG9jYXRpb25zKSB7CiAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkTG9jYXRpb24obCkpIHsKICAgICAgICAgICAgY29uc3QgZCA9IHN3aC5nZXREaXN0YW5jZUZyb21MYXRMb25Jbk0obC5sYXQsIGwubG5nLCBzYW5pdGl6ZWRMb2MubGF0LCBzYW5pdGl6ZWRMb2MubG5nKQogICAgICAgICAgICBpZiAoZCA8IDEwMCkgewogICAgICAgICAgICAgIHRoaXMuc2VsZWN0S25vd25Mb2NhdGlvbihsKQogICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIAogICAgICAvLyDorr7nva7mnInmlYjnmoTkvY3nva4KICAgICAgdGhpcy5tYXBDZW50ZXIgPSBbc2FuaXRpemVkTG9jLmxhdCwgc2FuaXRpemVkTG9jLmxuZ10KICAgICAgdGhpcy5waWNrTG9jYXRpb24gPSBzYW5pdGl6ZWRMb2MKICAgICAgdGhpcy5zZXRQaWNrTG9jYXRpb25Nb2RlKCkKICAgIH0sCiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIHNtYWxsIGNyb3NzIGJ1dHRvbgogICAgY2VudGVyT25SZWFsUG9zaXRpb246IGZ1bmN0aW9uICgpIHsKICAgICAgdGhpcy5zZXRQaWNrTG9jYXRpb24odGhpcy5yZWFsTG9jYXRpb24pCiAgICB9LAogICAgCiAgICAvLyDpgJrov4fkv6Hlj7fmp73mm7TmlrDlnLDlm77mmL7npLrkvY3nva4KICAgIHVwZGF0ZU1hcFBvc2l0aW9uOiBmdW5jdGlvbiAobGF0LCBsbmcsIG9wdGlvbnMgPSB7fSkgewogICAgICBjb25zb2xlLmxvZygn5pS25Yiw5L2N572u5pu05paw5L+h5Y+3OicsIGxhdCwgbG5nLCBvcHRpb25zKQogICAgICAKICAgICAgLy8g6aqM6K+B6L6T5YWl5Y+C5pWwCiAgICAgIGlmICh0eXBlb2YgbGF0ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgbG5nICE9PSAnbnVtYmVyJyB8fCAKICAgICAgICAgIGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSB8fCAKICAgICAgICAgIGxhdCA8IC05MCB8fCBsYXQgPiA5MCB8fCBsbmcgPCAtMTgwIHx8IGxuZyA+IDE4MCkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ+aXoOaViOeahOS9jee9ruWdkOaghzonLCB7IGxhdCwgbG5nIH0pCiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgCiAgICAgIC8vIOm7mOiupOmAiemhuQogICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHsKICAgICAgICB1cGRhdGVNYXJrZXI6IHRydWUsICAgICAgICAvLyDmmK/lkKbmm7TmlrDlnLDlm77pkonkvY3nva4KICAgICAgICBmZXRjaEFkZHJlc3M6IHRydWUsICAgICAgICAvLyDmmK/lkKbojrflj5blnLDlnYDkv6Hmga8KICAgICAgICB6b29tOiBudWxsLCAgICAgICAgICAgICAgIC8vIOWPr+mAieeahOe8qeaUvue6p+WIqwogICAgICAgIGFuaW1hdGU6IHRydWUsICAgICAgICAgICAgLy8g5piv5ZCm5L2/55So5Yqo55S7CiAgICAgICAgYWNjdXJhY3k6IDAgICAgICAgICAgICAgICAvLyDkvY3nva7nsr7luqYKICAgICAgfQogICAgICAKICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpCiAgICAgIAogICAgICB0cnkgewogICAgICAgIC8vIOabtOaWsOWcsOWbvuS4reW/gwogICAgICAgIGlmIChjb25maWcuYW5pbWF0ZSAmJiB0aGlzLiRyZWZzLm15TWFwICYmIHRoaXMuJHJlZnMubXlNYXAubWFwT2JqZWN0KSB7CiAgICAgICAgICAvLyDkvb/nlKjliqjnlLvlubPmu5Hnp7vliqgKICAgICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuJHJlZnMubXlNYXAubWFwT2JqZWN0CiAgICAgICAgICBjb25zdCB0YXJnZXRab29tID0gY29uZmlnLnpvb20gfHwgbWFwLmdldFpvb20oKQogICAgICAgICAgbWFwLmZseVRvKFtsYXQsIGxuZ10sIHRhcmdldFpvb20sIHsKICAgICAgICAgICAgZHVyYXRpb246IDEuNSwgIC8vIOWKqOeUu+aXtumVv++8iOenku+8iQogICAgICAgICAgICBlYXNlTGluZWFyaXR5OiAwLjEKICAgICAgICAgIH0pCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIOebtOaOpeiuvue9ruWcsOWbvuS4reW/gwogICAgICAgICAgdGhpcy5tYXBDZW50ZXIgPSBbbGF0LCBsbmddCiAgICAgICAgICAKICAgICAgICAgIC8vIOWmguaenOaMh+WumuS6hue8qeaUvue6p+WIq++8jOiuvue9rue8qeaUvgogICAgICAgICAgaWYgKGNvbmZpZy56b29tICYmIHRoaXMuJHJlZnMubXlNYXAgJiYgdGhpcy4kcmVmcy5teU1hcC5tYXBPYmplY3QpIHsKICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgIHRoaXMuJHJlZnMubXlNYXAubWFwT2JqZWN0LnNldFpvb20oY29uZmlnLnpvb20pCiAgICAgICAgICAgIH0pCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOabtOaWsOWcsOWbvumSieS9jee9rgogICAgICAgIGlmIChjb25maWcudXBkYXRlTWFya2VyKSB7CiAgICAgICAgICBjb25zdCBuZXdMb2NhdGlvbiA9IHsKICAgICAgICAgICAgbGF0OiBsYXQsCiAgICAgICAgICAgIGxuZzogbG5nLAogICAgICAgICAgICBhY2N1cmFjeTogY29uZmlnLmFjY3VyYWN5LAogICAgICAgICAgICBzaG9ydF9uYW1lOiBjb25maWcuZmV0Y2hBZGRyZXNzID8gdGhpcy4kdCgnbG9jYXRpb25NZ3IuZmV0Y2hpbmdMb2NhdGlvbkluZm8nKSA6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLm5ld0xvY2F0aW9uJyksCiAgICAgICAgICAgIGNvdW50cnk6IGNvbmZpZy5mZXRjaEFkZHJlc3MgPyB0aGlzLiR0KCdsb2NhdGlvbk1nci5wbGVhc2VXYWl0JykgOiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duJyksCiAgICAgICAgICAgIHN0cmVldF9hZGRyZXNzOiBgJHt0aGlzLiR0KCdsb2NhdGlvbk1nci5jb29yZGluYXRlcycpfTogJHtsYXQudG9GaXhlZCg2KX0sICR7bG5nLnRvRml4ZWQoNil9YAogICAgICAgICAgfQogICAgICAgICAgCiAgICAgICAgICAvLyDmoLnmja7lvZPliY3mqKHlvI/mm7TmlrDkvY3nva4KICAgICAgICAgIGlmICh0aGlzLnBpY2tMb2NhdGlvbk1vZGUpIHsKICAgICAgICAgICAgdGhpcy5waWNrTG9jYXRpb24gPSBuZXdMb2NhdGlvbgogICAgICAgICAgICB0aGlzLnNldFBpY2tMb2NhdGlvbk1vZGUoKQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8g5Yib5bu65paw55qE5ou+5Y+W5L2N572uCiAgICAgICAgICAgIHRoaXMucGlja0xvY2F0aW9uID0gbmV3TG9jYXRpb24KICAgICAgICAgICAgdGhpcy5zZXRQaWNrTG9jYXRpb25Nb2RlKCkKICAgICAgICAgIH0KICAgICAgICAgIAogICAgICAgICAgLy8g6I635Y+W5Zyw5Z2A5L+h5oGvCiAgICAgICAgICBpZiAoY29uZmlnLmZldGNoQWRkcmVzcykgewogICAgICAgICAgICB0aGlzLnJlcXVlc3RMb2NhdGlvbkluZm8obGF0LCBsbmcpCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOinpuWPkeS9jee9ruabtOaWsOS6i+S7tgogICAgICAgIHRoaXMuJGVtaXQoJ21hcFBvc2l0aW9uVXBkYXRlZCcsIHsgbGF0LCBsbmcsIG9wdGlvbnM6IGNvbmZpZyB9KQogICAgICAgIAogICAgICAgIGNvbnNvbGUubG9nKCflnLDlm77kvY3nva7mm7TmlrDmiJDlip86JywgeyBsYXQsIGxuZywgY29uZmlnIH0pCiAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICAKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCflnLDlm77kvY3nva7mm7TmlrDlpLHotKU6JywgZXJyb3IpCiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgIH0sCiAgICAKICAgIC8vIOi+heWKqeaWueazle+8muivt+axguS9jee9ruS/oeaBrwogICAgcmVxdWVzdExvY2F0aW9uSW5mbzogZnVuY3Rpb24gKGxhdCwgbG5nKSB7CiAgICAgIC8vIOeUn+aIkOaWsOeahOivt+axgklECiAgICAgIGNvbnN0IHJlcXVlc3RJZCA9ICsrdGhpcy5jdXJyZW50UmVxdWVzdElkCiAgICAgIAogICAgICAvLyDlu7bov5/ojrflj5blnLDnkIbkv6Hmga/vvIzpgb/lhY3popHnuYHor7fmsYIKICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgLy8g5qOA5p+l5piv5ZCm5piv5pyA5paw55qE6K+35rGCCiAgICAgICAgaWYgKHJlcXVlc3RJZCAhPT0gdGhpcy5jdXJyZW50UmVxdWVzdElkKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygn5L2N572u5L+h5oGv6K+35rGC5bey6L+H5pyf77yM6Lez6L+H5Zyw55CG57yW56CBJykKICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDojrflj5blnLDnkIbkv6Hmga/vvIjlnKjnur/miJbnprvnur/vvIkKICAgICAgICB0aGlzLmdldENpdHlJbmZvKHsgbGF0LCBsbmcgfSwgcmVxdWVzdElkKS50aGVuKGNpdHlJbmZvID0+IHsKICAgICAgICAgIC8vIOWGjeasoeajgOafpeivt+axguaYr+WQpuS7jeeEtuacieaViAogICAgICAgICAgaWYgKHJlcXVlc3RJZCAhPT0gdGhpcy5jdXJyZW50UmVxdWVzdElkKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCflnLDnkIbnvJbnoIHlrozmiJDvvIzkvYbor7fmsYLlt7Lov4fmnJ8nKQogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KICAgICAgICAgIAogICAgICAgICAgY29uc3QgdXBkYXRlZFBvcyA9IHsKICAgICAgICAgICAgbGF0OiBsYXQsCiAgICAgICAgICAgIGxuZzogbG5nLAogICAgICAgICAgICBhY2N1cmFjeTogdGhpcy5waWNrTG9jYXRpb24/LmFjY3VyYWN5IHx8IDAsCiAgICAgICAgICAgIC4uLmNpdHlJbmZvCiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIC8vIOabtOaWsOS9jee9ruS/oeaBrwogICAgICAgICAgaWYgKHRoaXMucGlja0xvY2F0aW9uTW9kZSAmJiB0aGlzLnBpY2tMb2NhdGlvbikgewogICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucGlja0xvY2F0aW9uLCB1cGRhdGVkUG9zKQogICAgICAgICAgICB0aGlzLiRmb3JjZVVwZGF0ZSgpCiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIGNvbnNvbGUubG9nKCfkvY3nva7kv6Hmga/lt7Lmm7TmlrA6JywgdXBkYXRlZFBvcykKICAgICAgICAgIAogICAgICAgICAgLy8g6Kem5Y+R5Zyw5Z2A5L+h5oGv5pu05paw5LqL5Lu2CiAgICAgICAgICB0aGlzLiRlbWl0KCdhZGRyZXNzSW5mb1VwZGF0ZWQnLCB1cGRhdGVkUG9zKQogICAgICAgICAgCiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gewogICAgICAgICAgLy8g5qOA5p+l5piv5ZCm5piv6K+35rGC5Y+W5raI6ZSZ6K+vCiAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCflnLDnkIbnvJbnoIHor7fmsYLooqvlj5bmtognKQogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KICAgICAgICAgIAogICAgICAgICAgLy8g5YaN5qyh5qOA5p+l6K+35rGC5piv5ZCm5LuN54S25pyJ5pWICiAgICAgICAgICBpZiAocmVxdWVzdElkICE9PSB0aGlzLmN1cnJlbnRSZXF1ZXN0SWQpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coJ+WcsOeQhue8lueggeWksei0pe+8jOS9huivt+axguW3sui/h+acnycpCiAgICAgICAgICAgIHJldHVybgogICAgICAgICAgfQogICAgICAgICAgCiAgICAgICAgICBjb25zb2xlLmVycm9yKCfojrflj5bkvY3nva7kv6Hmga/lpLHotKU6JywgZXJyb3IpCiAgICAgICAgICAKICAgICAgICAgIC8vIOmUmeivr+WkhOeQhgogICAgICAgICAgY29uc3QgZXJyb3JMb2NhdGlvbkluZm8gPSB7CiAgICAgICAgICAgIGxhdDogbGF0LAogICAgICAgICAgICBsbmc6IGxuZywKICAgICAgICAgICAgYWNjdXJhY3k6IHRoaXMucGlja0xvY2F0aW9uPy5hY2N1cmFjeSB8fCAwLAogICAgICAgICAgICBzaG9ydF9uYW1lOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5mZXRjaExvY2F0aW9uRmFpbGVkJyksCiAgICAgICAgICAgIGNvdW50cnk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25SZWdpb24nKSwKICAgICAgICAgICAgc3RyZWV0X2FkZHJlc3M6IGAke3RoaXMuJHQoJ2xvY2F0aW9uTWdyLmNvb3JkaW5hdGVzJyl9OiAke2xhdC50b0ZpeGVkKDYpfSwgJHtsbmcudG9GaXhlZCg2KX1gCiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIGlmICh0aGlzLnBpY2tMb2NhdGlvbk1vZGUgJiYgdGhpcy5waWNrTG9jYXRpb24pIHsKICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBpY2tMb2NhdGlvbiwgZXJyb3JMb2NhdGlvbkluZm8pCiAgICAgICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCkKICAgICAgICAgIH0KICAgICAgICAgIAogICAgICAgICAgLy8g6Kem5Y+R6ZSZ6K+v5LqL5Lu2CiAgICAgICAgICB0aGlzLiRlbWl0KCdhZGRyZXNzSW5mb0Vycm9yJywgeyBsYXQsIGxuZywgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSkKICAgICAgICB9KQogICAgICB9LCAxMDApIC8vIDEwMG1z5bu26L+fCiAgICB9LAogICAgY2hlY2tUaWxlQXZhaWxhYmlsaXR5OiBmdW5jdGlvbiAoKSB7CiAgICAgIGNvbnN0IHRoYXQgPSB0aGlzCiAgICAgIAogICAgICAvLyDlnKjnlJ/kuqfnjq/looPkuIvkvJjlhYjkvb/nlKjpnZnmgIHnk6bniYcKICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHsKICAgICAgICB0aGF0LnRlc3RTdGF0aWNUaWxlcygpLnRoZW4oaXNBdmFpbGFibGUgPT4gewogICAgICAgICAgaWYgKGlzQXZhaWxhYmxlKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfkvb/nlKjpnZnmgIHnk6bniYfmlofku7YnKQogICAgICAgICAgICB0aGF0LnVybCA9IHRoYXQuZmFsbGJhY2tVcmwKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfpnZnmgIHnk6bniYfkuI3lj6/nlKjvvIzlsJ3or5V0aWxl5pyN5Yqh5ZmoJykKICAgICAgICAgICAgdGhhdC50ZXN0VGlsZVNlcnZlcigpCiAgICAgICAgICB9CiAgICAgICAgfSkKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyDlvIDlj5Hnjq/looPkuIvkvJjlhYjlsJ3or5V0aWxl5pyN5Yqh5ZmoCiAgICAgICAgdGhhdC50ZXN0VGlsZVNlcnZlcigpCiAgICAgIH0KICAgIH0sCiAgICAKICAgIHRlc3RTdGF0aWNUaWxlczogZnVuY3Rpb24gKCkgewogICAgICBjb25zdCB0aGF0ID0gdGhpcwogICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAvLyDmtYvor5XlpJrkuKrnvKnmlL7nuqfliKvnmoTnk6bniYfmmK/lkKblrZjlnKgKICAgICAgICBjb25zdCB0ZXN0VXJscyA9IFsKICAgICAgICAgICcvdGlsZXMvMC8wLzAucG5nJywKICAgICAgICAgICcvdGlsZXMvMS8wLzAucG5nJywKICAgICAgICAgICcvdGlsZXMvMi8xLzEucG5nJwogICAgICAgIF0KICAgICAgICAKICAgICAgICBsZXQgdGVzdENvdW50ID0gMAogICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwCiAgICAgICAgCiAgICAgICAgdGVzdFVybHMuZm9yRWFjaCh1cmwgPT4gewogICAgICAgICAgZmV0Y2godXJsLCB7IG1ldGhvZDogJ0hFQUQnIH0pCiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHsKICAgICAgICAgICAgICB0ZXN0Q291bnQrKwogICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykgewogICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50KysKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgaWYgKHRlc3RDb3VudCA9PT0gdGVzdFVybHMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAvLyDlpoLmnpzoh7PlsJHkuIDljYrnmoTmtYvor5Xnk6bniYflj6/nlKjvvIzorqTkuLrpnZnmgIHnk6bniYflj6/nlKgKICAgICAgICAgICAgICAgIHJlc29sdmUoc3VjY2Vzc0NvdW50ID49IHRlc3RVcmxzLmxlbmd0aCAvIDIpCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgICAgICAuY2F0Y2goKCkgPT4gewogICAgICAgICAgICAgIHRlc3RDb3VudCsrCiAgICAgICAgICAgICAgaWYgKHRlc3RDb3VudCA9PT0gdGVzdFVybHMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICByZXNvbHZlKHN1Y2Nlc3NDb3VudCA+PSB0ZXN0VXJscy5sZW5ndGggLyAyKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICB9KQogICAgICAgIAogICAgICAgIC8vIOi2heaXtuWkhOeQhgogICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgaWYgKHRlc3RDb3VudCA8IHRlc3RVcmxzLmxlbmd0aCkgewogICAgICAgICAgICByZXNvbHZlKGZhbHNlKQogICAgICAgICAgfQogICAgICAgIH0sIDIwMDApCiAgICAgIH0pCiAgICB9LAogICAgCiAgICB0ZXN0VGlsZVNlcnZlcjogZnVuY3Rpb24gKCkgewogICAgICBjb25zdCB0aGF0ID0gdGhpcwogICAgICAKICAgICAgLy8g5rWL6K+VdGlsZeacjeWKoeWZqOaYr+WQpuWPr+eUqAogICAgICBjb25zdCB0ZXN0VXJsID0gdGhpcy5zZXJ2ZXJVcmwucmVwbGFjZSgne3p9JywgJzAnKS5yZXBsYWNlKCd7eH0nLCAnMCcpLnJlcGxhY2UoJ3t5fScsICcwJykKICAgICAgCiAgICAgIGZldGNoKHRlc3RVcmwsIHsgbWV0aG9kOiAnSEVBRCcsIHRpbWVvdXQ6IDMwMDAgfSkKICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7CiAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHsKICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbGXmnI3liqHlmajlj6/nlKgnKQogICAgICAgICAgICB0aGF0LnVybCA9IHRoYXQuc2VydmVyVXJsCiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RpbGXmnI3liqHlmajlk43lupTplJnor68nKQogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgICAgLmNhdGNoKGVycm9yID0+IHsKICAgICAgICAgIGNvbnNvbGUubG9nKCd0aWxl5pyN5Yqh5Zmo5LiN5Y+v55So77yM5L2/55So6Z2Z5oCB55Om54mHOicsIGVycm9yKQogICAgICAgICAgdGhhdC51cmwgPSB0aGF0LmZhbGxiYWNrVXJsCiAgICAgICAgICAKICAgICAgICAgIC8vIOWmguaenOmdmeaAgeeTpueJh+S5n+S4jeWPr+eUqO+8jOacgOWQjuWwneivleWcqOe6v+eTpueJhwogICAgICAgICAgdGhhdC50ZXN0U3RhdGljVGlsZXMoKS50aGVuKGlzQXZhaWxhYmxlID0+IHsKICAgICAgICAgICAgaWYgKCFpc0F2YWlsYWJsZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgewogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfliIfmjaLliLDlnKjnur/nk6bniYfmnI3liqEnKQogICAgICAgICAgICAgIHRoYXQudXJsID0gdGhhdC5vbmxpbmVVcmwKICAgICAgICAgICAgfQogICAgICAgICAgfSkKICAgICAgICB9KQogICAgfSwKICAgIHVwZGF0ZVpvb21MaW1pdHM6IGZ1bmN0aW9uIChtYXApIHsKICAgICAgY29uc3QgdGhhdCA9IHRoaXMKICAgICAgCiAgICAgIC8vIOWKqOaAgeiuvue9rue8qeaUvumZkOWItgogICAgICBtYXAuc2V0TWluWm9vbSh0aGlzLmVmZmVjdGl2ZU1pblpvb20pCiAgICAgIG1hcC5zZXRNYXhab29tKHRoaXMuZWZmZWN0aXZlTWF4Wm9vbSkKICAgICAgCiAgICAgIGNvbnNvbGUubG9nKGDlnLDlm77nvKnmlL7pmZDliLbmm7TmlrA6ICR7dGhpcy5lZmZlY3RpdmVNaW5ab29tfSAtICR7dGhpcy5lZmZlY3RpdmVNYXhab29tfSAoJHt0aGlzLmN1cnJlbnRNYXBUeXBlfeaooeW8jylgKQogICAgICAKICAgICAgLy8g5Y+q5Zyo56a757q/5qih5byP5LiL5qOA5rWL5Y+v55So55Om54mH57qn5YirCiAgICAgIGlmICh0aGlzLmN1cnJlbnRNYXBUeXBlID09PSAnb2ZmbGluZScgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykgewogICAgICAgIHRoaXMuZGV0ZWN0QXZhaWxhYmxlVGlsZUxldmVscygpLnRoZW4obGV2ZWxzID0+IHsKICAgICAgICAgIGlmIChsZXZlbHMubWluICE9PSBudWxsICYmIGxldmVscy5tYXggIT09IG51bGwpIHsKICAgICAgICAgICAgbWFwLnNldE1pblpvb20obGV2ZWxzLm1pbikKICAgICAgICAgICAgbWFwLnNldE1heFpvb20obGV2ZWxzLm1heCkKICAgICAgICAgICAgY29uc29sZS5sb2coYOemu+e6v+eTpueJh+e6p+WIq+ajgOa1izogJHtsZXZlbHMubWlufSAtICR7bGV2ZWxzLm1heH1gKQogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgIH0KICAgIH0sCiAgICAKICAgIGRldGVjdEF2YWlsYWJsZVRpbGVMZXZlbHM6IGZ1bmN0aW9uICgpIHsKICAgICAgY29uc3QgdGhhdCA9IHRoaXMKICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICAgICAgY29uc3QgdGVzdExldmVscyA9IE1hcENvbmZpZy5kZXRlY3Rpb24udGVzdExldmVscwogICAgICAgIGxldCBhdmFpbGFibGVMZXZlbHMgPSBbXQogICAgICAgIGxldCB0ZXN0Q291bnQgPSAwCiAgICAgICAgCiAgICAgICAgdGVzdExldmVscy5mb3JFYWNoKGxldmVsID0+IHsKICAgICAgICAgIGNvbnN0IHRlc3RVcmwgPSBgL3RpbGVzLyR7bGV2ZWx9LzAvMC5wbmdgCiAgICAgICAgICAKICAgICAgICAgIGZldGNoKHRlc3RVcmwsIHsgbWV0aG9kOiAnSEVBRCcgfSkKICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gewogICAgICAgICAgICAgIHRlc3RDb3VudCsrCiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7CiAgICAgICAgICAgICAgICBhdmFpbGFibGVMZXZlbHMucHVzaChsZXZlbCkKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgaWYgKHRlc3RDb3VudCA9PT0gdGVzdExldmVscy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZUxldmVscy5zb3J0KChhLCBiKSA9PiBhIC0gYikKICAgICAgICAgICAgICAgIHJlc29sdmUoewogICAgICAgICAgICAgICAgICBtaW46IGF2YWlsYWJsZUxldmVscy5sZW5ndGggPiAwID8gYXZhaWxhYmxlTGV2ZWxzWzBdIDogbnVsbCwKICAgICAgICAgICAgICAgICAgbWF4OiBhdmFpbGFibGVMZXZlbHMubGVuZ3RoID4gMCA/IGF2YWlsYWJsZUxldmVsc1thdmFpbGFibGVMZXZlbHMubGVuZ3RoIC0gMV0gOiBudWxsLAogICAgICAgICAgICAgICAgICBhdmFpbGFibGU6IGF2YWlsYWJsZUxldmVscwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7CiAgICAgICAgICAgICAgdGVzdENvdW50KysKICAgICAgICAgICAgICBpZiAodGVzdENvdW50ID09PSB0ZXN0TGV2ZWxzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgYXZhaWxhYmxlTGV2ZWxzLnNvcnQoKGEsIGIpID0+IGEgLSBiKQogICAgICAgICAgICAgICAgcmVzb2x2ZSh7CiAgICAgICAgICAgICAgICAgIG1pbjogYXZhaWxhYmxlTGV2ZWxzLmxlbmd0aCA+IDAgPyBhdmFpbGFibGVMZXZlbHNbMF0gOiBudWxsLAogICAgICAgICAgICAgICAgICBtYXg6IGF2YWlsYWJsZUxldmVscy5sZW5ndGggPiAwID8gYXZhaWxhYmxlTGV2ZWxzW2F2YWlsYWJsZUxldmVscy5sZW5ndGggLSAxXSA6IG51bGwsCiAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYXZhaWxhYmxlTGV2ZWxzCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICB9KQogICAgICAgIAogICAgICAgIC8vIOS9v+eUqOmFjee9rueahOi2heaXtuaXtumXtAogICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgaWYgKHRlc3RDb3VudCA8IHRlc3RMZXZlbHMubGVuZ3RoKSB7CiAgICAgICAgICAgIHJlc29sdmUoeyAKICAgICAgICAgICAgICBtaW46IE1hcENvbmZpZy56b29tLm9mZmxpbmUubWluLCAKICAgICAgICAgICAgICBtYXg6IE1hcENvbmZpZy56b29tLm9mZmxpbmUubWF4LCAKICAgICAgICAgICAgICBhdmFpbGFibGU6IFtdIAogICAgICAgICAgICB9KQogICAgICAgICAgfQogICAgICAgIH0sIE1hcENvbmZpZy5kZXRlY3Rpb24udGltZW91dCkKICAgICAgfSkKICAgIH0sCiAgICBpc1ZhbGlkTG9jYXRpb246IGZ1bmN0aW9uIChsb2NhdGlvbikgewogICAgICBpZiAoIWxvY2F0aW9uKSB7CiAgICAgICAgY29uc29sZS5kZWJ1Zygn5L2N572u6aqM6K+BOiDkvY3nva7lr7nosaHkuLrnqbonKQogICAgICAgIHJldHVybiBmYWxzZQogICAgICB9CiAgICAgIAogICAgICAvLyDmo4Dmn6Xlv4XpnIDnmoTlsZ7mgKfmmK/lkKblrZjlnKgKICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5sYXQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBsb2NhdGlvbi5sbmcgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgY29uc29sZS5kZWJ1Zygn5L2N572u6aqM6K+BOiDnvLrlsJFsYXTmiJZsbmflsZ7mgKcnLCBsb2NhdGlvbikKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICAKICAgICAgLy8g5qOA5p+l57uP57qs5bqm5piv5ZCm5Li65pyJ5pWI5pWw5a2XCiAgICAgIGNvbnN0IGxhdCA9IHBhcnNlRmxvYXQobG9jYXRpb24ubGF0KQogICAgICBjb25zdCBsbmcgPSBwYXJzZUZsb2F0KGxvY2F0aW9uLmxuZykKICAgICAgCiAgICAgIGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHsKICAgICAgICBjb25zb2xlLmRlYnVnKCfkvY3nva7pqozor4E6IOWdkOagh+S4jeaYr+acieaViOaVsOWtlycsIHsgbGF0OiBsb2NhdGlvbi5sYXQsIGxuZzogbG9jYXRpb24ubG5nLCBwYXJzZWRMYXQ6IGxhdCwgcGFyc2VkTG5nOiBsbmcgfSkKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICAKICAgICAgLy8g5qOA5p+l57uP57qs5bqm6IyD5Zu0CiAgICAgIGlmIChsYXQgPCAtOTAgfHwgbGF0ID4gOTAgfHwgbG5nIDwgLTE4MCB8fCBsbmcgPiAxODApIHsKICAgICAgICBjb25zb2xlLmRlYnVnKCfkvY3nva7pqozor4E6IOWdkOagh+i2heWHuuacieaViOiMg+WbtCcsIHsgbGF0LCBsbmcgfSkKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICAKICAgICAgLy8g5qOA5p+l5piv5ZCm5piv5p6B5YC877yI5Y+v6IO96KGo56S66ZSZ6K+v5pWw5o2u77yJCiAgICAgIGlmIChsYXQgPT09IDAgJiYgbG5nID09PSAwKSB7CiAgICAgICAgY29uc29sZS5kZWJ1Zygn5L2N572u6aqM6K+BOiDlnZDmoIfkuLooMCwwKe+8jOWPr+iDveaYr+mUmeivr+aVsOaNricpCiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgCiAgICAgIHJldHVybiB0cnVlCiAgICB9LAogICAgc2FuaXRpemVMb2NhdGlvbjogZnVuY3Rpb24gKGxvY2F0aW9uKSB7CiAgICAgIGlmICghbG9jYXRpb24pIHsKICAgICAgICBjb25zb2xlLmRlYnVnKCfkvY3nva7muIXnkIY6IOi+k+WFpeS9jee9ruS4uuepuicpCiAgICAgICAgcmV0dXJuIG51bGwKICAgICAgfQogICAgICAKICAgICAgLy8g56Gu5L+d5pyJ5Z+65pys55qE5Z2Q5qCHCiAgICAgIGNvbnN0IGxhdCA9IHBhcnNlRmxvYXQobG9jYXRpb24ubGF0KQogICAgICBjb25zdCBsbmcgPSBwYXJzZUZsb2F0KGxvY2F0aW9uLmxuZykKICAgICAgCiAgICAgIGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHsKICAgICAgICBjb25zb2xlLmRlYnVnKCfkvY3nva7muIXnkIY6IOaXoOaViOeahOWdkOagh+aVsOaNricsIGxvY2F0aW9uKQogICAgICAgIHJldHVybiBudWxsCiAgICAgIH0KICAgICAgCiAgICAgIGNvbnN0IHNhbml0aXplZCA9IHsKICAgICAgICBsYXQ6IE1hdGgubWF4KC05MCwgTWF0aC5taW4oOTAsIGxhdCkpLCAgICAgLy8g56Gu5L+d57qs5bqm5Zyo5pyJ5pWI6IyD5Zu05YaFCiAgICAgICAgbG5nOiBNYXRoLm1heCgtMTgwLCBNYXRoLm1pbigxODAsIGxuZykpLCAgIC8vIOehruS/nee7j+W6puWcqOacieaViOiMg+WbtOWGhQogICAgICAgIGFjY3VyYWN5OiBwYXJzZUZsb2F0KGxvY2F0aW9uLmFjY3VyYWN5KSB8fCAxMDAsCiAgICAgICAgc2hvcnRfbmFtZTogbG9jYXRpb24uc2hvcnRfbmFtZSB8fCB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duTG9jYXRpb24nKSwKICAgICAgICBjb3VudHJ5OiBsb2NhdGlvbi5jb3VudHJ5IHx8IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25Db3VudHJ5JyksCiAgICAgICAgc3RyZWV0X2FkZHJlc3M6IGxvY2F0aW9uLnN0cmVldF9hZGRyZXNzIHx8ICcnLAogICAgICAgIGNpdHk6IGxvY2F0aW9uLmNpdHkgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwKICAgICAgICBzdGF0ZTogbG9jYXRpb24uc3RhdGUgfHwgJycsCiAgICAgICAgcG9zdGNvZGU6IGxvY2F0aW9uLnBvc3Rjb2RlIHx8ICcnCiAgICAgIH0KICAgICAgCiAgICAgIC8vIOWGjeasoemqjOivgea4heeQhuWQjueahOS9jee9rgogICAgICBpZiAoIXRoaXMuaXNWYWxpZExvY2F0aW9uKHNhbml0aXplZCkpIHsKICAgICAgICBjb25zb2xlLmRlYnVnKCfkvY3nva7muIXnkIY6IOa4heeQhuWQjuS7jeeEtuaXoOaViCcsIHNhbml0aXplZCkKICAgICAgICByZXR1cm4gbnVsbAogICAgICB9CiAgICAgIAogICAgICByZXR1cm4gc2FuaXRpemVkCiAgICB9LAogICAgZml4TGVhZmxldEljb25zOiBmdW5jdGlvbiAoKSB7CiAgICAgIC8vIOS/ruWkjUxlYWZsZXTlm77moIfpl67popgKICAgICAgTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoID0gJ2h0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXRAMS43LjEvZGlzdC9pbWFnZXMvJwogICAgICAKICAgICAgLy8g56Gu5L+d6Kem5bGP5ouW5ou95pSv5oyBCiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICBpZiAodGhpcy4kcmVmcy5teU1hcCAmJiB0aGlzLiRyZWZzLm15TWFwLm1hcE9iamVjdCkgewogICAgICAgICAgY29uc3QgbWFwID0gdGhpcy4kcmVmcy5teU1hcC5tYXBPYmplY3QKICAgICAgICAgIC8vIOWQr+eUqOinpuWxj+aLluaLvQogICAgICAgICAgbWFwLm9wdGlvbnMudG91Y2hab29tID0gdHJ1ZQogICAgICAgICAgbWFwLm9wdGlvbnMudG91Y2hQYW4gPSB0cnVlCiAgICAgICAgfQogICAgICB9KQogICAgfSwKICAgIGdldENpdHlJbmZvOiBmdW5jdGlvbiAocG9zaXRpb24sIHJlcXVlc3RJZCkgewogICAgICAvLyDorr7nva7liqDovb3nirbmgIEKICAgICAgdGhpcy5nZW9Db2RlTG9hZGluZyA9IHRydWUKICAgICAgCiAgICAgIC8vIOWIm+W7ukFib3J0Q29udHJvbGxlcgogICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCkKICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXIKICAgICAgCiAgICAgIC8vIOebtOaOpeWfuuS6juW3suehruWumueahOWcsOWbvuexu+Wei+mAieaLqeWcsOeQhue8lueggeaWueW8j++8iOS4jemHjeWkjeWIpOaWree9kee7nOeKtuaAge+8iQogICAgICBpZiAodGhpcy5jdXJyZW50TWFwVHlwZSA9PT0gJ29ubGluZScpIHsKICAgICAgICByZXR1cm4gdGhpcy5nZXRPbmxpbmVHZW9jb2RpbmdJbmZvKHBvc2l0aW9uLCBhYm9ydENvbnRyb2xsZXIpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2ZmbGluZUdlb2NvZGluZ0luZm8ocG9zaXRpb24pCiAgICAgIH0KICAgIH0sCiAgICAKICAgIC8vIOWcqOe6v+WcsOeQhue8lueggQogICAgZ2V0T25saW5lR2VvY29kaW5nSW5mbzogZnVuY3Rpb24gKHBvc2l0aW9uLCBhYm9ydENvbnRyb2xsZXIpIHsKICAgICAgY29uc29sZS5sb2coJ+S9v+eUqOWcqOe6v+WcsOeQhue8lueggeacjeWKoScpCiAgICAgIAogICAgICAvLyDlsJ3or5XlpJrnp43lnLDnkIbnvJbnoIHmnI3liqHlkoznrZbnlaUKICAgICAgY29uc3QgdHJ5R2VvY29kaW5nID0gYXN5bmMgKCkgPT4gewogICAgICAgIC8vIOetlueVpTE6IOWwneivleS9v+eUqEpTT05Q5pa55byP57uV6L+HQ09SU++8iOWmguaenOacjeWKoeaUr+aMge+8iQogICAgICAgIC8vIOetlueVpTI6IOS9v+eUqOWFrOW8gOeahOS7o+eQhuacjeWKoQogICAgICAgIC8vIOetlueVpTM6IOmZjee6p+WIsOemu+e6v+aooeW8jwogICAgICAgIAogICAgICAgIGNvbnN0IHNlcnZpY2VzID0gWwogICAgICAgICAgewogICAgICAgICAgICBuYW1lOiAnQmlnRGF0YUNsb3VkLUFQSScsCiAgICAgICAgICAgIHVybDogYGh0dHBzOi8vYXBpLmJpZ2RhdGFjbG91ZC5uZXQvZGF0YS9yZXZlcnNlLWdlb2NvZGUtY2xpZW50P2xhdGl0dWRlPSR7cG9zaXRpb24ubGF0fSZsb25naXR1ZGU9JHtwb3NpdGlvbi5sbmd9JmxvY2FsaXR5TGFuZ3VhZ2U9emgtQ05gLAogICAgICAgICAgICBtZXRob2Q6ICdmZXRjaC1jb3JzJwogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgbmFtZTogJ09wZW5DYWdlLURlbW8nLAogICAgICAgICAgICB1cmw6IGBodHRwczovL2FwaS5vcGVuY2FnZWRhdGEuY29tL2dlb2NvZGUvdjEvanNvbj9xPSR7cG9zaXRpb24ubGF0fSske3Bvc2l0aW9uLmxuZ30ma2V5PWRlbW8mbGFuZ3VhZ2U9emgtQ04mcHJldHR5PTEmbm9fYW5ub3RhdGlvbnM9MWAsCiAgICAgICAgICAgIG1ldGhvZDogJ2ZldGNoLWNvcnMnCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICAgIAogICAgICAgIGZvciAoY29uc3Qgc2VydmljZSBvZiBzZXJ2aWNlcykgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgY29uc29sZS5sb2coYOWwneivleS9v+eUqCR7c2VydmljZS5uYW1lfeiOt+WPluWcsOWdgOS/oeaBry4uLmApCiAgICAgICAgICAgIAogICAgICAgICAgICBsZXQgZGF0YQogICAgICAgICAgICBpZiAoc2VydmljZS5tZXRob2QgPT09ICdqc29ucCcpIHsKICAgICAgICAgICAgICAvLyBKU09OUOaWueazlQogICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEpTT05QKHNlcnZpY2UudXJsLCA4MDAwKQogICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZpY2UubWV0aG9kID09PSAnZmV0Y2gtY29ycycpIHsKICAgICAgICAgICAgICAvLyDmlK/mjIFDT1JT55qEQVBJCiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzZXJ2aWNlLnVybCwgewogICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLAogICAgICAgICAgICAgICAgbW9kZTogJ2NvcnMnLAogICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdvbWl0JwogICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NlcnZpY2UubmFtZX0gSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAKICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgLy8g5bi46KeEZmV0Y2jmlrnms5UKICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNlcnZpY2UudXJsLCB7CiAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZXJ2aWNlLmhlYWRlcnMgfHwge30sCiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsCiAgICAgICAgICAgICAgICBtb2RlOiAnY29ycycsCiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ29taXQnCiAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAKICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2VydmljZS5uYW1lfSBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWApCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIAogICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgY29uc29sZS5sb2coYCR7c2VydmljZS5uYW1lfeWTjeW6lDpgLCBkYXRhKQogICAgICAgICAgICAKICAgICAgICAgICAgLy8g5aSE55CG5LiN5ZCM5pyN5Yqh55qE5ZON5bqU5qC85byPCiAgICAgICAgICAgIGxldCBjaXR5SW5mbwogICAgICAgICAgICBpZiAoc2VydmljZS5uYW1lLmluY2x1ZGVzKCdCaWdEYXRhQ2xvdWQnKSkgewogICAgICAgICAgICAgIC8vIEJpZ0RhdGFDbG91ZCBBUEnmoLzlvI8KICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmNpdHkpIHsKICAgICAgICAgICAgICAgIGNpdHlJbmZvID0gewogICAgICAgICAgICAgICAgICBzaG9ydF9uYW1lOiB0aGlzLmZvcm1hdEJpZ0RhdGFDbG91ZExvY2F0aW9uTmFtZShkYXRhKSwKICAgICAgICAgICAgICAgICAgY291bnRyeTogZGF0YS5jb3VudHJ5TmFtZSB8fCB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duQ291bnRyeScpLAogICAgICAgICAgICAgICAgICBzdHJlZXRfYWRkcmVzczogZGF0YS5sb2NhbGl0eSB8fCBkYXRhLmNpdHkgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkFkZHJlc3MnKSwKICAgICAgICAgICAgICAgICAgY2l0eTogZGF0YS5jaXR5IHx8IGRhdGEubG9jYWxpdHkgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwKICAgICAgICAgICAgICAgICAgc3RhdGU6IGRhdGEucHJpbmNpcGFsU3ViZGl2aXNpb24gfHwgJycsCiAgICAgICAgICAgICAgICAgIHBvc3Rjb2RlOiBkYXRhLnBvc3Rjb2RlIHx8ICcnCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZpY2UubmFtZS5pbmNsdWRlcygnT3BlbkNhZ2UnKSkgewogICAgICAgICAgICAgIC8vIE9wZW5DYWdlIEFQSeagvOW8jwogICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucmVzdWx0cyAmJiBkYXRhLnJlc3VsdHMubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0YS5yZXN1bHRzWzBdCiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gcmVzdWx0LmNvbXBvbmVudHMgfHwge30KICAgICAgICAgICAgICAgIGNpdHlJbmZvID0gewogICAgICAgICAgICAgICAgICBzaG9ydF9uYW1lOiB0aGlzLmZvcm1hdE9wZW5DYWdlTG9jYXRpb25OYW1lKGNvbXBvbmVudHMpLAogICAgICAgICAgICAgICAgICBjb3VudHJ5OiBjb21wb25lbnRzLmNvdW50cnkgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNvdW50cnknKSwKICAgICAgICAgICAgICAgICAgc3RyZWV0X2FkZHJlc3M6IHJlc3VsdC5mb3JtYXR0ZWQgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkFkZHJlc3MnKSwKICAgICAgICAgICAgICAgICAgY2l0eTogY29tcG9uZW50cy5jaXR5IHx8IGNvbXBvbmVudHMudG93biB8fCBjb21wb25lbnRzLnZpbGxhZ2UgfHwgY29tcG9uZW50cy5jb3VudHkgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwKICAgICAgICAgICAgICAgICAgc3RhdGU6IGNvbXBvbmVudHMuc3RhdGUgfHwgY29tcG9uZW50cy5wcm92aW5jZSB8fCAnJywKICAgICAgICAgICAgICAgICAgcG9zdGNvZGU6IGNvbXBvbmVudHMucG9zdGNvZGUgfHwgJycKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgLy8gTm9taW5hdGlt5qC85byPCiAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgKGRhdGEuZGlzcGxheV9uYW1lIHx8IGRhdGEubmFtZSkpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBkYXRhLmFkZHJlc3MgfHwge30KICAgICAgICAgICAgICAgIGNpdHlJbmZvID0gewogICAgICAgICAgICAgICAgICBzaG9ydF9uYW1lOiB0aGlzLmZvcm1hdExvY2F0aW9uTmFtZShhZGRyZXNzKSwKICAgICAgICAgICAgICAgICAgY291bnRyeTogYWRkcmVzcy5jb3VudHJ5IHx8IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25Db3VudHJ5JyksCiAgICAgICAgICAgICAgICAgIHN0cmVldF9hZGRyZXNzOiBkYXRhLmRpc3BsYXlfbmFtZSB8fCBkYXRhLm5hbWUgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkFkZHJlc3MnKSwKICAgICAgICAgICAgICAgICAgY2l0eTogYWRkcmVzcy5jaXR5IHx8IGFkZHJlc3MudG93biB8fCBhZGRyZXNzLnZpbGxhZ2UgfHwgYWRkcmVzcy5jb3VudHkgfHwgdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwKICAgICAgICAgICAgICAgICAgc3RhdGU6IGFkZHJlc3Muc3RhdGUgfHwgYWRkcmVzcy5wcm92aW5jZSB8fCAnJywKICAgICAgICAgICAgICAgICAgcG9zdGNvZGU6IGFkZHJlc3MucG9zdGNvZGUgfHwgJycKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChjaXR5SW5mbykgewogICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke3NlcnZpY2UubmFtZX3miJDlip/ojrflj5blnLDlnYDkv6Hmga9gKQogICAgICAgICAgICAgIHJldHVybiBjaXR5SW5mbwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzZXJ2aWNlLm5hbWV95pyq6L+U5Zue5pyJ5pWI5Zyw5Z2A5L+h5oGvYCkKICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3NlcnZpY2UubmFtZX3lpLHotKU6YCwgZXJyb3IubWVzc2FnZSkKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIOWmguaenOaYr+WPlua2iOivt+axgu+8jOebtOaOpeaKm+WHugogICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7CiAgICAgICAgICAgICAgdGhyb3cgZXJyb3IKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLy8g57un57ut5bCd6K+V5LiL5LiA5Liq5pyN5YqhCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOaJgOacieWcqOe6v+acjeWKoemDveWksei0peS6hu+8jOmZjee6p+WIsOemu+e6v+aooeW8jwogICAgICAgIGNvbnNvbGUubG9nKCfmiYDmnInlnKjnur/lnLDnkIbnvJbnoIHmnI3liqHpg73lpLHotKXvvIzpmY3nuqfliLDnprvnur/mqKHlvI8nKQogICAgICAgIHRocm93IG5ldyBFcnJvcign5omA5pyJ5Zyo57q/5Zyw55CG57yW56CB5pyN5Yqh6YO95LiN5Y+v55SoJykKICAgICAgfQogICAgICAKICAgICAgLy8g5Yib5bu65bim6LaF5pe255qEUHJvbWlzZQogICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHsKICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ+WcqOe6v+WcsOeQhue8lueggei2heaXticpKSwgNjAwMCkgLy8gNuenkui2heaXtgogICAgICB9KQogICAgICAKICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbdHJ5R2VvY29kaW5nKCksIHRpbWVvdXRQcm9taXNlXSkKICAgICAgLmNhdGNoKGVycm9yID0+IHsKICAgICAgICBjb25zb2xlLndhcm4oJ+WcqOe6v+WcsOeQhue8lueggeWksei0pe+8jOmZjee6p+WIsOemu+e6v+aooeW8jzonLCBlcnJvci5tZXNzYWdlKQogICAgICAgIAogICAgICAgIC8vIOWmguaenOaYr+WPlua2iOivt+axgu+8jOebtOaOpeaKm+WHugogICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHsKICAgICAgICAgIHRocm93IGVycm9yCiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOmZjee6p+WIsOemu+e6v+aooeW8jwogICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlT2ZmbGluZUxvY2F0aW9uSW5mbyhwb3NpdGlvbikKICAgICAgfSkKICAgICAgLmZpbmFsbHkoKCkgPT4gewogICAgICAgIC8vIOa4hemZpOWKoOi9veeKtuaAgQogICAgICAgIHRoaXMuZ2VvQ29kZUxvYWRpbmcgPSBmYWxzZQogICAgICAgIGlmICh0aGlzLmFib3J0Q29udHJvbGxlciA9PT0gYWJvcnRDb250cm9sbGVyKSB7CiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG51bGwKICAgICAgICB9CiAgICAgIH0pCiAgICB9LAogICAgCiAgICAvLyBKU09OUOi+heWKqeaWueazlQogICAgZmV0Y2hXaXRoSlNPTlA6IGZ1bmN0aW9uICh1cmwsIHRpbWVvdXQgPSA4MDAwKSB7CiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgICAgICAgY29uc3QgY2FsbGJhY2tOYW1lID0gJ2pzb25wX2NhbGxiYWNrXycgKyBNYXRoLnJvdW5kKDEwMDAwMCAqIE1hdGgucmFuZG9tKCkpCiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykKICAgICAgICAKICAgICAgICAvLyDorr7nva7otoXml7YKICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIGNsZWFudXAoKQogICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSlNPTlDor7fmsYLotoXml7YnKSkKICAgICAgICB9LCB0aW1lb3V0KQogICAgICAgIAogICAgICAgIC8vIOa4heeQhuWHveaVsAogICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7CiAgICAgICAgICBpZiAoc2NyaXB0LnBhcmVudE5vZGUpIHsKICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KQogICAgICAgICAgfQogICAgICAgICAgaWYgKHdpbmRvd1tjYWxsYmFja05hbWVdKSB7CiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tOYW1lXQogICAgICAgICAgfQogICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8g6K6+572u5Zue6LCDCiAgICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSAoZGF0YSkgPT4gewogICAgICAgICAgY2xlYW51cCgpCiAgICAgICAgICByZXNvbHZlKGRhdGEpCiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOWkhOeQhumUmeivrwogICAgICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT4gewogICAgICAgICAgY2xlYW51cCgpCiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdKU09OUOiEmuacrOWKoOi9veWksei0pScpKQogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDmiafooYzor7fmsYIgLSDkv67lpI3lm57osIPlh73mlbDlkI3np7Dmm7/mjaIKICAgICAgICBjb25zdCBmaW5hbFVybCA9IHVybC5yZXBsYWNlKCdDQUxMQkFDS19QTEFDRUhPTERFUicsIGNhbGxiYWNrTmFtZSkKICAgICAgICBzY3JpcHQuc3JjID0gZmluYWxVcmwKICAgICAgICBjb25zb2xlLmxvZygnSlNPTlDor7fmsYJVUkw6JywgZmluYWxVcmwpCiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpCiAgICAgIH0pCiAgICB9LAogICAgCiAgICAvLyDnprvnur/lnLDnkIbnvJbnoIEKICAgIGdldE9mZmxpbmVHZW9jb2RpbmdJbmZvOiBmdW5jdGlvbiAocG9zaXRpb24pIHsKICAgICAgY29uc29sZS5sb2coJ+S9v+eUqOemu+e6v+WcsOeQhue8lueggScpCiAgICAgIAogICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAvLyDmqKHmi5/nn63mmoLnmoTliqDovb3ml7bpl7QKICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIC8vIOWfuuS6juWdkOagh+eUn+aIkOWfuuacrOWcsOeQhuS/oeaBrwogICAgICAgICAgY29uc3QgY2l0eUluZm8gPSB0aGlzLmdlbmVyYXRlT2ZmbGluZUxvY2F0aW9uSW5mbyhwb3NpdGlvbikKICAgICAgICAgIAogICAgICAgICAgY29uc29sZS5sb2coJ+emu+e6v+S9jee9ruS/oeaBr+eUn+aIkDonLCBjaXR5SW5mby5zaG9ydF9uYW1lKQogICAgICAgICAgcmVzb2x2ZShjaXR5SW5mbykKICAgICAgICB9LCAyMDApIC8vIDIwMG1z5bu26L+f77yM5o+Q5L6b6Imv5aW955qE55So5oi35L2T6aqMCiAgICAgIH0pCiAgICAgIC5maW5hbGx5KCgpID0+IHsKICAgICAgICAvLyDmuIXpmaTliqDovb3nirbmgIEKICAgICAgICB0aGlzLmdlb0NvZGVMb2FkaW5nID0gZmFsc2UKICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG51bGwKICAgICAgfSkKICAgIH0sCiAgICBnZW5lcmF0ZU9mZmxpbmVMb2NhdGlvbkluZm86IGZ1bmN0aW9uIChwb3NpdGlvbikgewogICAgICBjb25zdCBsYXQgPSBwb3NpdGlvbi5sYXQKICAgICAgY29uc3QgbG5nID0gcG9zaXRpb24ubG5nCiAgICAgIAogICAgICAvLyDnoa7lrprlpKfoh7TnmoTlnLDnkIbljLrln58KICAgICAgbGV0IHJlZ2lvbkluZm8gPSB0aGlzLmRldGVybWluZVJlZ2lvbihsYXQsIGxuZykKICAgICAgCiAgICAgIC8vIOeUn+aIkOS9jee9ruWQjeensAogICAgICBjb25zdCBsb2NhdGlvbk5hbWUgPSBgJHtyZWdpb25JbmZvLnJlZ2lvbn3lnLDljLpgCiAgICAgIAogICAgICByZXR1cm4gewogICAgICAgIHNob3J0X25hbWU6IGxvY2F0aW9uTmFtZSwKICAgICAgICBjb3VudHJ5OiByZWdpb25JbmZvLmNvdW50cnksCiAgICAgICAgc3RyZWV0X2FkZHJlc3M6IGDlnZDmoIc6ICR7bGF0LnRvRml4ZWQoNil9LCAke2xuZy50b0ZpeGVkKDYpfWAsCiAgICAgICAgY2l0eTogcmVnaW9uSW5mby5jaXR5LAogICAgICAgIHN0YXRlOiByZWdpb25JbmZvLnN0YXRlLAogICAgICAgIHBvc3Rjb2RlOiAnJwogICAgICB9CiAgICB9LAogICAgCiAgICBkZXRlcm1pbmVSZWdpb246IGZ1bmN0aW9uIChsYXQsIGxuZykgewogICAgICAvLyDln7rkuo7lnZDmoIfojIPlm7Tnoa7lrprlpKfoh7TlnLDnkIbljLrln5/vvIjnprvnur/pgLvovpHvvIkKICAgICAgCiAgICAgIC8vIOS4reWbveWMuuWfn+WIpOaWrQogICAgICBpZiAobGF0ID49IDE4ICYmIGxhdCA8PSA1NCAmJiBsbmcgPj0gNzMgJiYgbG5nIDw9IDEzNSkgewogICAgICAgIGlmIChsYXQgPj0gMzkuNCAmJiBsYXQgPD0gNDEuMSAmJiBsbmcgPj0gMTE1LjQgJiYgbG5nIDw9IDExNy41KSB7CiAgICAgICAgICByZXR1cm4geyByZWdpb246IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmJlaWppbmcnKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2hpbmEnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuYmVpamluZ0NpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmJlaWppbmdDaXR5JykgfQogICAgICAgIH0gZWxzZSBpZiAobGF0ID49IDMwLjggJiYgbGF0IDw9IDMxLjkgJiYgbG5nID49IDEyMC45ICYmIGxuZyA8PSAxMjIuMCkgewogICAgICAgICAgcmV0dXJuIHsgcmVnaW9uOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5zaGFuZ2hhaScpLCBjb3VudHJ5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci5jaGluYScpLCBjaXR5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci5zaGFuZ2hhaUNpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnNoYW5naGFpQ2l0eScpIH0KICAgICAgICB9IGVsc2UgaWYgKGxhdCA+PSAyMi40ICYmIGxhdCA8PSAyMy42ICYmIGxuZyA+PSAxMTMuOCAmJiBsbmcgPD0gMTE0LjYpIHsKICAgICAgICAgIHJldHVybiB7IHJlZ2lvbjogdGhpcy4kdCgnbG9jYXRpb25NZ3Iuc2hlbnpoZW4nKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2hpbmEnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3Iuc2hlbnpoZW5DaXR5JyksIHN0YXRlOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5ndWFuZ2RvbmdQcm92aW5jZScpIH0KICAgICAgICB9IGVsc2UgaWYgKGxhdCA+PSAzMC4xICYmIGxhdCA8PSAzMC45ICYmIGxuZyA+PSAxMDMuOSAmJiBsbmcgPD0gMTA0LjkpIHsKICAgICAgICAgIHJldHVybiB7IHJlZ2lvbjogdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2hlbmdkdScpLCBjb3VudHJ5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci5jaGluYScpLCBjaXR5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci5jaGVuZ2R1Q2l0eScpLCBzdGF0ZTogdGhpcy4kdCgnbG9jYXRpb25NZ3Iuc2ljaHVhblByb3ZpbmNlJykgfQogICAgICAgIH0gZWxzZSBpZiAobGF0ID49IDIyLjAgJiYgbGF0IDw9IDIzLjYgJiYgbG5nID49IDExMi45ICYmIGxuZyA8PSAxMTQuMCkgewogICAgICAgICAgcmV0dXJuIHsgcmVnaW9uOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5ndWFuZ3pob3UnKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2hpbmEnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuZ3Vhbmd6aG91Q2l0eScpLCBzdGF0ZTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuZ3Vhbmdkb25nUHJvdmluY2UnKSB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiB7IHJlZ2lvbjogdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2hpbmEnKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2hpbmEnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25Qcm92aW5jZScpIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOWFtuS7luS4u+imgeWbveWuti/lnLDljLoKICAgICAgaWYgKGxhdCA+PSAyNC41ICYmIGxhdCA8PSA0OS40ICYmIGxuZyA+PSAtMTI1ICYmIGxuZyA8PSAtNjYpIHsKICAgICAgICByZXR1cm4geyByZWdpb246IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVzYScpLCBjb3VudHJ5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci51c2EnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25TdGF0ZScpIH0KICAgICAgfSBlbHNlIGlmIChsYXQgPj0gNDUuOCAmJiBsYXQgPD0gNzEuMCAmJiBsbmcgPj0gLTE0MSAmJiBsbmcgPD0gLTUyKSB7CiAgICAgICAgcmV0dXJuIHsgcmVnaW9uOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5jYW5hZGEnKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2FuYWRhJyksIGNpdHk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25DaXR5JyksIHN0YXRlOiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duUHJvdmluY2UnKSB9CiAgICAgIH0gZWxzZSBpZiAobGF0ID49IDM1LjggJiYgbGF0IDw9IDQ1LjYgJiYgbG5nID49IDEzOC43ICYmIGxuZyA8PSAxNDYuMCkgewogICAgICAgIHJldHVybiB7IHJlZ2lvbjogdGhpcy4kdCgnbG9jYXRpb25NZ3IuamFwYW4nKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuamFwYW4nKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25QcmVmZWN0dXJlJykgfQogICAgICB9IGVsc2UgaWYgKGxhdCA+PSAzMy4wICYmIGxhdCA8PSAzOC42ICYmIGxuZyA+PSAxMjQuNiAmJiBsbmcgPD0gMTMwLjkpIHsKICAgICAgICByZXR1cm4geyByZWdpb246IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmtvcmVhJyksIGNvdW50cnk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmtvcmVhJyksIGNpdHk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25DaXR5JyksIHN0YXRlOiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duUHJvdmluY2UnKSB9CiAgICAgIH0gZWxzZSBpZiAobGF0ID49IDM2LjAgJiYgbGF0IDw9IDcxLjIgJiYgbG5nID49IC0xMS4wICYmIGxuZyA8PSAzMi4wKSB7CiAgICAgICAgcmV0dXJuIHsgcmVnaW9uOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5ldXJvcGUnKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuZXVyb3BlJyksIGNpdHk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25DaXR5JyksIHN0YXRlOiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duUmVnaW9uJykgfQogICAgICB9CiAgICAgIAogICAgICAvLyDmoLnmja7nu4/nuqzluqbnoa7lrprlpKfmtLIKICAgICAgaWYgKGxhdCA+PSAtNTUgJiYgbGF0IDw9IDcxKSB7CiAgICAgICAgaWYgKGxuZyA+PSAtMTY4ICYmIGxuZyA8PSAtMzApIHsKICAgICAgICAgIHJldHVybiB7IHJlZ2lvbjogdGhpcy4kdCgnbG9jYXRpb25NZ3IuYW1lcmljYXMnKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuYW1lcmljYXMnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25SZWdpb24nKSB9CiAgICAgICAgfSBlbHNlIGlmIChsbmcgPj0gLTExICYmIGxuZyA8PSAxODApIHsKICAgICAgICAgIGlmIChsYXQgPj0gLTQ3ICYmIGxuZyA+PSAxMTApIHsKICAgICAgICAgICAgcmV0dXJuIHsgcmVnaW9uOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5vY2VhbmlhJyksIGNvdW50cnk6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLm9jZWFuaWEnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25SZWdpb24nKSB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4geyByZWdpb246IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmFzaWEnKSwgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IuYXNpYScpLCBjaXR5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duQ2l0eScpLCBzdGF0ZTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93blJlZ2lvbicpIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAobGF0ID49IC01NSAmJiBsYXQgPD0gMzcgJiYgbG5nID49IC0yMCAmJiBsbmcgPD0gNTUpIHsKICAgICAgICByZXR1cm4geyByZWdpb246IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLmFmcmljYScpLCBjb3VudHJ5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci5hZnJpY2EnKSwgY2l0eTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93bkNpdHknKSwgc3RhdGU6IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25SZWdpb24nKSB9CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOm7mOiupOS9jee9rgogICAgICByZXR1cm4geyAKICAgICAgICByZWdpb246IHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd24nKSwgCiAgICAgICAgY291bnRyeTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93blJlZ2lvbicpLCAKICAgICAgICBjaXR5OiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duQ2l0eScpLCAKICAgICAgICBzdGF0ZTogdGhpcy4kdCgnbG9jYXRpb25NZ3IudW5rbm93blJlZ2lvbicpIAogICAgICB9CiAgICB9LAogICAgZm9ybWF0TG9jYXRpb25OYW1lOiBmdW5jdGlvbiAoYWRkcmVzcykgewogICAgICAvLyDmoLzlvI/ljJbkvY3nva7lkI3np7DvvIzkvJjlhYjmmL7npLrln47luILkv6Hmga8KICAgICAgY29uc3QgY2l0eSA9IGFkZHJlc3MuY2l0eSB8fCBhZGRyZXNzLnRvd24gfHwgYWRkcmVzcy52aWxsYWdlIHx8IGFkZHJlc3MuY291bnR5CiAgICAgIGNvbnN0IHN0YXRlID0gYWRkcmVzcy5zdGF0ZSB8fCBhZGRyZXNzLnByb3ZpbmNlCiAgICAgIGNvbnN0IGNvdW50cnkgPSBhZGRyZXNzLmNvdW50cnkKICAgICAgCiAgICAgIGlmIChjaXR5ICYmIHN0YXRlKSB7CiAgICAgICAgcmV0dXJuIGAke2NpdHl9LCAke3N0YXRlfWAKICAgICAgfSBlbHNlIGlmIChjaXR5KSB7CiAgICAgICAgcmV0dXJuIGNpdHkKICAgICAgfSBlbHNlIGlmIChzdGF0ZSkgewogICAgICAgIHJldHVybiBzdGF0ZQogICAgICB9IGVsc2UgaWYgKGNvdW50cnkpIHsKICAgICAgICByZXR1cm4gY291bnRyeQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duTG9jYXRpb24nKQogICAgICB9CiAgICB9LAogICAgZm9ybWF0QmlnRGF0YUNsb3VkTG9jYXRpb25OYW1lOiBmdW5jdGlvbiAoZGF0YSkgewogICAgICAvLyDmoLzlvI/ljJZCaWdEYXRhQ2xvdWQgQVBJ55qE5L2N572u5ZCN56ewCiAgICAgIGNvbnN0IGNpdHkgPSBkYXRhLmNpdHkgfHwgZGF0YS5sb2NhbGl0eQogICAgICBjb25zdCBzdGF0ZSA9IGRhdGEucHJpbmNpcGFsU3ViZGl2aXNpb24KICAgICAgY29uc3QgY291bnRyeSA9IGRhdGEuY291bnRyeU5hbWUKICAgICAgCiAgICAgIGlmIChjaXR5ICYmIHN0YXRlKSB7CiAgICAgICAgcmV0dXJuIGAke2NpdHl9LCAke3N0YXRlfWAKICAgICAgfSBlbHNlIGlmIChjaXR5KSB7CiAgICAgICAgcmV0dXJuIGNpdHkKICAgICAgfSBlbHNlIGlmIChzdGF0ZSkgewogICAgICAgIHJldHVybiBzdGF0ZQogICAgICB9IGVsc2UgaWYgKGNvdW50cnkpIHsKICAgICAgICByZXR1cm4gY291bnRyeQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB0aGlzLiR0KCdsb2NhdGlvbk1nci51bmtub3duTG9jYXRpb24nKQogICAgICB9CiAgICB9LAogICAgZm9ybWF0T3BlbkNhZ2VMb2NhdGlvbk5hbWU6IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7CiAgICAgIC8vIOagvOW8j+WMlk9wZW5DYWdlIEFQSeeahOS9jee9ruWQjeensAogICAgICBjb25zdCBjaXR5ID0gY29tcG9uZW50cy5jaXR5IHx8IGNvbXBvbmVudHMudG93biB8fCBjb21wb25lbnRzLnZpbGxhZ2UgfHwgY29tcG9uZW50cy5jb3VudHkKICAgICAgY29uc3Qgc3RhdGUgPSBjb21wb25lbnRzLnN0YXRlIHx8IGNvbXBvbmVudHMucHJvdmluY2UKICAgICAgY29uc3QgY291bnRyeSA9IGNvbXBvbmVudHMuY291bnRyeQogICAgICAKICAgICAgaWYgKGNpdHkgJiYgc3RhdGUpIHsKICAgICAgICByZXR1cm4gYCR7Y2l0eX0sICR7c3RhdGV9YAogICAgICB9IGVsc2UgaWYgKGNpdHkpIHsKICAgICAgICByZXR1cm4gY2l0eQogICAgICB9IGVsc2UgaWYgKHN0YXRlKSB7CiAgICAgICAgcmV0dXJuIHN0YXRlCiAgICAgIH0gZWxzZSBpZiAoY291bnRyeSkgewogICAgICAgIHJldHVybiBjb3VudHJ5CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHQoJ2xvY2F0aW9uTWdyLnVua25vd25Mb2NhdGlvbicpCiAgICAgIH0KICAgIH0sCiAgICBnZXRNYXBTdGF0dXNDb2xvcjogZnVuY3Rpb24gKCkgewogICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudE1hcFR5cGUpIHsKICAgICAgICBjYXNlICdvbmxpbmUnOgogICAgICAgICAgcmV0dXJuICdncmVlbicKICAgICAgICBjYXNlICdvZmZsaW5lJzoKICAgICAgICAgIHJldHVybiB0aGlzLnVzZU9ubGluZU1hcCA/ICdvcmFuZ2UnIDogJ2JsdWUnCiAgICAgICAgY2FzZSAnY2hlY2tpbmcnOgogICAgICAgICAgcmV0dXJuICdncmV5JwogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gJ3JlZCcKICAgICAgfQogICAgfSwKICAgIGdldE1hcFN0YXR1c0ljb246IGZ1bmN0aW9uICgpIHsKICAgICAgc3dpdGNoICh0aGlzLmN1cnJlbnRNYXBUeXBlKSB7CiAgICAgICAgY2FzZSAnb25saW5lJzoKICAgICAgICAgIHJldHVybiAnbWRpLWNsb3VkLWNoZWNrJwogICAgICAgIGNhc2UgJ29mZmxpbmUnOgogICAgICAgICAgcmV0dXJuICdtZGktY2xvdWQtb2ZmJwogICAgICAgIGNhc2UgJ2NoZWNraW5nJzoKICAgICAgICAgIHJldHVybiAnbWRpLWxvYWRpbmcgbWRpLXNwaW4nCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldHVybiAnbWRpLWFsZXJ0LWNpcmNsZScKICAgICAgfQogICAgfSwKICAgIGdldE1hcFN0YXR1c1RleHQ6IGZ1bmN0aW9uICgpIHsKICAgICAgc3dpdGNoICh0aGlzLmN1cnJlbnRNYXBUeXBlKSB7CiAgICAgICAgY2FzZSAnb25saW5lJzoKICAgICAgICAgIHJldHVybiB0aGlzLiR0KCdsb2NhdGlvbk1nci5vbmxpbmVNYXAnKQogICAgICAgIGNhc2UgJ29mZmxpbmUnOgogICAgICAgICAgcmV0dXJuIHRoaXMudXNlT25saW5lTWFwID8gdGhpcy4kdCgnbG9jYXRpb25NZ3Iub2ZmbGluZU1hcEZhbGxiYWNrJykgOiB0aGlzLiR0KCdsb2NhdGlvbk1nci5vZmZsaW5lTWFwJykKICAgICAgICBjYXNlICdjaGVja2luZyc6CiAgICAgICAgICByZXR1cm4gdGhpcy4kdCgnbG9jYXRpb25NZ3IuY2hlY2tpbmcnKQogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gdGhpcy4kdCgnbG9jYXRpb25NZ3IuY29ubmVjdGlvbkZhaWxlZCcpCiAgICAgIH0KICAgIH0sCiAgICBvbk1hcFR5cGVUb2dnbGU6IGZ1bmN0aW9uICgpIHsKICAgICAgLy8g55So5oi35YiH5o2i5Zyw5Zu+5qih5byPCiAgICAgIGNvbnNvbGUubG9nKCfnlKjmiLfliIfmjaLlnLDlm77mqKHlvI/kuLo6JywgdGhpcy51c2VPbmxpbmVNYXAgPyAn5Zyo57q/5Zyw5Zu+JyA6ICfnprvnur/lnLDlm74nKQogICAgICAKICAgICAgaWYgKHRoaXMudXNlT25saW5lTWFwKSB7CiAgICAgICAgLy8g55So5oi36YCJ5oup5Zyo57q/5qih5byP77yM5qOA5rWL572R57uc5bm25bCd6K+V5L2/55So5Zyo57q/5Zyw5Zu+CiAgICAgICAgdGhpcy5kZXRlY3RBbmRTZXRNYXBUeXBlKCkKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyDnlKjmiLfpgInmi6nnprvnur/mqKHlvI/vvIznm7TmjqXliIfmjaLliLDnprvnur/lnLDlm74KICAgICAgICB0aGlzLmN1cnJlbnRNYXBUeXBlID0gJ29mZmxpbmUnCiAgICAgICAgdGhpcy51cmwgPSB0aGlzLmZhbGxiYWNrVXJsCiAgICAgICAgY29uc29sZS5sb2coJ/CflKcg55So5oi35omL5Yqo6YCJ5oup56a757q/5Zyw5Zu+JykKICAgICAgICAKICAgICAgICAvLyDmm7TmlrDnvKnmlL7pmZDliLYKICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICBpZiAodGhpcy4kcmVmcy5teU1hcCAmJiB0aGlzLiRyZWZzLm15TWFwLm1hcE9iamVjdCkgewogICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLiRyZWZzLm15TWFwLm1hcE9iamVjdAogICAgICAgICAgICBtYXAuaW52YWxpZGF0ZVNpemUoKQogICAgICAgICAgICB0aGlzLnVwZGF0ZVpvb21MaW1pdHMobWFwKQogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgIH0KICAgIH0sCiAgICAKICAgIC8vIOe9kee7nOi/nuaOpeajgOa1iwogICAgY2hlY2tOZXR3b3JrQ29ubmVjdGlvbjogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAvLyDmlrnms5UxOiDmo4DmtYtuYXZpZ2F0b3Iub25MaW5lCiAgICAgICAgaWYgKCFuYXZpZ2F0b3Iub25MaW5lKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygn572R57uc5qOA5rWLOiBuYXZpZ2F0b3Iub25MaW5l5Li6ZmFsc2UnKQogICAgICAgICAgcmVzb2x2ZShmYWxzZSkKICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDmlrnms5UyOiDlsJ3or5Xorr/pl67lnLDnkIbnvJbnoIHmnI3liqHmnaXmtYvor5XnvZHnu5wKICAgICAgICBjb25zdCB0ZXN0VXJscyA9IFsKICAgICAgICAgIC8vIOebtOaOpea1i+ivleWcsOeQhue8lueggeacjeWKoQogICAgICAgICAgJ2h0dHBzOi8vbm9taW5hdGltLm9wZW5zdHJlZXRtYXAub3JnL3JldmVyc2U/Zm9ybWF0PWpzb24mbGF0PTQwJmxvbj0xMTYmYWNjZXB0LWxhbmd1YWdlPWVuJywKICAgICAgICAgIC8vIOWkh+eUqOa1i+ivlQogICAgICAgICAgJ2h0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2Zhdmljb24uaWNvJwogICAgICAgIF0KICAgICAgICAKICAgICAgICBsZXQgY29tcGxldGVkID0gMAogICAgICAgIGxldCBoYXNTdWNjZXNzID0gZmFsc2UKICAgICAgICBjb25zdCB0aW1lb3V0ID0gMzAwMCAvLyDlh4/lsJHliLAz56eS6LaF5pe2CiAgICAgICAgCiAgICAgICAgdGVzdFVybHMuZm9yRWFjaCgodXJsLCBpbmRleCkgPT4gewogICAgICAgICAgLy8g5L2/55SoZmV0Y2jmtYvor5XvvIzmm7Tlh4bnoa4KICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCkKICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KQogICAgICAgICAgCiAgICAgICAgICBmZXRjaCh1cmwsIHsKICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsCiAgICAgICAgICAgIG1vZGU6ICduby1jb3JzJywgLy8g6YG/5YWNQ09SU+mXrumimAogICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLAogICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJwogICAgICAgICAgfSkKICAgICAgICAgIC50aGVuKCgpID0+IHsKICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkKICAgICAgICAgICAgaWYgKCFoYXNTdWNjZXNzKSB7CiAgICAgICAgICAgICAgaGFzU3VjY2VzcyA9IHRydWUKICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg572R57uc5qOA5rWLOiAke3VybH0g6L+e5o6l5oiQ5YqfYCkKICAgICAgICAgICAgICByZXNvbHZlKHRydWUpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pCiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gewogICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKQogICAgICAgICAgICBjb21wbGV0ZWQrKwogICAgICAgICAgICBjb25zb2xlLmxvZyhg572R57uc5qOA5rWLOiAke3VybH0g6L+e5o6l5aSx6LSlOmAsIGVycm9yLm5hbWUpCiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT09IHRlc3RVcmxzLmxlbmd0aCAmJiAhaGFzU3VjY2VzcykgewogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfnvZHnu5zmo4DmtYs6IOaJgOaciea1i+ivlemDveWksei0pe+8jOWIpOWumue9kee7nOS4jeWPr+eUqCcpCiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSkKICAgICAgICAgICAgfQogICAgICAgICAgfSkKICAgICAgICB9KQogICAgICAgIAogICAgICAgIC8vIOaAu+S9k+i2heaXtgogICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgaWYgKCFoYXNTdWNjZXNzKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfnvZHnu5zmo4DmtYs6IOi2heaXtu+8jOWIpOWumue9kee7nOS4jeWPr+eUqCcpCiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpCiAgICAgICAgICB9CiAgICAgICAgfSwgdGltZW91dCArIDUwMCkKICAgICAgfSkKICAgIH0sCiAgICAKICAgIC8vIOajgOa1i+WcqOe6v+WcsOWbvuWPr+eUqOaApwogICAgY2hlY2tPbmxpbmVNYXBBdmFpbGFiaWxpdHk6IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICAgICAgY29uc3QgdGVzdFVybHMgPSBbCiAgICAgICAgICAnaHR0cHM6Ly9hLnRpbGUub3BlbnN0cmVldG1hcC5vcmcvMC8wLzAucG5nJywKICAgICAgICAgICdodHRwczovL2IudGlsZS5vcGVuc3RyZWV0bWFwLm9yZy8wLzAvMC5wbmcnLAogICAgICAgICAgJ2h0dHBzOi8vYy50aWxlLm9wZW5zdHJlZXRtYXAub3JnLzAvMC8wLnBuZycKICAgICAgICBdCiAgICAgICAgCiAgICAgICAgbGV0IGNvbXBsZXRlZCA9IDAKICAgICAgICBsZXQgaGFzU3VjY2VzcyA9IGZhbHNlCiAgICAgICAgCiAgICAgICAgdGVzdFVybHMuZm9yRWFjaCh1cmwgPT4gewogICAgICAgICAgZmV0Y2godXJsLCB7IAogICAgICAgICAgICBtZXRob2Q6ICdIRUFEJywgCiAgICAgICAgICAgIG1vZGU6ICduby1jb3JzJywKICAgICAgICAgICAgY2FjaGU6ICduby1jYWNoZScKICAgICAgICAgIH0pCiAgICAgICAgICAudGhlbigoKSA9PiB7CiAgICAgICAgICAgIGlmICghaGFzU3VjY2VzcykgewogICAgICAgICAgICAgIGhhc1N1Y2Nlc3MgPSB0cnVlCiAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKQogICAgICAgICAgICB9CiAgICAgICAgICB9KQogICAgICAgICAgLmNhdGNoKCgpID0+IHsKICAgICAgICAgICAgY29tcGxldGVkKysKICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gdGVzdFVybHMubGVuZ3RoICYmICFoYXNTdWNjZXNzKSB7CiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSkKICAgICAgICAgICAgfQogICAgICAgICAgfSkKICAgICAgICB9KQogICAgICAgIAogICAgICAgIC8vIDPnp5LotoXml7YKICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIGlmICghaGFzU3VjY2VzcykgewogICAgICAgICAgICByZXNvbHZlKGZhbHNlKQogICAgICAgICAgfQogICAgICAgIH0sIDMwMDApCiAgICAgIH0pCiAgICB9LAogICAgCiAgICAvLyDmo4DmtYvlubborr7nva7lnLDlm77nsbvlnovvvIjku4XlnKjnlKjmiLfpgInmi6nlnKjnur/mqKHlvI/ml7bosIPnlKjvvIkKICAgIGRldGVjdEFuZFNldE1hcFR5cGU6IGFzeW5jIGZ1bmN0aW9uICgpIHsKICAgICAgdGhpcy5jdXJyZW50TWFwVHlwZSA9ICdjaGVja2luZycKICAgICAgY29uc29sZS5sb2coJ+ajgOa1i+WcqOe6v+WcsOWbvuWPr+eUqOaApy4uLicpCiAgICAgIAogICAgICB0cnkgewogICAgICAgIC8vIOajgOa1i+e9kee7nOi/nuaOpQogICAgICAgIHRoaXMuaXNOZXR3b3JrQ29ubmVjdGVkID0gYXdhaXQgdGhpcy5jaGVja05ldHdvcmtDb25uZWN0aW9uKCkKICAgICAgICBjb25zb2xlLmxvZygn572R57uc6L+e5o6l54q25oCBOicsIHRoaXMuaXNOZXR3b3JrQ29ubmVjdGVkKQogICAgICAgIAogICAgICAgIGlmICh0aGlzLmlzTmV0d29ya0Nvbm5lY3RlZCkgewogICAgICAgICAgLy8g5qOA5rWL5Zyo57q/5Zyw5Zu+5Y+v55So5oCnCiAgICAgICAgICB0aGlzLmlzT25saW5lTWFwQXZhaWxhYmxlID0gYXdhaXQgdGhpcy5jaGVja09ubGluZU1hcEF2YWlsYWJpbGl0eSgpCiAgICAgICAgICBjb25zb2xlLmxvZygn5Zyo57q/5Zyw5Zu+5Y+v55So5oCnOicsIHRoaXMuaXNPbmxpbmVNYXBBdmFpbGFibGUpCiAgICAgICAgICAKICAgICAgICAgIGlmICh0aGlzLmlzT25saW5lTWFwQXZhaWxhYmxlKSB7CiAgICAgICAgICAgIHRoaXMuY3VycmVudE1hcFR5cGUgPSAnb25saW5lJwogICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMub25saW5lVXJsCiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUg5L2/55So5Zyo57q/5Zyw5Zu+JykKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMuY3VycmVudE1hcFR5cGUgPSAnb2ZmbGluZScKICAgICAgICAgICAgdGhpcy51cmwgPSB0aGlzLmZhbGxiYWNrVXJsCiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8g5Zyo57q/5Zyw5Zu+5LiN5Y+v55So77yM6Ieq5Yqo6ZmN57qn5Yiw56a757q/5Zyw5Zu+JykKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8g572R57uc5LiN5Y+v55So77yM6ZmN57qn5Yiw56a757q/5Zyw5Zu+CiAgICAgICAgICB0aGlzLmN1cnJlbnRNYXBUeXBlID0gJ29mZmxpbmUnCiAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuZmFsbGJhY2tVcmwKICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OhIOe9kee7nOS4jeWPr+eUqO+8jOiHquWKqOmZjee6p+WIsOemu+e6v+WcsOWbvicpCiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOabtOaWsOWcsOWbvgogICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgIGlmICh0aGlzLiRyZWZzLm15TWFwICYmIHRoaXMuJHJlZnMubXlNYXAubWFwT2JqZWN0KSB7CiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuJHJlZnMubXlNYXAubWFwT2JqZWN0CiAgICAgICAgICAgIG1hcC5pbnZhbGlkYXRlU2l6ZSgpCiAgICAgICAgICAgIC8vIOagueaNruaWsOeahOWcsOWbvuexu+Wei+abtOaWsOe8qeaUvumZkOWItgogICAgICAgICAgICB0aGlzLnVwZGF0ZVpvb21MaW1pdHMobWFwKQogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgICAgCiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgY29uc29sZS5lcnJvcign5Zyw5Zu+5qOA5rWL5aSx6LSlOicsIGVycm9yKQogICAgICAgIHRoaXMuY3VycmVudE1hcFR5cGUgPSAnb2ZmbGluZScKICAgICAgICB0aGlzLnVybCA9IHRoaXMuZmFsbGJhY2tVcmwKICAgICAgICB0aGlzLmlzTmV0d29ya0Nvbm5lY3RlZCA9IGZhbHNlCiAgICAgICAgdGhpcy5pc09ubGluZU1hcEF2YWlsYWJsZSA9IGZhbHNlCiAgICAgICAgY29uc29sZS5sb2coJ+KdjCDmo4DmtYvlpLHotKXvvIzpmY3nuqfliLDnprvnur/lnLDlm74nKQogICAgICB9CiAgICB9LAogICAgCiAgICAvLyDlkK/liqjnvZHnu5znirbmgIHnm5HmjqcKICAgIHN0YXJ0TmV0d29ya01vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHsKICAgICAgLy8g55uR5ZCs572R57uc54q25oCB5Y+Y5YyW5LqL5Lu277yI6L+Z5Lqb5piv55yf5q2j55qE572R57uc54q25oCB5Y+Y5YyW77yJCiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiB7CiAgICAgICAgY29uc29sZS5sb2coJ+ezu+e7n+e9kee7nOi/nuaOpeaBouWkjScpCiAgICAgICAgLy8g5Y+q5pyJ5Zyo55So5oi35YGP5aW95Zyo57q/5Zyw5Zu+5pe25omN6YeN5paw5qOA5rWLCiAgICAgICAgaWYgKHRoaXMudXNlT25saW5lTWFwKSB7CiAgICAgICAgICB0aGlzLmRldGVjdEFuZFNldE1hcFR5cGUoKQogICAgICAgIH0KICAgICAgfSkKICAgICAgCiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgKCkgPT4gewogICAgICAgIGNvbnNvbGUubG9nKCfns7vnu5/nvZHnu5zov57mjqXmlq3lvIAnKQogICAgICAgIHRoaXMuaXNOZXR3b3JrQ29ubmVjdGVkID0gZmFsc2UKICAgICAgICB0aGlzLmlzT25saW5lTWFwQXZhaWxhYmxlID0gZmFsc2UKICAgICAgICB0aGlzLmN1cnJlbnRNYXBUeXBlID0gJ29mZmxpbmUnCiAgICAgICAgdGhpcy51cmwgPSB0aGlzLmZhbGxiYWNrVXJsCiAgICAgIH0pCiAgICAgIAogICAgICAvLyDlrprmnJ/mo4DmtYvpopHnjoflpKfluYXpmY3kvY7vvIzpgb/lhY3popHnuYHnvZHnu5zor7fmsYIKICAgICAgdGhpcy5uZXR3b3JrQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHsKICAgICAgICAvLyDlj6rmnInlnKjku6XkuIvmnaHku7blhajpg6jmu6HotrPml7bmiY3ph43mlrDmo4DmtYvvvJoKICAgICAgICAvLyAxLiDnlKjmiLfpgInmi6nlnKjnur/lnLDlm74KICAgICAgICAvLyAyLiDlvZPliY3kvb/nlKjnprvnur/lnLDlm74KICAgICAgICAvLyAzLiDns7vnu5/mmL7npLrnvZHnu5zlnKjnur8KICAgICAgICBpZiAodGhpcy51c2VPbmxpbmVNYXAgJiYgCiAgICAgICAgICAgIHRoaXMuY3VycmVudE1hcFR5cGUgPT09ICdvZmZsaW5lJyAmJiAKICAgICAgICAgICAgbmF2aWdhdG9yLm9uTGluZSkgewogICAgICAgICAgY29uc29sZS5sb2coJ+WwneivleS7juemu+e6v+aooeW8j+aBouWkjeWIsOWcqOe6v+aooeW8jycpCiAgICAgICAgICB0aGlzLmRldGVjdEFuZFNldE1hcFR5cGUoKQogICAgICAgIH0KICAgICAgfSwgNjAwMDApIC8vIOmZjeS9juWIsOavjzYw56eS5qOA5rWL5LiA5qyhCiAgICB9LAogICAgCiAgICAvLyDmi5bmi73nu5PmnZ/kuovku7YKICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChldmVudCkgewogICAgICBjb25zdCBuZXdQb3MgPSB7CiAgICAgICAgbGF0OiBldmVudC50YXJnZXQuX2xhdGxuZy5sYXQsCiAgICAgICAgbG5nOiBldmVudC50YXJnZXQuX2xhdGxuZy5sbmcsCiAgICAgICAgYWNjdXJhY3k6IDAKICAgICAgfQogICAgICAKICAgICAgY29uc29sZS5sb2coJ+aLluaLvee7k+adn++8jOaWsOS9jee9rjonLCBuZXdQb3MubGF0LnRvRml4ZWQoNiksIG5ld1Bvcy5sbmcudG9GaXhlZCg2KSkKICAgICAgCiAgICAgIC8vIOS9v+eUqOaWsOeahHVwZGF0ZU1hcFBvc2l0aW9u5pa55rOV5aSE55CG5ouW5ou9CiAgICAgIHRoaXMudXBkYXRlTWFwUG9zaXRpb24obmV3UG9zLmxhdCwgbmV3UG9zLmxuZywgewogICAgICAgIHVwZGF0ZU1hcmtlcjogdHJ1ZSwKICAgICAgICBmZXRjaEFkZHJlc3M6IHRydWUsCiAgICAgICAgYW5pbWF0ZTogZmFsc2UsICAvLyDmi5bmi73ml7bkuI3kvb/nlKjliqjnlLsKICAgICAgICBhY2N1cmFjeTogMAogICAgICB9KQogICAgICAKICAgICAgLy8g5Y+R6YCB5L2N572u6YeN572u5LqL5Lu277yI5L+d5oyB5ZCR5ZCO5YW85a6577yJCiAgICAgIC8vIHRoaXMuJGVtaXQoJ3Jlc2V0TG9jYXRpb24nLCBuZXdQb3MubGF0LCBuZXdQb3MubG5nKQogICAgfSwKICAgIAogICAgLy8g5L6/5o235pa55rOV77ya5b+r6YCf6Lez6L2s5Yiw5oyH5a6a5L2N572u77yI5bim5Yqo55S777yJCiAgICBmbHlUb1Bvc2l0aW9uOiBmdW5jdGlvbiAobGF0LCBsbmcsIHpvb20gPSBudWxsKSB7CiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU1hcFBvc2l0aW9uKGxhdCwgbG5nLCB7CiAgICAgICAgYW5pbWF0ZTogdHJ1ZSwKICAgICAgICB6b29tOiB6b29tLAogICAgICAgIHVwZGF0ZU1hcmtlcjogdHJ1ZSwKICAgICAgICBmZXRjaEFkZHJlc3M6IHRydWUKICAgICAgfSkKICAgIH0sCiAgICAKICAgIC8vIOS+v+aNt+aWueazle+8muebtOaOpeiuvue9ruS9jee9ru+8iOaXoOWKqOeUu++8iQogICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uIChsYXQsIGxuZywgem9vbSA9IG51bGwpIHsKICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFwUG9zaXRpb24obGF0LCBsbmcsIHsKICAgICAgICBhbmltYXRlOiBmYWxzZSwKICAgICAgICB6b29tOiB6b29tLAogICAgICAgIHVwZGF0ZU1hcmtlcjogdHJ1ZSwKICAgICAgICBmZXRjaEFkZHJlc3M6IHRydWUKICAgICAgfSkKICAgIH0sCiAgICAKICAgIC8vIOS+v+aNt+aWueazle+8muS7heabtOaWsOWcsOWbvuS4reW/g++8iOS4jeenu+WKqOWcsOWbvumSie+8iQogICAgY2VudGVyTWFwQXQ6IGZ1bmN0aW9uIChsYXQsIGxuZywgem9vbSA9IG51bGwsIGFuaW1hdGUgPSB0cnVlKSB7CiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU1hcFBvc2l0aW9uKGxhdCwgbG5nLCB7CiAgICAgICAgYW5pbWF0ZTogYW5pbWF0ZSwKICAgICAgICB6b29tOiB6b29tLAogICAgICAgIHVwZGF0ZU1hcmtlcjogZmFsc2UsCiAgICAgICAgZmV0Y2hBZGRyZXNzOiBmYWxzZQogICAgICB9KQogICAgfSwKICAgIAogICAgCiAgICAvLyDkvr/mjbfmlrnms5XvvJrpgJrov4flt7Lnn6XkvY3nva7lr7nosaHmm7TmlrAKICAgIHVwZGF0ZVRvS25vd25Mb2NhdGlvbjogZnVuY3Rpb24gKGxvY2F0aW9uT2JqLCBhbmltYXRlID0gdHJ1ZSkgewogICAgICBpZiAoIWxvY2F0aW9uT2JqIHx8ICF0aGlzLmlzVmFsaWRMb2NhdGlvbihsb2NhdGlvbk9iaikpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCfml6DmlYjnmoTkvY3nva7lr7nosaE6JywgbG9jYXRpb25PYmopCiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgCiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU1hcFBvc2l0aW9uKGxvY2F0aW9uT2JqLmxhdCwgbG9jYXRpb25PYmoubG5nLCB7CiAgICAgICAgYW5pbWF0ZTogYW5pbWF0ZSwKICAgICAgICB1cGRhdGVNYXJrZXI6IHRydWUsCiAgICAgICAgZmV0Y2hBZGRyZXNzOiBmYWxzZSwgIC8vIOW3suefpeS9jee9rumAmuW4uOS4jemcgOimgemHjeaWsOiOt+WPluWcsOWdgAogICAgICAgIGFjY3VyYWN5OiBsb2NhdGlvbk9iai5hY2N1cmFjeSB8fCAwCiAgICAgIH0pCiAgICB9CiAgfSwKICBjb21wb25lbnRzOiB7IExNYXAsIExUaWxlTGF5ZXIsIExNYXJrZXIsIExDaXJjbGUsIExUb29sdGlwLCBMQ29udHJvbFpvb20gfQp9Cg=="},{"version":3,"sources":["location-mgr.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2LA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"location-mgr.vue","sourceRoot":"src/components","sourcesContent":["// Stellarium Web - Copyright (c) 2022 - Stellarium Labs SRL\n//\n// This program is licensed under the terms of the GNU AGPL v3, or\n// alternatively under a commercial licence.\n//\n// The terms of the AGPL v3 license can be found in the main directory of this\n// repository.\n\n/*\n - \n\n\n1. updateMapPosition(lat, lng, options) - \n   \n   - lat:  (number)\n   - lng:  (number) \n   - options:  (object)\n     - updateMarker:  (boolean, true)\n     - fetchAddress:  (boolean, true)\n     - zoom:  (number, )\n     - animate:  (boolean, true)\n     - accuracy:  (number, 0)\n\n\n2. flyToPosition(lat, lng, zoom) - \n3. setPosition(lat, lng, zoom) - \n4. centerMapAt(lat, lng, zoom, animate) - \n5. updateToKnownLocation(locationObj, animate) - \n\n\n- mapPositionUpdated: \n- addressInfoUpdated:   \n- addressInfoError: \n\n\n// \nthis.$refs.locationManager.flyToPosition(39.9042, 116.4074, 15)\nthis.$refs.locationManager.setPosition(40.7128, -74.0060)\nthis.$refs.locationManager.centerMapAt(51.5074, -0.1278, 12, false)\n\n// \n<location-mgr \n  @mapPositionUpdated=\"onPositionUpdated\"\n  @addressInfoUpdated=\"onAddressUpdated\"\n  @addressInfoError=\"onAddressError\"\n  ref=\"locationManager\">\n</location-mgr>\n\n\n<template>\n  <div>\n    <v-row justify=\"space-around\">\n      <v-col cols=\"4\" v-if=\"doShowMyLocation\">\n        <v-list two-line subheader>\n          <v-subheader>{{ $t('My Locations') }}</v-subheader>\n          <v-list-item href=\"javascript:;\" v-for=\"item in knownLocations\" v-bind:key=\"item.id\" @click.native.stop=\"selectKnownLocation(item)\" :style=\"(item && knownLocationMode && selectedKnownLocation && item.id === selectedKnownLocation.id) ? 'background-color: #455a64' : ''\">\n            <v-list-item-icon>\n              <v-icon>mdi-map-marker</v-icon>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title>{{ item.short_name }}</v-list-item-title>\n              <v-list-item-subtitle>{{ item.country }}</v-list-item-subtitle>\n            </v-list-item-content>\n          </v-list-item>\n        </v-list>\n      </v-col>\n      <v-col cols=\"doShowMyLocation ? 8 : 12\" >\n        <v-card class=\"blue-grey darken-2 white--text\">\n          <v-card-title primary-title>\n            <v-container fluid>\n              <v-row>\n                <!--  -->\n                <v-col>\n                  <div>\n                    <div class=\"text-h5\" style=\"overflow: hidden; white-space: nowrap; text-overflow: ellipsis;\">\n                      {{ locationForDetail ? locationForDetail.short_name + ', ' + locationForDetail.country : $t('locationMgr.selectLocation') }}\n                      <v-progress-circular v-if=\"geoCodeLoading\" indeterminate size=\"16\" width=\"2\" color=\"orange\" style=\"margin-left: 8px;\"></v-progress-circular>\n                    </div>\n                    <div class=\"grey--text text-subtitle-2\" v-if=\"locationForDetail && locationForDetail.street_address\">{{ locationForDetail.street_address }}</div>\n                    <div class=\"grey--text text-subtitle-2\">\n                      {{ hasValidSelection ? locationForDetail.lat.toFixed(5) + ' ' + locationForDetail.lng.toFixed(5) : $t('locationMgr.dragToSelect') }}\n                      <span v-if=\"geoCodeLoading\" style=\"color: #ff9800; margin-left: 8px;\">{{ $t('locationMgr.fetchingAddress') }}</span>\n                    </div>\n                  </div>\n                </v-col>\n                \n                <!--  -->\n                <v-col cols=\"auto\" style=\"min-width: 200px;\">\n                  <div class=\"d-flex flex-column\" style=\"gap: 8px;\">\n                    <!-- -  -->\n                    <div class=\"d-flex align-center justify-space-between\" style=\"width: 100%; min-height: 32px;\">\n                      <div class=\"d-flex align-center\" style=\"gap: 6px; line-height: 1;\">\n                        <v-icon :color=\"getMapStatusColor()\" size=\"16\">{{ getMapStatusIcon() }}</v-icon>\n                        <span class=\"text-caption\" :style=\"`color: ${getMapStatusColor()}; line-height: 1;`\">{{ getMapStatusText() }}</span>\n                      </div>\n                      <div class=\"d-flex align-center\">\n                        <v-switch\n                          v-model=\"useOnlineMap\"\n                          @change=\"onMapTypeToggle\"\n                          dense\n                          hide-details\n                          color=\"primary\"\n                          class=\"mt-0 pt-0\"\n                          style=\"margin-left: 12px;\"\n                        >\n                          <template v-slot:label>\n                            <span class=\"text-caption\" style=\"line-height: 1;\">{{ $t('locationMgr.onlineMap') }}</span>\n                          </template>\n                        </v-switch>\n                      </div>\n                    </div>\n                    <!--  -->\n                    <div>\n                      <v-btn \n                        @click.native.stop=\"useLocation()\" \n                        :disabled=\"!hasValidSelection\"\n                        color=\"primary\"\n                        small\n                        style=\"width: 100%;\"\n                      >\n                        <v-icon small>mdi-chevron-right</v-icon>\n                        {{ $t('Use this location') }}\n                      </v-btn>\n                    </div>\n                  </div>\n                </v-col>\n              </v-row>\n            </v-container>\n          </v-card-title>\n          <div style=\"height: 375px\">\n            <l-map class=\"black--text\" ref=\"myMap\" :center=\"mapCenter\" :zoom=\"defaultZoom\" style=\"width: 100%; height: 375px;\" :options=\"{zoomControl: false, minZoom: effectiveMinZoom, maxZoom: effectiveMaxZoom}\">\n              <l-control-zoom position=\"topright\"></l-control-zoom>\n              <l-tile-layer :url=\"url\" attribution='&copy; <a target=\"_blank\" rel=\"noopener\" href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'></l-tile-layer>\n              <l-marker :key=\"loc.id || 'marker-' + index\"\n                  v-for=\"(loc, index) in validKnownLocations\"\n                  :lat-lng=\"[ loc.lat, loc.lng ]\"\n                  :clickable=\"true\"\n                  :opacity=\"(!pickLocationMode && selectedKnownLocation && selectedKnownLocation === loc ? 1.0 : 0.25)\"\n                  @click=\"selectKnownLocation(loc)\"\n                  :draggable=\"!pickLocationMode && selectedKnownLocation && selectedKnownLocation === loc\" \n                  @dragend=\"dragEnd\"\n                >\n                  <l-tooltip>\n                    <div class=\"black--text\">\n                      <strong>{{ loc.short_name }}</strong><br>\n                      <span v-if=\"loc.city && loc.city !== $t('locationMgr.unknownCity')\">{{ loc.city }}<span v-if=\"loc.state\">, {{ loc.state }}</span><br></span>\n                      {{ loc.country }}<br>\n                      {{ $t('locationMgr.coordinates') }}: {{ loc.lat.toFixed(4) }}, {{ loc.lng.toFixed(4) }}<br>\n                      <small style=\"color: #666;\">\n                        <span v-if=\"!pickLocationMode && selectedKnownLocation && selectedKnownLocation === loc\">{{ $t('locationMgr.dragToMove') }}</span>\n                        <span v-else>{{ $t('locationMgr.clickToSelect') }}</span>\n                      </small>\n                    </div>\n                  </l-tooltip>\n                </l-marker>\n              <l-circle v-if=\"startLocation && isValidLocation(startLocation)\"\n                :lat-lng=\"[ startLocation.lat, startLocation.lng ]\"\n                :radius=\"startLocation.accuracy || 100\"\n                :options=\"{\n                  strokeColor: '#0000FF',\n                  strokeOpacity: 0.5,\n                  strokeWeight: 1,\n                  fillColor: '#0000FF',\n                  fillOpacity: 0.08}\"></l-circle>\n              <l-marker v-if=\"shouldShowPickLocation\" \n                :lat-lng=\"[ pickLocation.lat, pickLocation.lng ]\"\n                :draggable=\"true\" \n                @dragend=\"dragEnd\">\n                <l-tooltip>\n                  <div class=\"black--text\">\n                    <strong>{{ pickLocation.short_name }}</strong><br>\n                    <span v-if=\"pickLocation.city && pickLocation.city !== $t('locationMgr.unknownCity')\">{{ pickLocation.city }}<span v-if=\"pickLocation.state\">, {{ pickLocation.state }}</span><br></span>\n                    <span v-if=\"pickLocation.country && pickLocation.country !== $t('locationMgr.unknown')\">{{ pickLocation.country }}<br></span>\n                    {{ $t('locationMgr.coordinates') }}: {{ pickLocation.lat.toFixed(4) }}, {{ pickLocation.lng.toFixed(4) }}<br>\n                    <small style=\"color: #666;\">{{ $t('locationMgr.dragToAdjust') }}</small>\n                  </div>\n                </l-tooltip>\n              </l-marker>\n            </l-map>\n          </div>\n        </v-card>\n      </v-col>\n    </v-row>\n  </div>\n</template>\n\n<script>\nimport swh from '@/assets/sw_helpers.js'\nimport { LMap, LTileLayer, LMarker, LCircle, LTooltip, LControlZoom } from 'vue2-leaflet'\nimport L from 'leaflet'\nimport MapConfig from '@/config/map-config.js'\n\nexport default {\n  data: function () {\n    return {\n      mode: 'pick',\n      pickLocation: undefined,\n      selectedKnownLocation: undefined,\n      mapCenter: [39.9042, 116.4074],\n      url: process.env.NODE_ENV === 'production' ? '/tiles/{z}/{x}/{y}.png' : 'http://localhost:8080/tiles/{z}/{x}/{y}.png',\n      fallbackUrl: '/tiles/{z}/{x}/{y}.png',\n      serverUrl: 'http://localhost:8080/tiles/{z}/{x}/{y}.png',\n      onlineUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n      // \n      minZoom: MapConfig.zoom.offline.min,\n      maxZoom: MapConfig.zoom.offline.max,\n      defaultZoom: MapConfig.zoom.offline.default,\n      // \n      geoCodeLoading: false,\n      // \n      useOnlineMap: true,              // \n      isOnlineMapAvailable: false,     // \n      isNetworkConnected: false,       // \n      currentMapType: 'checking',      // : 'online', 'offline', 'checking'\n      networkCheckInterval: null,      // \n      // \n      currentRequestId: 0,\n      abortController: null\n    }\n  },\n  props: ['showMyLocation', 'knownLocations', 'startLocation', 'realLocation'],\n  computed: {\n    doShowMyLocation: function () {\n      return this.showMyLocation === undefined ? false : this.showMyLocation\n    },\n    pickLocationMode: function () {\n      return this.mode === 'pick'\n    },\n    knownLocationMode: function () {\n      return this.mode === 'known'\n    },\n    locationForDetail: function () {\n      let location = null\n      \n      if (this.pickLocationMode && this.pickLocation === undefined) {\n        location = this.startLocation\n      } else {\n        location = this.pickLocationMode ? this.pickLocation : this.selectedKnownLocation\n      }\n      \n      // \n      if (location && this.isValidLocation(location)) {\n        const sanitized = this.sanitizeLocation(location)\n        if (sanitized) {\n          return sanitized\n        }\n      }\n      \n      // \n      return {\n        lat: 39.9042,\n        lng: 116.4074,\n        accuracy: 1000,\n        short_name: this.$t('locationMgr.beijing'),\n        country: this.$t('locationMgr.china'),\n        street_address: this.$t('locationMgr.beijingCity'),\n        city: this.$t('locationMgr.beijingCity'),\n        state: this.$t('locationMgr.beijingCity'),\n        postcode: ''\n      }\n    },\n    // \n    effectiveMinZoom: function () {\n      // \n      if (this.currentMapType === 'online') {\n        return MapConfig.zoom.online.min  // 01\n      } else {\n        return MapConfig.zoom.offline.min  // \n      }\n    },\n    effectiveMaxZoom: function () {\n      // \n      if (this.currentMapType === 'online') {\n        return MapConfig.zoom.online.max  // 1819\n      } else {\n        return MapConfig.zoom.offline.max  // \n      }\n    },\n    validKnownLocations: function () {\n      if (!this.knownLocations || !Array.isArray(this.knownLocations) || this.knownLocations.length === 0) {\n        // \n        return []\n      }\n      \n      const validLocations = this.knownLocations.filter(this.isValidLocation)\n      return validLocations\n    },\n    // pickLocation\n    shouldShowPickLocation: function () {\n      // pickLocationModepickLocation\n      return this.pickLocationMode && \n             this.pickLocation && \n             this.isValidLocation(this.pickLocation)\n    },\n    hasValidSelection: function () {\n      // \n      if (this.selectedKnownLocation) {\n        return true // \n      }\n      \n      if (this.pickLocation && this.isValidLocation(this.pickLocation)) {\n        // \"\"\"\"\n        if (this.pickLocation.short_name === this.$t('locationMgr.dragToSelectPin') || \n            this.pickLocation.country === this.$t('locationMgr.defaultLocation')) {\n          return false\n        }\n        return true\n      }\n      \n      return false\n    }\n  },\n  watch: {\n    startLocation: function (newLocation) {\n      if (this.isValidLocation(newLocation)) {\n        this.setPickLocation(newLocation)\n      } else {\n        console.warn('Invalid startLocation received:', newLocation)\n      }\n    }\n  },\n  created() {\n    this.$bus.$on('updateMapPosition', this.updateMapPosition);\n  },\n  mounted: function () {\n    const that = this\n    \n    // Leaflet\n    this.fixLeafletIcons()\n    \n    // startLocationpickLocation\n    if (this.startLocation && this.isValidLocation(this.startLocation)) {\n      this.setPickLocation(this.startLocation)\n    } else {\n      // startLocationpickLocation\n      this.pickLocation = {\n        lat: 39.9042,\n        lng: 116.4074,\n        accuracy: 0,\n        short_name: this.$t('locationMgr.dragToSelectPin'),\n        country: this.$t('locationMgr.defaultLocation'),\n        street_address: this.$t('locationMgr.dragPinToTarget')\n      }\n      this.setPickLocationMode()\n    }\n    \n    // \n    this.startNetworkMonitoring()\n    \n    // \n    this.detectAndSetMapType()\n    \n    this.$nextTick(() => {\n      const map = this.$refs.myMap.mapObject\n      map._onResize()\n\n      // \n      this.updateZoomLimits(map)\n    })\n  },\n  beforeDestroy: function () {\n    // \n    if (this.networkCheckInterval) {\n      clearInterval(this.networkCheckInterval)\n    }\n    \n    // \n    if (this.abortController) {\n      this.abortController.abort()\n      console.log('')\n    }\n    \n    // \n    window.removeEventListener('online', this.detectAndSetMapType)\n    window.removeEventListener('offline', this.detectAndSetMapType)\n  },\n  methods: {\n    selectKnownLocation: function (loc) {\n      this.selectedKnownLocation = loc\n      this.setKnownLocationMode()\n      this.mapCenter = [loc.lat, loc.lng]\n    },\n    useLocation: function () {\n      console.log('useLocation:', this.locationForDetail.lat, this.locationForDetail.lng)\n      this.$bus.$emit('locationSelected', this.locationForDetail)\n      const lat = parseFloat(this.locationForDetail.lat.toFixed(3))\n      const lng = parseFloat(this.locationForDetail.lng.toFixed(3))\n      this.$bus.$emit('resetLocation', lat, lng,false)\n    },\n    setPickLocationMode: function () {\n      this.mode = 'pick'\n    },\n    setKnownLocationMode: function () {\n      this.mode = 'known'\n    },\n    setPickLocation: function (loc) {\n      // \n      if (!this.isValidLocation(loc)) {\n        console.warn('Invalid location data received:', loc)\n        // \n        return\n      }\n      \n      // \n      const sanitizedLoc = this.sanitizeLocation(loc)\n      \n      if (sanitizedLoc.accuracy < 100) {\n        for (const l of this.knownLocations) {\n          if (this.isValidLocation(l)) {\n            const d = swh.getDistanceFromLatLonInM(l.lat, l.lng, sanitizedLoc.lat, sanitizedLoc.lng)\n            if (d < 100) {\n              this.selectKnownLocation(l)\n              return\n            }\n          }\n        }\n      }\n      \n      // \n      this.mapCenter = [sanitizedLoc.lat, sanitizedLoc.lng]\n      this.pickLocation = sanitizedLoc\n      this.setPickLocationMode()\n    },\n    // Called when the user clicks on the small cross button\n    centerOnRealPosition: function () {\n      this.setPickLocation(this.realLocation)\n    },\n    \n    // \n    updateMapPosition: function (lat, lng, options = {}) {\n      console.log(':', lat, lng, options)\n      \n      // \n      if (typeof lat !== 'number' || typeof lng !== 'number' || \n          isNaN(lat) || isNaN(lng) || \n          lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n        console.error(':', { lat, lng })\n        return false\n      }\n      \n      // \n      const defaultOptions = {\n        updateMarker: true,        // \n        fetchAddress: true,        // \n        zoom: null,               // \n        animate: true,            // \n        accuracy: 0               // \n      }\n      \n      const config = Object.assign({}, defaultOptions, options)\n      \n      try {\n        // \n        if (config.animate && this.$refs.myMap && this.$refs.myMap.mapObject) {\n          // \n          const map = this.$refs.myMap.mapObject\n          const targetZoom = config.zoom || map.getZoom()\n          map.flyTo([lat, lng], targetZoom, {\n            duration: 1.5,  // \n            easeLinearity: 0.1\n          })\n        } else {\n          // \n          this.mapCenter = [lat, lng]\n          \n          // \n          if (config.zoom && this.$refs.myMap && this.$refs.myMap.mapObject) {\n            this.$nextTick(() => {\n              this.$refs.myMap.mapObject.setZoom(config.zoom)\n            })\n          }\n        }\n        \n        // \n        if (config.updateMarker) {\n          const newLocation = {\n            lat: lat,\n            lng: lng,\n            accuracy: config.accuracy,\n            short_name: config.fetchAddress ? this.$t('locationMgr.fetchingLocationInfo') : this.$t('locationMgr.newLocation'),\n            country: config.fetchAddress ? this.$t('locationMgr.pleaseWait') : this.$t('locationMgr.unknown'),\n            street_address: `${this.$t('locationMgr.coordinates')}: ${lat.toFixed(6)}, ${lng.toFixed(6)}`\n          }\n          \n          // \n          if (this.pickLocationMode) {\n            this.pickLocation = newLocation\n            this.setPickLocationMode()\n          } else {\n            // \n            this.pickLocation = newLocation\n            this.setPickLocationMode()\n          }\n          \n          // \n          if (config.fetchAddress) {\n            this.requestLocationInfo(lat, lng)\n          }\n        }\n        \n        // \n        this.$emit('mapPositionUpdated', { lat, lng, options: config })\n        \n        console.log(':', { lat, lng, config })\n        return true\n        \n      } catch (error) {\n        console.error(':', error)\n        return false\n      }\n    },\n    \n    // \n    requestLocationInfo: function (lat, lng) {\n      // ID\n      const requestId = ++this.currentRequestId\n      \n      // \n      setTimeout(() => {\n        // \n        if (requestId !== this.currentRequestId) {\n          console.log('')\n          return\n        }\n        \n        // \n        this.getCityInfo({ lat, lng }, requestId).then(cityInfo => {\n          // \n          if (requestId !== this.currentRequestId) {\n            console.log('')\n            return\n          }\n          \n          const updatedPos = {\n            lat: lat,\n            lng: lng,\n            accuracy: this.pickLocation?.accuracy || 0,\n            ...cityInfo\n          }\n          \n          // \n          if (this.pickLocationMode && this.pickLocation) {\n            Object.assign(this.pickLocation, updatedPos)\n            this.$forceUpdate()\n          }\n          \n          console.log(':', updatedPos)\n          \n          // \n          this.$emit('addressInfoUpdated', updatedPos)\n          \n        }).catch(error => {\n          // \n          if (error.name === 'AbortError') {\n            console.log('')\n            return\n          }\n          \n          // \n          if (requestId !== this.currentRequestId) {\n            console.log('')\n            return\n          }\n          \n          console.error(':', error)\n          \n          // \n          const errorLocationInfo = {\n            lat: lat,\n            lng: lng,\n            accuracy: this.pickLocation?.accuracy || 0,\n            short_name: this.$t('locationMgr.fetchLocationFailed'),\n            country: this.$t('locationMgr.unknownRegion'),\n            street_address: `${this.$t('locationMgr.coordinates')}: ${lat.toFixed(6)}, ${lng.toFixed(6)}`\n          }\n          \n          if (this.pickLocationMode && this.pickLocation) {\n            Object.assign(this.pickLocation, errorLocationInfo)\n            this.$forceUpdate()\n          }\n          \n          // \n          this.$emit('addressInfoError', { lat, lng, error: error.message })\n        })\n      }, 100) // 100ms\n    },\n    checkTileAvailability: function () {\n      const that = this\n      \n      // \n      if (process.env.NODE_ENV === 'production') {\n        that.testStaticTiles().then(isAvailable => {\n          if (isAvailable) {\n            console.log('')\n            that.url = that.fallbackUrl\n          } else {\n            console.log('tile')\n            that.testTileServer()\n          }\n        })\n      } else {\n        // tile\n        that.testTileServer()\n      }\n    },\n    \n    testStaticTiles: function () {\n      const that = this\n      return new Promise((resolve) => {\n        // \n        const testUrls = [\n          '/tiles/0/0/0.png',\n          '/tiles/1/0/0.png',\n          '/tiles/2/1/1.png'\n        ]\n        \n        let testCount = 0\n        let successCount = 0\n        \n        testUrls.forEach(url => {\n          fetch(url, { method: 'HEAD' })\n            .then(response => {\n              testCount++\n              if (response.ok) {\n                successCount++\n              }\n              \n              if (testCount === testUrls.length) {\n                // \n                resolve(successCount >= testUrls.length / 2)\n              }\n            })\n            .catch(() => {\n              testCount++\n              if (testCount === testUrls.length) {\n                resolve(successCount >= testUrls.length / 2)\n              }\n            })\n        })\n        \n        // \n        setTimeout(() => {\n          if (testCount < testUrls.length) {\n            resolve(false)\n          }\n        }, 2000)\n      })\n    },\n    \n    testTileServer: function () {\n      const that = this\n      \n      // tile\n      const testUrl = this.serverUrl.replace('{z}', '0').replace('{x}', '0').replace('{y}', '0')\n      \n      fetch(testUrl, { method: 'HEAD', timeout: 3000 })\n        .then(response => {\n          if (response.ok) {\n            console.log('tile')\n            that.url = that.serverUrl\n          } else {\n            throw new Error('tile')\n          }\n        })\n        .catch(error => {\n          console.log('tile:', error)\n          that.url = that.fallbackUrl\n          \n          // \n          that.testStaticTiles().then(isAvailable => {\n            if (!isAvailable && process.env.NODE_ENV === 'development') {\n              console.log('')\n              that.url = that.onlineUrl\n            }\n          })\n        })\n    },\n    updateZoomLimits: function (map) {\n      const that = this\n      \n      // \n      map.setMinZoom(this.effectiveMinZoom)\n      map.setMaxZoom(this.effectiveMaxZoom)\n      \n      console.log(`: ${this.effectiveMinZoom} - ${this.effectiveMaxZoom} (${this.currentMapType})`)\n      \n      // \n      if (this.currentMapType === 'offline' && process.env.NODE_ENV === 'production') {\n        this.detectAvailableTileLevels().then(levels => {\n          if (levels.min !== null && levels.max !== null) {\n            map.setMinZoom(levels.min)\n            map.setMaxZoom(levels.max)\n            console.log(`: ${levels.min} - ${levels.max}`)\n          }\n        })\n      }\n    },\n    \n    detectAvailableTileLevels: function () {\n      const that = this\n      return new Promise((resolve) => {\n        const testLevels = MapConfig.detection.testLevels\n        let availableLevels = []\n        let testCount = 0\n        \n        testLevels.forEach(level => {\n          const testUrl = `/tiles/${level}/0/0.png`\n          \n          fetch(testUrl, { method: 'HEAD' })\n            .then(response => {\n              testCount++\n              if (response.ok) {\n                availableLevels.push(level)\n              }\n              \n              if (testCount === testLevels.length) {\n                availableLevels.sort((a, b) => a - b)\n                resolve({\n                  min: availableLevels.length > 0 ? availableLevels[0] : null,\n                  max: availableLevels.length > 0 ? availableLevels[availableLevels.length - 1] : null,\n                  available: availableLevels\n                })\n              }\n            })\n            .catch(() => {\n              testCount++\n              if (testCount === testLevels.length) {\n                availableLevels.sort((a, b) => a - b)\n                resolve({\n                  min: availableLevels.length > 0 ? availableLevels[0] : null,\n                  max: availableLevels.length > 0 ? availableLevels[availableLevels.length - 1] : null,\n                  available: availableLevels\n                })\n              }\n            })\n        })\n        \n        // \n        setTimeout(() => {\n          if (testCount < testLevels.length) {\n            resolve({ \n              min: MapConfig.zoom.offline.min, \n              max: MapConfig.zoom.offline.max, \n              available: [] \n            })\n          }\n        }, MapConfig.detection.timeout)\n      })\n    },\n    isValidLocation: function (location) {\n      if (!location) {\n        console.debug(': ')\n        return false\n      }\n      \n      // \n      if (typeof location.lat === 'undefined' || typeof location.lng === 'undefined') {\n        console.debug(': latlng', location)\n        return false\n      }\n      \n      // \n      const lat = parseFloat(location.lat)\n      const lng = parseFloat(location.lng)\n      \n      if (isNaN(lat) || isNaN(lng)) {\n        console.debug(': ', { lat: location.lat, lng: location.lng, parsedLat: lat, parsedLng: lng })\n        return false\n      }\n      \n      // \n      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n        console.debug(': ', { lat, lng })\n        return false\n      }\n      \n      // \n      if (lat === 0 && lng === 0) {\n        console.debug(': (0,0)')\n        return false\n      }\n      \n      return true\n    },\n    sanitizeLocation: function (location) {\n      if (!location) {\n        console.debug(': ')\n        return null\n      }\n      \n      // \n      const lat = parseFloat(location.lat)\n      const lng = parseFloat(location.lng)\n      \n      if (isNaN(lat) || isNaN(lng)) {\n        console.debug(': ', location)\n        return null\n      }\n      \n      const sanitized = {\n        lat: Math.max(-90, Math.min(90, lat)),     // \n        lng: Math.max(-180, Math.min(180, lng)),   // \n        accuracy: parseFloat(location.accuracy) || 100,\n        short_name: location.short_name || this.$t('locationMgr.unknownLocation'),\n        country: location.country || this.$t('locationMgr.unknownCountry'),\n        street_address: location.street_address || '',\n        city: location.city || this.$t('locationMgr.unknownCity'),\n        state: location.state || '',\n        postcode: location.postcode || ''\n      }\n      \n      // \n      if (!this.isValidLocation(sanitized)) {\n        console.debug(': ', sanitized)\n        return null\n      }\n      \n      return sanitized\n    },\n    fixLeafletIcons: function () {\n      // Leaflet\n      L.Icon.Default.imagePath = 'https://unpkg.com/leaflet@1.7.1/dist/images/'\n      \n      // \n      this.$nextTick(() => {\n        if (this.$refs.myMap && this.$refs.myMap.mapObject) {\n          const map = this.$refs.myMap.mapObject\n          // \n          map.options.touchZoom = true\n          map.options.touchPan = true\n        }\n      })\n    },\n    getCityInfo: function (position, requestId) {\n      // \n      this.geoCodeLoading = true\n      \n      // AbortController\n      const abortController = new AbortController()\n      this.abortController = abortController\n      \n      // \n      if (this.currentMapType === 'online') {\n        return this.getOnlineGeocodingInfo(position, abortController)\n      } else {\n        return this.getOfflineGeocodingInfo(position)\n      }\n    },\n    \n    // \n    getOnlineGeocodingInfo: function (position, abortController) {\n      console.log('')\n      \n      // \n      const tryGeocoding = async () => {\n        // 1: JSONPCORS\n        // 2: \n        // 3: \n        \n        const services = [\n          {\n            name: 'BigDataCloud-API',\n            url: `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${position.lat}&longitude=${position.lng}&localityLanguage=zh-CN`,\n            method: 'fetch-cors'\n          },\n          {\n            name: 'OpenCage-Demo',\n            url: `https://api.opencagedata.com/geocode/v1/json?q=${position.lat}+${position.lng}&key=demo&language=zh-CN&pretty=1&no_annotations=1`,\n            method: 'fetch-cors'\n          }\n        ]\n        \n        for (const service of services) {\n          try {\n            console.log(`${service.name}...`)\n            \n            let data\n            if (service.method === 'jsonp') {\n              // JSONP\n              data = await this.fetchWithJSONP(service.url, 8000)\n            } else if (service.method === 'fetch-cors') {\n              // CORSAPI\n              const response = await fetch(service.url, {\n                signal: abortController.signal,\n                mode: 'cors',\n                credentials: 'omit'\n              })\n              \n              if (!response.ok) {\n                throw new Error(`${service.name} HTTP ${response.status}`)\n              }\n              \n              data = await response.json()\n            } else {\n              // fetch\n              const response = await fetch(service.url, {\n                headers: service.headers || {},\n                signal: abortController.signal,\n                mode: 'cors',\n                credentials: 'omit'\n              })\n              \n              if (!response.ok) {\n                throw new Error(`${service.name} HTTP ${response.status}`)\n              }\n              \n              data = await response.json()\n            }\n            \n            console.log(`${service.name}:`, data)\n            \n            // \n            let cityInfo\n            if (service.name.includes('BigDataCloud')) {\n              // BigDataCloud API\n              if (data && data.city) {\n                cityInfo = {\n                  short_name: this.formatBigDataCloudLocationName(data),\n                  country: data.countryName || this.$t('locationMgr.unknownCountry'),\n                  street_address: data.locality || data.city || this.$t('locationMgr.unknownAddress'),\n                  city: data.city || data.locality || this.$t('locationMgr.unknownCity'),\n                  state: data.principalSubdivision || '',\n                  postcode: data.postcode || ''\n                }\n              }\n            } else if (service.name.includes('OpenCage')) {\n              // OpenCage API\n              if (data && data.results && data.results.length > 0) {\n                const result = data.results[0]\n                const components = result.components || {}\n                cityInfo = {\n                  short_name: this.formatOpenCageLocationName(components),\n                  country: components.country || this.$t('locationMgr.unknownCountry'),\n                  street_address: result.formatted || this.$t('locationMgr.unknownAddress'),\n                  city: components.city || components.town || components.village || components.county || this.$t('locationMgr.unknownCity'),\n                  state: components.state || components.province || '',\n                  postcode: components.postcode || ''\n                }\n              }\n            } else {\n              // Nominatim\n              if (data && (data.display_name || data.name)) {\n                const address = data.address || {}\n                cityInfo = {\n                  short_name: this.formatLocationName(address),\n                  country: address.country || this.$t('locationMgr.unknownCountry'),\n                  street_address: data.display_name || data.name || this.$t('locationMgr.unknownAddress'),\n                  city: address.city || address.town || address.village || address.county || this.$t('locationMgr.unknownCity'),\n                  state: address.state || address.province || '',\n                  postcode: address.postcode || ''\n                }\n              }\n            }\n            \n            if (cityInfo) {\n              console.log(`${service.name}`)\n              return cityInfo\n            } else {\n              throw new Error(`${service.name}`)\n            }\n          } catch (error) {\n            console.warn(`${service.name}:`, error.message)\n            \n            // \n            if (error.name === 'AbortError') {\n              throw error\n            }\n            \n            // \n            continue\n          }\n        }\n        \n        // \n        console.log('')\n        throw new Error('')\n      }\n      \n      // Promise\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('')), 6000) // 6\n      })\n      \n      return Promise.race([tryGeocoding(), timeoutPromise])\n      .catch(error => {\n        console.warn(':', error.message)\n        \n        // \n        if (error.name === 'AbortError') {\n          throw error\n        }\n        \n        // \n        return this.generateOfflineLocationInfo(position)\n      })\n      .finally(() => {\n        // \n        this.geoCodeLoading = false\n        if (this.abortController === abortController) {\n          this.abortController = null\n        }\n      })\n    },\n    \n    // JSONP\n    fetchWithJSONP: function (url, timeout = 8000) {\n      return new Promise((resolve, reject) => {\n        const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random())\n        const script = document.createElement('script')\n        \n        // \n        const timeoutId = setTimeout(() => {\n          cleanup()\n          reject(new Error('JSONP'))\n        }, timeout)\n        \n        // \n        const cleanup = () => {\n          if (script.parentNode) {\n            script.parentNode.removeChild(script)\n          }\n          if (window[callbackName]) {\n            delete window[callbackName]\n          }\n          clearTimeout(timeoutId)\n        }\n        \n        // \n        window[callbackName] = (data) => {\n          cleanup()\n          resolve(data)\n        }\n        \n        // \n        script.onerror = () => {\n          cleanup()\n          reject(new Error('JSONP'))\n        }\n        \n        //  - \n        const finalUrl = url.replace('CALLBACK_PLACEHOLDER', callbackName)\n        script.src = finalUrl\n        console.log('JSONPURL:', finalUrl)\n        document.head.appendChild(script)\n      })\n    },\n    \n    // \n    getOfflineGeocodingInfo: function (position) {\n      console.log('')\n      \n      return new Promise((resolve) => {\n        // \n        setTimeout(() => {\n          // \n          const cityInfo = this.generateOfflineLocationInfo(position)\n          \n          console.log(':', cityInfo.short_name)\n          resolve(cityInfo)\n        }, 200) // 200ms\n      })\n      .finally(() => {\n        // \n        this.geoCodeLoading = false\n        this.abortController = null\n      })\n    },\n    generateOfflineLocationInfo: function (position) {\n      const lat = position.lat\n      const lng = position.lng\n      \n      // \n      let regionInfo = this.determineRegion(lat, lng)\n      \n      // \n      const locationName = `${regionInfo.region}`\n      \n      return {\n        short_name: locationName,\n        country: regionInfo.country,\n        street_address: `: ${lat.toFixed(6)}, ${lng.toFixed(6)}`,\n        city: regionInfo.city,\n        state: regionInfo.state,\n        postcode: ''\n      }\n    },\n    \n    determineRegion: function (lat, lng) {\n      // \n      \n      // \n      if (lat >= 18 && lat <= 54 && lng >= 73 && lng <= 135) {\n        if (lat >= 39.4 && lat <= 41.1 && lng >= 115.4 && lng <= 117.5) {\n          return { region: this.$t('locationMgr.beijing'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.beijingCity'), state: this.$t('locationMgr.beijingCity') }\n        } else if (lat >= 30.8 && lat <= 31.9 && lng >= 120.9 && lng <= 122.0) {\n          return { region: this.$t('locationMgr.shanghai'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.shanghaiCity'), state: this.$t('locationMgr.shanghaiCity') }\n        } else if (lat >= 22.4 && lat <= 23.6 && lng >= 113.8 && lng <= 114.6) {\n          return { region: this.$t('locationMgr.shenzhen'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.shenzhenCity'), state: this.$t('locationMgr.guangdongProvince') }\n        } else if (lat >= 30.1 && lat <= 30.9 && lng >= 103.9 && lng <= 104.9) {\n          return { region: this.$t('locationMgr.chengdu'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.chengduCity'), state: this.$t('locationMgr.sichuanProvince') }\n        } else if (lat >= 22.0 && lat <= 23.6 && lng >= 112.9 && lng <= 114.0) {\n          return { region: this.$t('locationMgr.guangzhou'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.guangzhouCity'), state: this.$t('locationMgr.guangdongProvince') }\n        } else {\n          return { region: this.$t('locationMgr.china'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownProvince') }\n        }\n      }\n      \n      // /\n      if (lat >= 24.5 && lat <= 49.4 && lng >= -125 && lng <= -66) {\n        return { region: this.$t('locationMgr.usa'), country: this.$t('locationMgr.usa'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownState') }\n      } else if (lat >= 45.8 && lat <= 71.0 && lng >= -141 && lng <= -52) {\n        return { region: this.$t('locationMgr.canada'), country: this.$t('locationMgr.canada'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownProvince') }\n      } else if (lat >= 35.8 && lat <= 45.6 && lng >= 138.7 && lng <= 146.0) {\n        return { region: this.$t('locationMgr.japan'), country: this.$t('locationMgr.japan'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownPrefecture') }\n      } else if (lat >= 33.0 && lat <= 38.6 && lng >= 124.6 && lng <= 130.9) {\n        return { region: this.$t('locationMgr.korea'), country: this.$t('locationMgr.korea'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownProvince') }\n      } else if (lat >= 36.0 && lat <= 71.2 && lng >= -11.0 && lng <= 32.0) {\n        return { region: this.$t('locationMgr.europe'), country: this.$t('locationMgr.europe'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n      }\n      \n      // \n      if (lat >= -55 && lat <= 71) {\n        if (lng >= -168 && lng <= -30) {\n          return { region: this.$t('locationMgr.americas'), country: this.$t('locationMgr.americas'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n        } else if (lng >= -11 && lng <= 180) {\n          if (lat >= -47 && lng >= 110) {\n            return { region: this.$t('locationMgr.oceania'), country: this.$t('locationMgr.oceania'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n          } else {\n            return { region: this.$t('locationMgr.asia'), country: this.$t('locationMgr.asia'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n          }\n        }\n      } else if (lat >= -55 && lat <= 37 && lng >= -20 && lng <= 55) {\n        return { region: this.$t('locationMgr.africa'), country: this.$t('locationMgr.africa'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n      }\n      \n      // \n      return { \n        region: this.$t('locationMgr.unknown'), \n        country: this.$t('locationMgr.unknownRegion'), \n        city: this.$t('locationMgr.unknownCity'), \n        state: this.$t('locationMgr.unknownRegion') \n      }\n    },\n    formatLocationName: function (address) {\n      // \n      const city = address.city || address.town || address.village || address.county\n      const state = address.state || address.province\n      const country = address.country\n      \n      if (city && state) {\n        return `${city}, ${state}`\n      } else if (city) {\n        return city\n      } else if (state) {\n        return state\n      } else if (country) {\n        return country\n      } else {\n        return this.$t('locationMgr.unknownLocation')\n      }\n    },\n    formatBigDataCloudLocationName: function (data) {\n      // BigDataCloud API\n      const city = data.city || data.locality\n      const state = data.principalSubdivision\n      const country = data.countryName\n      \n      if (city && state) {\n        return `${city}, ${state}`\n      } else if (city) {\n        return city\n      } else if (state) {\n        return state\n      } else if (country) {\n        return country\n      } else {\n        return this.$t('locationMgr.unknownLocation')\n      }\n    },\n    formatOpenCageLocationName: function (components) {\n      // OpenCage API\n      const city = components.city || components.town || components.village || components.county\n      const state = components.state || components.province\n      const country = components.country\n      \n      if (city && state) {\n        return `${city}, ${state}`\n      } else if (city) {\n        return city\n      } else if (state) {\n        return state\n      } else if (country) {\n        return country\n      } else {\n        return this.$t('locationMgr.unknownLocation')\n      }\n    },\n    getMapStatusColor: function () {\n      switch (this.currentMapType) {\n        case 'online':\n          return 'green'\n        case 'offline':\n          return this.useOnlineMap ? 'orange' : 'blue'\n        case 'checking':\n          return 'grey'\n        default:\n          return 'red'\n      }\n    },\n    getMapStatusIcon: function () {\n      switch (this.currentMapType) {\n        case 'online':\n          return 'mdi-cloud-check'\n        case 'offline':\n          return 'mdi-cloud-off'\n        case 'checking':\n          return 'mdi-loading mdi-spin'\n        default:\n          return 'mdi-alert-circle'\n      }\n    },\n    getMapStatusText: function () {\n      switch (this.currentMapType) {\n        case 'online':\n          return this.$t('locationMgr.onlineMap')\n        case 'offline':\n          return this.useOnlineMap ? this.$t('locationMgr.offlineMapFallback') : this.$t('locationMgr.offlineMap')\n        case 'checking':\n          return this.$t('locationMgr.checking')\n        default:\n          return this.$t('locationMgr.connectionFailed')\n      }\n    },\n    onMapTypeToggle: function () {\n      // \n      console.log(':', this.useOnlineMap ? '' : '')\n      \n      if (this.useOnlineMap) {\n        // \n        this.detectAndSetMapType()\n      } else {\n        // \n        this.currentMapType = 'offline'\n        this.url = this.fallbackUrl\n        console.log(' ')\n        \n        // \n        this.$nextTick(() => {\n          if (this.$refs.myMap && this.$refs.myMap.mapObject) {\n            const map = this.$refs.myMap.mapObject\n            map.invalidateSize()\n            this.updateZoomLimits(map)\n          }\n        })\n      }\n    },\n    \n    // \n    checkNetworkConnection: function () {\n      return new Promise((resolve) => {\n        // 1: navigator.onLine\n        if (!navigator.onLine) {\n          console.log(': navigator.onLinefalse')\n          resolve(false)\n          return\n        }\n        \n        // 2: \n        const testUrls = [\n          // \n          'https://nominatim.openstreetmap.org/reverse?format=json&lat=40&lon=116&accept-language=en',\n          // \n          'https://www.openstreetmap.org/favicon.ico'\n        ]\n        \n        let completed = 0\n        let hasSuccess = false\n        const timeout = 3000 // 3\n        \n        testUrls.forEach((url, index) => {\n          // fetch\n          const controller = new AbortController()\n          const timeoutId = setTimeout(() => controller.abort(), timeout)\n          \n          fetch(url, {\n            method: 'HEAD',\n            mode: 'no-cors', // CORS\n            signal: controller.signal,\n            cache: 'no-cache'\n          })\n          .then(() => {\n            clearTimeout(timeoutId)\n            if (!hasSuccess) {\n              hasSuccess = true\n              console.log(`: ${url} `)\n              resolve(true)\n            }\n          })\n          .catch(error => {\n            clearTimeout(timeoutId)\n            completed++\n            console.log(`: ${url} :`, error.name)\n            if (completed === testUrls.length && !hasSuccess) {\n              console.log(': ')\n              resolve(false)\n            }\n          })\n        })\n        \n        // \n        setTimeout(() => {\n          if (!hasSuccess) {\n            console.log(': ')\n            resolve(false)\n          }\n        }, timeout + 500)\n      })\n    },\n    \n    // \n    checkOnlineMapAvailability: function () {\n      return new Promise((resolve) => {\n        const testUrls = [\n          'https://a.tile.openstreetmap.org/0/0/0.png',\n          'https://b.tile.openstreetmap.org/0/0/0.png',\n          'https://c.tile.openstreetmap.org/0/0/0.png'\n        ]\n        \n        let completed = 0\n        let hasSuccess = false\n        \n        testUrls.forEach(url => {\n          fetch(url, { \n            method: 'HEAD', \n            mode: 'no-cors',\n            cache: 'no-cache'\n          })\n          .then(() => {\n            if (!hasSuccess) {\n              hasSuccess = true\n              resolve(true)\n            }\n          })\n          .catch(() => {\n            completed++\n            if (completed === testUrls.length && !hasSuccess) {\n              resolve(false)\n            }\n          })\n        })\n        \n        // 3\n        setTimeout(() => {\n          if (!hasSuccess) {\n            resolve(false)\n          }\n        }, 3000)\n      })\n    },\n    \n    // \n    detectAndSetMapType: async function () {\n      this.currentMapType = 'checking'\n      console.log('...')\n      \n      try {\n        // \n        this.isNetworkConnected = await this.checkNetworkConnection()\n        console.log(':', this.isNetworkConnected)\n        \n        if (this.isNetworkConnected) {\n          // \n          this.isOnlineMapAvailable = await this.checkOnlineMapAvailability()\n          console.log(':', this.isOnlineMapAvailable)\n          \n          if (this.isOnlineMapAvailable) {\n            this.currentMapType = 'online'\n            this.url = this.onlineUrl\n            console.log(' ')\n          } else {\n            this.currentMapType = 'offline'\n            this.url = this.fallbackUrl\n            console.log(' ')\n          }\n        } else {\n          // \n          this.currentMapType = 'offline'\n          this.url = this.fallbackUrl\n          console.log(' ')\n        }\n        \n        // \n        this.$nextTick(() => {\n          if (this.$refs.myMap && this.$refs.myMap.mapObject) {\n            const map = this.$refs.myMap.mapObject\n            map.invalidateSize()\n            // \n            this.updateZoomLimits(map)\n          }\n        })\n        \n      } catch (error) {\n        console.error(':', error)\n        this.currentMapType = 'offline'\n        this.url = this.fallbackUrl\n        this.isNetworkConnected = false\n        this.isOnlineMapAvailable = false\n        console.log(' ')\n      }\n    },\n    \n    // \n    startNetworkMonitoring: function () {\n      // \n      window.addEventListener('online', () => {\n        console.log('')\n        // \n        if (this.useOnlineMap) {\n          this.detectAndSetMapType()\n        }\n      })\n      \n      window.addEventListener('offline', () => {\n        console.log('')\n        this.isNetworkConnected = false\n        this.isOnlineMapAvailable = false\n        this.currentMapType = 'offline'\n        this.url = this.fallbackUrl\n      })\n      \n      // \n      this.networkCheckInterval = setInterval(() => {\n        // \n        // 1. \n        // 2. \n        // 3. \n        if (this.useOnlineMap && \n            this.currentMapType === 'offline' && \n            navigator.onLine) {\n          console.log('')\n          this.detectAndSetMapType()\n        }\n      }, 60000) // 60\n    },\n    \n    // \n    dragEnd: function (event) {\n      const newPos = {\n        lat: event.target._latlng.lat,\n        lng: event.target._latlng.lng,\n        accuracy: 0\n      }\n      \n      console.log(':', newPos.lat.toFixed(6), newPos.lng.toFixed(6))\n      \n      // updateMapPosition\n      this.updateMapPosition(newPos.lat, newPos.lng, {\n        updateMarker: true,\n        fetchAddress: true,\n        animate: false,  // \n        accuracy: 0\n      })\n      \n      // \n      // this.$emit('resetLocation', newPos.lat, newPos.lng)\n    },\n    \n    // \n    flyToPosition: function (lat, lng, zoom = null) {\n      return this.updateMapPosition(lat, lng, {\n        animate: true,\n        zoom: zoom,\n        updateMarker: true,\n        fetchAddress: true\n      })\n    },\n    \n    // \n    setPosition: function (lat, lng, zoom = null) {\n      return this.updateMapPosition(lat, lng, {\n        animate: false,\n        zoom: zoom,\n        updateMarker: true,\n        fetchAddress: true\n      })\n    },\n    \n    // \n    centerMapAt: function (lat, lng, zoom = null, animate = true) {\n      return this.updateMapPosition(lat, lng, {\n        animate: animate,\n        zoom: zoom,\n        updateMarker: false,\n        fetchAddress: false\n      })\n    },\n    \n    \n    // \n    updateToKnownLocation: function (locationObj, animate = true) {\n      if (!locationObj || !this.isValidLocation(locationObj)) {\n        console.error(':', locationObj)\n        return false\n      }\n      \n      return this.updateMapPosition(locationObj.lat, locationObj.lng, {\n        animate: animate,\n        updateMarker: true,\n        fetchAddress: false,  // \n        accuracy: locationObj.accuracy || 0\n      })\n    }\n  },\n  components: { LMap, LTileLayer, LMarker, LCircle, LTooltip, LControlZoom }\n}\n</script>\n\n<style>\n.leaflet-control-geocoder-form input {\n  caret-color:#000 !important;\n  color: #000 !important;\n}\n\n/* Tooltip */\n.leaflet-tooltip {\n  font-size: 12px !important;\n  font-weight: 500 !important;\n}\n\n.leaflet-tooltip strong {\n  color: #ff9800 !important;\n}\n\n.leaflet-tooltip small {\n  font-style: italic;\n}\n\n/*  */\n.leaflet-marker-dragging {\n  transition: none !important;\n}\n</style>\n"]}]}